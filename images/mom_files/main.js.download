/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/components/setSGTrackingId.js":
/*!************************************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/components/setSGTrackingId.js ***!
  \************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 * @param {string} storeId - sg storeID
 *  the system should get the tracking ID and save it to a session cookie
 * @returns {*}- sessionstorage result
 */
function getTrackingId(storeId) {
  try {
    var result;
    var normalizedStoreId = storeId.replace(/-/g, '').toLowerCase();

    try {
      result = sessionStorage.getItem('sg.sid-' + normalizedStoreId);
    } catch (e) {
      if (window.name) {
        return atob(window.name);
      }
    }

    if (result) {
      return atob(result);
    } else if (window.name) {
      // failed to retrieve from session storage, tracking is set to a    backup window variable in the case it fails to set to session
      return atob(window.name);
    }

    return null;
  } catch (e) {
    // log error
    return null;
  }
}
/**
 * creating cookie for shoppinggives tracking ID
 */


function setSGTrackingIDToCookie() {
  var CONSTANTS = __webpack_require__(/*! ../utilities/constants */ "../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/utilities/constants.js");

  var cookie = __webpack_require__(/*! brand/components/cookie */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/cookie.js");

  var sgTrackingID = CONSTANTS.SG_TRACKING_ID;
  var $sgTrackingIdDiv = $('.sg-trackingId');
  var storeId = $sgTrackingIdDiv.length ? $sgTrackingIdDiv.data('sg-storeid') : null;
  var sgTrackingIDValue = storeId ? getTrackingId(storeId) : '';
  var sgTrackingIDCookie = cookie.getCookie(sgTrackingID);

  if (sgTrackingIDCookie === '' && sgTrackingIDValue || sgTrackingIDCookie !== sgTrackingIDValue) {
    cookie.createCookie(sgTrackingID, sgTrackingIDValue, CONSTANTS.MAX_AGE_FOR_COOKIE);
  }
}

module.exports = {
  setSGTrackingIDToCookie: setSGTrackingIDToCookie
};

/***/ }),

/***/ "../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/utilities/constants.js":
/*!*****************************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/utilities/constants.js ***!
  \*****************************************************************************************************************/
/***/ (function(module) {

var SG_TRACKING_ID = 'sgTrackingID';
var MAX_AGE_FOR_COOKIE = 604800;
module.exports = {
  SG_TRACKING_ID: SG_TRACKING_ID,
  MAX_AGE_FOR_COOKIE: MAX_AGE_FOR_COOKIE
};

/***/ }),

/***/ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/header.js":
/*!******************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/header.js ***!
  \******************************************************************************************************/
/***/ (function(module) {

"use strict";

/**
* handle syte intro popup through cookie
**/

function includeSyteCookie() {
  var url = $('#syteCookieUrl').val();
  $.ajax({
    url: url,
    type: 'get',
    success: function success(data) {
      if (!data.success) {
        $('.syte-intro-popup').addClass('d-none');
      } else {
        $('.syte-intro-popup').removeClass('d-none');
      }
    }
  });
}
/**
 * Init the Header fucntions
 * */


function initHeaderFunctions() {
  includeSyteCookie();
  $(document).on('click', '.syte-camera-icon, .syte-camera-icon-nosearch', function () {
    $('body').trigger('event:syteInternalCameraSearch');
  });
  $(document).on('click', function (event) {
    if (!($('.syte-intro-popup').has(event.target).length > 0 || $(event.target).hasClass('syte-intro-popup'))) {
      $('.syte-intro-popup').addClass('d-none');
    }
  });
}

module.exports = {
  initHeaderFunctions: initHeaderFunctions()
};

/***/ }),

/***/ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/syte.js":
/*!****************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/syte.js ***!
  \****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var clientSideUtil = __webpack_require__(/*! brand/utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var isDesktop = $(window).width() >= 768;
/**
 * @param  {integer} currentProductHeight - height of the product card before the carousel is appended
 * @param  {element} syteButton - syte button that has clicked
 */

function calculateCarouselPosition(currentProductHeight, syteButton) {
  // logic for top margin syte carousal
  var columnPosition;
  var productPosition = syteButton.parents('.product-tile-wrapper').index('.product-tile-wrapper');
  var $sytePlpContent = $('.syte-plp-content');
  var otherProductsArr = [];
  var otherProducts1Height;
  var otherProducts2Height;
  var otherProducts3Height;
  var firstProduct;
  var secondProduct;
  var thirdProduct;
  var fourthProduct;

  if (isDesktop) {
    columnPosition = productPosition % 4;

    switch (columnPosition) {
      case 0:
        secondProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 1, ")")).find('.product-tile-container-js');
        thirdProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 2, ")")).find('.product-tile-container-js');
        fourthProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 3, ")")).find('.product-tile-container-js');
        otherProducts1Height = secondProduct.length > 0 ? secondProduct.height() : 0;
        otherProducts2Height = thirdProduct.length > 0 ? thirdProduct.height() : 0;
        otherProducts3Height = fourthProduct.length > 0 ? fourthProduct.height() : 0;
        break;

      case 1:
        firstProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 1, ")")).find('.product-tile-container-js');
        secondProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 1, ")")).find('.product-tile-container-js');
        thirdProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 2, ")")).find('.product-tile-container-js');
        otherProducts1Height = firstProduct.length > 0 ? firstProduct.height() : 0;
        otherProducts2Height = secondProduct.length > 0 ? secondProduct.height() : 0;
        otherProducts3Height = thirdProduct.length > 0 ? thirdProduct.height() : 0;
        break;

      case 2:
        firstProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 2, ")")).find('.product-tile-container-js');
        secondProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 1, ")")).find('.product-tile-container-js');
        thirdProduct = $(".product-tile-wrapper:eq(".concat(productPosition + 1, ")")).find('.product-tile-container-js');
        otherProducts1Height = firstProduct.length > 0 ? firstProduct.height() : 0;
        otherProducts2Height = secondProduct.length > 0 ? secondProduct.height() : 0;
        otherProducts3Height = thirdProduct.length > 0 ? thirdProduct.height() : 0;
        break;

      default:
        firstProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 3, ")")).find('.product-tile-container-js');
        secondProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 2, ")")).find('.product-tile-container-js');
        thirdProduct = $(".product-tile-wrapper:eq(".concat(productPosition - 1, ")")).find('.product-tile-container-js');
        otherProducts1Height = firstProduct.length > 0 ? firstProduct.height() : 0;
        otherProducts2Height = secondProduct.length > 0 ? secondProduct.height() : 0;
        otherProducts3Height = thirdProduct.length > 0 ? thirdProduct.height() : 0;
        break;
    }

    otherProductsArr.push(otherProducts1Height, otherProducts2Height, otherProducts3Height);

    if (currentProductHeight >= Math.max.apply(Math, otherProductsArr)) {
      $sytePlpContent.css('margin-top', 24);
    } else {
      $sytePlpContent.css('margin-top', Math.max.apply(Math, otherProductsArr) - currentProductHeight + 24);
    }
  } else {
    var otherProductHeight;
    columnPosition = (productPosition + 1) % 2;

    if (columnPosition === 1) {
      otherProductHeight = $('.product-tile-wrapper:eq(' + (productPosition + 1) + ')').find('.product-tile-container-js').height();
    } else {
      otherProductHeight = $('.product-tile-wrapper:eq(' + (productPosition - 1) + ')').find('.product-tile-container-js').height();
    }

    if (otherProductHeight && currentProductHeight < otherProductHeight) {
      $sytePlpContent.css('margin-top', otherProductHeight - currentProductHeight + 20);
    } else {
      $sytePlpContent.css('margin-top', 20);
    }
  }
}
/**
 * Throws Error when data is not returned from SYTE
 * @param {element} syteContentElement - syte CTA that has clicked
 */


function loadSyteContent(syteContentElement) {
  var $syteContent = syteContentElement.closest('.syte-header').siblings('.syte-content');
  var $syteChildNode = $syteContent.find('#syte-similar-items-container');
  var $syteErrorContent = syteContentElement.find('.plp-carousel').attr('data-syte-error-msg');

  if ($syteChildNode.html() === '') {
    var $syteErrorMsg = '<div class="syte-shop-similar-error">' + $syteErrorContent + '</div>';
    $syteChildNode.append($syteErrorMsg);
    $syteContent.addClass('syte-down-error');
  }
}
/**
 * the carousel content for a syte plp
 */


function syteShopSimilar() {
  $(document).on('click', '.syte-plp-btn', function () {
    var currentProductHeight = $(this).parents('.product-tile-container-js').height();
    var $this = $(this);
    var $plpCarousel = $('.plp-carousel');
    var $productskuid = $this.find($plpCarousel).attr('data-sku-productid');
    var $productImageUrl = $this.find($plpCarousel).attr('data-image-url');
    var $syteContentTimeInterval = $this.find($plpCarousel).attr('data-syte-delay-time');
    var sytecontent = $this.closest('.syte-header').siblings('.syte-content');
    var prevSyteid = localStorage.getItem('product-id-syte');
    localStorage.setItem('product-id-syte', $productskuid);
    var syteid = localStorage.getItem('product-id-syte');
    $(sytecontent).toggleClass('active-syte-desc');

    if (syteid && syteid !== prevSyteid) {
      $('.syte-content').empty();
      $('.syte-plp-btn').removeClass('syte-caret');
      $('.syte-content[data-product-id=' + prevSyteid + ']').removeClass('active-syte-desc');
    }

    if (sytecontent.hasClass('active-syte-desc')) {
      $(this).addClass('syte-caret');
      $('.syte-content').removeClass('d-none');
      var syteCarouselhtml = "<div class='p-0 syte-plp-content'><div class='syte-pointer'></div><button class='cross-icon' type='button'></button><div id='syte-similar-items-container' data-sku='" + $productskuid + "' data-image-src='" + $productImageUrl + "'data-placement='plp_si_button'></div></div>";
      $(sytecontent).empty().append(syteCarouselhtml);
      var $syteSelectorParent = $(this).closest('.tile-body');
      calculateCarouselPosition(currentProductHeight, $this);
      var scrollValue = $syteSelectorParent.offset().top;
      clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
      $('.syte-plp-content').css('margin-left', -($(this).offset().left - $('.product-grid').offset().left));
      $('.syte-pointer').css('margin-left', $(this).offset().left - $('.product-grid').offset().left + 30);
      $('.syte-plp-content').css('width', $('.product-grid').width());
    } else {
      $(this).removeClass('syte-caret');
      $(sytecontent).empty();
      $('.syte-content').removeClass('active-syte-desc').addClass('d-none');
    }

    $('body').trigger('event:syteShopSimilarCarousel');
    setTimeout(function () {
      loadSyteContent($this);
    }, $syteContentTimeInterval);
  });
  $(document).on('click', '.cross-icon', function () {
    $(this).closest('.syte-content').removeClass('active-syte-desc');
    $('.syte-content').empty();
    $('.syte-plp-btn').removeClass('syte-caret');
  });
}
/**
 * visual search icon
 */


function syteGlobalSearch() {
  $('.search-field').on('input', function () {
    if ($(this).val().length > 0) {
      $('.syte-camera-icon').addClass('d-none');
      $('.syte-intro-popup').addClass('d-none');
    } else {
      $('.syte-camera-icon').removeClass('d-none');
    }
  });
  $('.nosearch-page-search-field').on('input', function () {
    if ($(this).val().length > 0) {
      $('.syte-camera-icon-nosearch').addClass('d-none');
    } else {
      $('.syte-camera-icon-nosearch').removeClass('d-none');
    }
  });
  $('.search-field', '.suggestions-wrapper_content').on('blur', function () {
    $('.syte-camera-icon').removeClass('d-none');
  });
  $('.site-search .clear-button').on('click touchstart', function () {
    $('.syte-camera-icon').removeClass('d-none');
  });
  $('.site-search .research-clear-button').on('click', function () {
    $('.syte-camera-icon-nosearch').removeClass('d-none');
  });
}
/**
 * Funtion to trigger mouse events
 */


function primaryImageHover() {
  $(document).on('mouseover', '.zoomContainer', function () {
    var bgImage = $(this).find('.zoomWindow').css('background-image');
    bgImage = bgImage.split('"')[1];
    $('*[data-zoom-image="' + bgImage + '"]').closest('.large-images').find('.productdetail-container').css('opacity', '1');
  });
  $(document).on('mouseover', '.productdetail-container', function () {
    $(this).css('opacity', '1');
  });
  $('body').on('click', '.syte-discovery', function () {
    $(this).parent().css('opacity', '0');
    $('body').trigger('event:syteShopSimilarCarousel');
  });
  $(document).on('mouseleave', '.zoomContainer', function () {
    var bgImage = $(this).find('.zoomWindow').css('background-image');
    bgImage = bgImage.split('"')[1];
    $('*[data-zoom-image="' + bgImage + '"]').closest('.large-images').find('.productdetail-container').css('opacity', '0');
  });
}
/**
* Syte Recommendation Carousel for content slot
*/


function syteRecommendationCarousel() {
  $(window).on('load', function () {
    var $syteRecommendationClass = $('.syte-recommendation');

    if ($syteRecommendationClass.length !== 0) {
      var syteContainerId = $syteRecommendationClass.data('id');
      var $productLineItemsId = $('.cart-head').data('productlineitem-id');

      if (syteContainerId === 'syte-fbt-container') {
        $syteRecommendationClass.attr('data-skus', $productLineItemsId);
      }

      $syteRecommendationClass.attr('id', syteContainerId);
    }
  });
}
/**
* Initilising wishlist for Syte Carousel
*/


function syteWishlistInitialize() {
  $(window).on('load', function () {
    var $syteAddToWishlist = $('.syteAddToWishlist');
    window.syteWishList = window.syteWishList || new Set();
    window.syteWishList.clear();
    var wishlistedSKUs = $('.wishlistedItems').length > 0 && $('.wishlistedItems').val() !== '' ? $('.wishlistedItems').val().split(',') : '';

    if (wishlistedSKUs.length > 0) {
      wishlistedSKUs.forEach(function (v) {
        return window.syteWishList.add(v);
      });
    }

    window.$('body').on('event:addProductToFavourites', function (e, data) {
      if ($syteAddToWishlist.length > 0) {
        window.syteWishList.add(data.pid);
      }
    });
    window.$('body').on('event:removeProductFromFavourites', function (e, data) {
      if ($syteAddToWishlist.length > 0) {
        window.syteWishList.delete(data.pid);
      }
    });
    window.$('body').on('event:addToCart', function (e, data) {
      if ($syteAddToWishlist.length > 0) {
        window.syteWishList.delete(data.productID);
      }
    });
    $(window).on('load', function () {
      if (localStorage.getItem('product-id-syte')) {
        localStorage.removeItem('product-id-syte');
      }
    });
  });
}
/**
* Eventlistner for SYTE add to wishlist functioanlity
*/


function syteAddToWishlist() {
  var wishlist = __webpack_require__(/*! ../product/wishlist */ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/product/wishlist.js");

  window.addEventListener('syte.addProductToWishList', function (data) {
    wishlist.addToWishlist(data);
  });
}
/**
* Eventlistner for SYTE remove from wishlist functionality
*/


function syteRemoveFromWishlist() {
  var wishlist = __webpack_require__(/*! ../product/wishlist */ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/product/wishlist.js");

  window.addEventListener('syte.removeProductFromWishList', function (data) {
    wishlist.removeFromWishlist(data);
  });
}

module.exports = {
  syteShopSimilar: syteShopSimilar,
  syteGlobalSearch: syteGlobalSearch,
  primaryImageHover: primaryImageHover,
  syteRecommendationCarousel: syteRecommendationCarousel,
  syteWishlistInitialize: syteWishlistInitialize,
  syteAddToWishlist: syteAddToWishlist,
  syteRemoveFromWishlist: syteRemoveFromWishlist
};

/***/ }),

/***/ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/product/wishlist.js":
/*!*****************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/product/wishlist.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var wishlistHelper = __webpack_require__(/*! brand/product/wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js");

var wishlistClientSideUtil = __webpack_require__(/*! brand/utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");
/**
 * @param {*} $element element from which we get the url
 * @returns {*} url
 */


function getSyteProductUrl($element) {
  var url = '';

  switch (true) {
    case $element.attr('href') && $element.attr('href').length > 0:
      url = $element.attr('href');
      break;

    case $element.data('href') && $element.data('href').length > 0:
      url = $element.data('href');
      break;

    case $element.data('url') && $element.data('url').length > 0:
      url = $element.data('url');
      break;

    default:
      break;
  }

  return url;
}
/**
 * @param {*} url Url string to be modified.
 * @param {*} pid New pid to be added to the URL
 * @returns {*} url with the new product ID
 */


function getSyteProductNewUrl(url, pid) {
  var urlArray = url.split('?pid=');
  var newUrl = urlArray[0] + '?pid=' + pid;
  return newUrl;
}

module.exports = {
  addToWishlist: function addToWishlist(syteData) {
    var url = $('.syteAddToWishlist').length > 0 ? getSyteProductUrl($('.syteAddToWishlist')) : undefined;
    var pid = syteData.detail.sku;

    if (!url || !pid) {
      return;
    }

    var optionId = $(this).closest('.product-detail').find('.product-option').attr('data-option-id');
    var optionVal = $(this).closest('.product-detail').find('.options-select option:selected').attr('data-value-id');
    $.spinner().start();
    $(this).attr('disabled', true);
    $.ajax({
      url: url,
      type: 'post',
      dataType: 'json',
      data: {
        pid: pid,
        optionId: optionId,
        optionVal: optionVal
      },
      success: function success(data) {
        var isSuccess = true;

        if (data.error) {
          isSuccess = false;

          if (data.msg) {
            wishlistClientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }
        } else {
          window.syteWishList.add(data.pid);
          wishlistHelper.fillHeaderHeart(data.wishlistedItems);
          wishlistHelper.popupdisplay(true, {
            addWishlist: true,
            removeWishlist: false,
            toastTime: data.toastMessageDisplayTime
          });
          $('.main-wishlist').empty().append(data.renderedTemplate);
        }

        $.spinner().stop();
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  },
  removeFromWishlist: function removeFromWishlist(syteData) {
    var pid = syteData.detail.sku;
    var url = $('.syteRemoveFromWishlist').length > 0 ? getSyteProductUrl($('.syteRemoveFromWishlist')) : undefined;
    var newUrl = getSyteProductNewUrl(url, pid);

    if (!url && !newUrl) {
      return;
    }

    $.spinner().start();
    $.ajax({
      url: newUrl,
      type: 'get',
      success: function success(data) {
        var isSuccess = true;

        if (data.error) {
          isSuccess = false;

          if (data.productRemovedMsg) {
            wishlistClientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }
        } else {
          window.syteWishList.delete(data.pid);
          wishlistHelper.fillHeaderHeart(data.wishlistedItems);
          wishlistHelper.popupdisplay(true, {
            addWishlist: false,
            removeWishlist: true,
            toastTime: data.toastMessageDisplayTime
          });
          $('.main-wishlist').empty().append(data.renderedTemplate);
        }

        $.spinner().stop();
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  }
};

/***/ }),

/***/ "../../capri-core-sfcc/src/integrations/link_bazaarvoice-release-20.1.0/cartridges/int_bazaarvoice_sfra_custom/cartridge/client/default/js/product/bvHelper.js":
/*!*********************************************************************************************************************************************************************!*\
  !*** ../../capri-core-sfcc/src/integrations/link_bazaarvoice-release-20.1.0/cartridges/int_bazaarvoice_sfra_custom/cartridge/client/default/js/product/bvHelper.js ***!
  \*********************************************************************************************************************************************************************/
/***/ (function(module) {

"use strict";
 // Observing BV DOM injection

var observingBV = function observingBV() {
  if ($('#data-bv-show').length) {
    var target = $(this); // Callback function to execute when mutations are observed

    var callback = function callback(mutationsList, observer) {
      var hasChildListMutation = mutationsList.filter(function (m) {
        return m.type === 'childList';
      }).length;

      if (hasChildListMutation) {
        var noOfReviews;
        var targetElement = $(mutationsList[0].target);

        if (targetElement.data('bv-show') === 'rating_summary') {
          noOfReviews = parseInt(targetElement.find('.bv_numReviews_text').text().replace(/[{()}]/g, ''), 10);
        } else {
          noOfReviews = parseInt(targetElement.find('.bv_text').text().replace(/[{()}]/g, ''), 10);
        }

        if (noOfReviews <= 0) {
          observer.disconnect();
          targetElement.addClass('d-none').attr('style', 'display: none !important;');
        } else if (noOfReviews > 0) {
          observer.disconnect();
          targetElement.find('.bv_button_buttonMinimalist').addClass('d-none').attr('style', 'display: none !important;');
        }
      }
    }; // Create an observer instance linked to the callback function


    var observerIns = new MutationObserver(callback); // Start observing the target node for configured mutations

    observerIns.observe(target.get(0), {
      childList: true,
      subtree: true
    });
  }
};

module.exports = {
  observingBV: observingBV
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/bootstrap.js":
/*!*******************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/bootstrap.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

__webpack_require__(/*! bootstrap/js/src/util.js */ "./node_modules/bootstrap/js/src/util.js");

__webpack_require__(/*! bootstrap/js/src/alert.js */ "./node_modules/bootstrap/js/src/alert.js"); // require('bootstrap/js/src/button.js');
// require('bootstrap/js/src/carousel.js');


__webpack_require__(/*! bootstrap/js/src/collapse.js */ "./node_modules/bootstrap/js/src/collapse.js"); // require('bootstrap/js/src/dropdown.js');


__webpack_require__(/*! bootstrap/js/src/modal.js */ "./node_modules/bootstrap/js/src/modal.js");

__webpack_require__(/*! bootstrap/js/src/scrollspy.js */ "./node_modules/bootstrap/js/src/scrollspy.js");

__webpack_require__(/*! bootstrap/js/src/tab.js */ "./node_modules/bootstrap/js/src/tab.js");

__webpack_require__(/*! bootstrap/js/src/tooltip.js */ "./node_modules/bootstrap/js/src/tooltip.js"); // require('bootstrap/js/src/popover.js');

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/cart/cartHelpers.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/cart/cartHelpers.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base = __webpack_require__(/*! ../product/base */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js");

var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() <= SCREENSIZE.TABLETMAX;
var isLandScape = $(window).height() <= SCREENSIZE.LANDSCAPEHEIGHTMAX;

var clientSideValidation = __webpack_require__(/*! ../components/clientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js");

var giftWrap = __webpack_require__(/*! ../checkout/giftWrap */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/giftWrap.js");

var wishlist = __webpack_require__(/*! ../product/wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js");

var shareFlyout = __webpack_require__(/*! ../shareFlyout */ "./cartridges/app_mk_storefront/cartridge/client/default/js/shareFlyout.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");

var notifyMe = __webpack_require__(/*! ../components/notifyMe */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/notifyMe.js");

var toastMessageFlag = true;
/**
 * appends params to a url
 * @param {string} url - Original url
 * @param {Object} params - Parameters to append
 * @returns {string} result url with appended parameters
 */

function appendToUrl(url, params) {
  var newUrl = url;
  newUrl += (newUrl.indexOf('?') !== -1 ? '&' : '?') + Object.keys(params).map(function (key) {
    return key + '=' + encodeURIComponent(params[key]);
  }).join('&');
  return newUrl;
}
/**
 * Checks whether the basket is valid. if invalid displays error message and disables
 * checkout button
 * @param {Object} data - AJAX response from the server
 */


function validateBasket(data) {
  var $toastError = $('.toast-alert-error.validate-basket').parents('.float-toast-errors');

  if (data.valid.error) {
    if (data.valid.message) {
      var errorHtml = '<div class="alert alert-danger alert-dismissible valid-cart-error ' + 'fade show" role="alert">' + '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' + '<span aria-hidden="true">&times;</span>' + '</button>' + data.valid.message + '</div>';
      $('.cart-error').append(DOMpurify.sanitize(errorHtml));
    } else {
      $('.cart').empty().append('<div class="row"> ' + '<div class="col-12 text-center"> ' + '<h1>' + DOMpurify.sanitize(data.resources.emptyCartMsg) + '</h1> ' + '</div> ' + '</div>');
      $('.number-of-items').empty().append(DOMpurify.sanitize(data.resources.numberOfItems));
      $('.minicart-quantity').empty().append(DOMpurify.sanitize(data.numItems));
      $('.minicart-link').attr({
        'aria-label': data.resources.minicartCountOfItems,
        title: data.resources.minicartCountOfItems
      });
      $('.minicart .popover').empty();
      $('.minicart .popover').removeClass('show');
    }

    $('.checkout-btn').addClass('disabled');
    $('.toast-alert-error.validate-basket').empty().append(DOMpurify.sanitize(data.valid.message));
    $toastError.removeClass('d-none');
    $('.toast-oos.toast-alert-error.validate-basket').removeClass('d-none');
    toastMessageFlag = false;
  } else {
    $('.checkout-btn').removeClass('disabled');
    $('.express-checkout-buttons').removeClass('disabled');
    $('.cart-error-notification').addClass('d-none');
    $('.toast-oos').addClass('d-none');
    $('.float-toast-message').remove();

    if (!$toastError.hasClass('d-none')) {
      $toastError.addClass('d-none');
    }

    toastMessageFlag = true;
  }
}
/**
 * re-renders the order totals and the number of items in the cart
 * @param {Object} data - AJAX response from the server
 */


function updateCartTotals(data) {
  var couponBlock = '';
  $('.number-of-items').empty().append(DOMpurify.sanitize(data.resources.numberOfItems));
  var shippingMethodName;

  if (data.noOfOnlyVGCItems > 0 || data.noOfOnlyVGCAndPIS > 0) {
    shippingMethodName = data.resources.onlyVGCShippingName;
  } else {
    shippingMethodName = data.shipments[0].selectedShippingMethodName;
  }

  $('.shipping-cost-row .shipping-method-cart').html(DOMpurify.sanitize(shippingMethodName + ' ' + '<span class="count-shipping-item-cart"> (' + data.noOfEcomItems + ')</span>'));
  $('.shipping-cost, .shipping-total-cost').empty().append(DOMpurify.sanitize(data.totals.ecomShipmentCost));
  $('.pickup-instore-cost').empty().append(DOMpurify.sanitize(data.totals.storeShipmentCost));
  $('.tax-total').empty().append(DOMpurify.sanitize(data.totals.totalTax));

  if (data.totals && data.totals.grandTotal.formatted) {
    $('.grand-total-sum').empty().append(DOMpurify.sanitize(data.totals.grandTotal.formatted));
  } else {
    $('.grand-total-sum').empty().append(DOMpurify.sanitize(data.totals.grandTotal));
  }

  $('.sub-total').empty().append(DOMpurify.sanitize(data.totals.subTotal));
  $('.order-summary-gift-card').empty().append(DOMpurify.sanitize(data.renderedPaymentInstruments));
  $('.js-shopping-quantity, .minicart-heading h1').empty().append(DOMpurify.sanitize(data.resources.numberOfItems));
  $('.js-sub-total').empty().append(DOMpurify.sanitize(data.totals.grandTotal.formatted));
  $('.js-shipping-quantity.shipToHome').empty().append(DOMpurify.sanitize(data.resources.noOfEcomItems));
  $('.js-shipping-quantity.pickupInStore, .pickup-instore-items').empty().append(DOMpurify.sanitize(data.resources.noOfStoreItems));
  $('.minicart-quantity').empty().append(DOMpurify.sanitize(data.numItems)).removeClass('invisible');
  $('.minicart-link').attr({
    'aria-label': data.resources.minicartCountOfItems,
    title: DOMpurify.sanitize(data.resources.minicartCountOfItems)
  });

  if (data.totals.couponDiscountsTotal && data.totals.couponDiscountsTotal.value && data.totals.couponDiscountsTotal.value < 0) {
    $('.order-coupon-total').empty().append(DOMpurify.sanitize(data.totals.couponDiscountsTotal.formatted));
    $('.order-coupon-total-checkout').empty().append(DOMpurify.sanitize(data.totals.couponDiscountsTotal.formatted));
  } else {
    DOMpurify.sanitize($('.order-coupon-total').empty().append('--'));
    $('.order-coupon-total-checkout').empty().append('--');
  }

  if (data.totals.orderLevelDiscountTotal.value > 0) {
    $('.order-discount').removeClass('hide-order-discount');
    $('.order-discount-total').empty().append('- ' + DOMpurify.sanitize(data.totals.orderLevelDiscountTotal.formatted));
  } else {
    $('.order-discount').addClass('hide-order-discount');
  }

  if (data.totals.shippingLevelDiscountTotal.value > 0) {
    $('.shipping-discount').removeClass('hide-shipping-discount');
    $('.shipping-discount-total').empty().append('- ' + DOMpurify.sanitize(data.totals.shippingLevelDiscountTotal.formatted));
  } else {
    $('.shipping-discount').addClass('hide-shipping-discount');
  }

  if (!jQuery.isEmptyObject(data.totals.additionalTaxes)) {
    if (data.totals.additionalTaxes.taxGSTHST || data.totals.additionalTaxes.taxPSTQST) {
      $('.sales-tax-item').addClass('d-none');
    }

    if (data.totals.additionalTaxes.taxGSTHST && data.totals.additionalTaxes.taxGSTHST.enabled && data.totals.additionalTaxes.taxGSTHST.price.value >= 0) {
      $('.taxGSTHST-cost').text(data.totals.additionalTaxes.taxGSTHST.price.formatted);
      $('.taxGSTHST-label').text(data.totals.additionalTaxes.taxGSTHST.label);
      $('.taxGSTHST-label').parent().parent().removeClass('hide-additional-taxes');
    } else {
      $('.taxGSTHST-label').parent().parent().addClass('hide-additional-taxes');
    }

    if (data.totals.additionalTaxes.taxPSTQST && data.totals.additionalTaxes.taxPSTQST.enabled && data.totals.additionalTaxes.taxPSTQST.price.value >= 0) {
      $('.taxPSTQST-cost').text(data.totals.additionalTaxes.taxPSTQST.price.formatted);
      $('.taxPSTQST-label').text(data.totals.additionalTaxes.taxPSTQST.label);
      $('.taxPSTQST-label').parent().parent().removeClass('hide-additional-taxes');
    } else {
      $('.taxPSTQST-label').parent().parent().addClass('hide-additional-taxes');
    }
  }

  data.totals.discounts.forEach(function (couponval) {
    var code;
    var uuid;
    var promoActionUrl = data.actionUrls.removeCouponLineItem;

    if (couponval.applied) {
      code = couponval.couponCode;
      uuid = couponval.UUID;
      couponBlock += '<div class="coupon-price-adjustment coupon-uuid-' + uuid + '" data-uuid="' + uuid + '"><div class="coupon-code text-uppercase">' + couponval.couponCode + '<button data-uuid="' + uuid + '" data-code="' + code + '" data-action="' + promoActionUrl + '"class="float-right pr-0 bg-transparent border-0 delete-coupon-confirmation-btn"><span aria-hidden="true">×</span></button></div></div>';
      $('.appliedcode').html(DOMpurify.sanitize(couponBlock));
    }
  });
  data.items.forEach(function (item) {
    if (data.totals.orderLevelDiscountTotal.value > 0) {
      $('.coupons-and-promos').empty().append(DOMpurify.sanitize(data.totals.discountsHtml));
    }

    if (item.renderedPromotions) {
      $('.item-' + item.UUID).empty().append(DOMpurify.sanitize(item.renderedPromotions));
    } else {
      $('.item-' + item.UUID).empty();
    }

    $('.uuid-' + item.UUID + ' .unit-price').empty().append(item.renderedPrice);
    $('.line-item-price-' + item.UUID + ' .unit-price').empty().append(DOMpurify.sanitize(item.priceTotal.renderedPrice));
    $('.item-total-' + item.UUID).empty().append(item.priceTotal.renderedPrice);
  });

  if (data.totals.klarnaTotal) {
    $('klarna-placement').attr('data-purchase-amount', DOMpurify.sanitize(data.totals.klarnaTotal));
    window.KlarnaOnsiteService = window.KlarnaOnsiteService || [];
    window.KlarnaOnsiteService.push({
      eventName: 'refresh-placements'
    });
  }
  /*
      afterPay calculation after the cart-updation
  */


  var afterPayPlacementLength = $('.afterpay-messaging afterpay-placement').length;

  if (data.isCartAfterpayEligible) {
    if (afterPayPlacementLength > 0) {
      if (data.totals && data.totals.grandTotal) {
        // updates afterPay amount
        if ($('.afterpay-messaging afterpay-placement').length > 0) {
          // unhides afterPay payment
          $('.afterpay-messaging afterpay-placement, .afterpay-messaging').removeClass('d-none');
        }

        $('.afterpay-messaging afterpay-placement').attr('data-amount', DOMpurify.sanitize(data.totals.grandTotal.value || data.totals.grandTotal));
      }
    } else {
      $('body').find('.afterpay-messaging').append(DOMpurify.sanitize(data.renderedTemplate)); // renders afterPay when it is eligible after updating the cart
    }
  } else if (afterPayPlacementLength > 0) {
    // hide afterPay payment method when it is not applicable for updated cart
    $('.afterpay-messaging afterpay-placement, .afterpay-messaging').addClass('d-none');
  }
  /*
     klarna Payment calculation after the cart update
  */


  if (data.isKlarnaEligible) {
    $('.klarna-cart-message').removeClass('d-none');
  } else {
    $('.klarna-cart-message').addClass('d-none');
  }
}
/**
 * update the last class on the last Product lineitem when PIS product exist in cart
 * @param {Object} data - AJAX response from the server
 */


function updateProductLineItemBorder(data) {
  if (data.noOfStoreItems > 0) {
    $('.cartproduct-card.last').removeClass('last');
    $('.shipToHome_section .js-cart-product-section:last-child .cartproduct-card').addClass('last');
  } else {
    $('.cartproduct-card.last').removeClass('last');
  }
}
/**
 * re-renders the order totals and the number of items in the cart
 * @param {Object} message - Error message to display
 */


function createErrorNotification(message) {
  if (message) {
    $('.cart-error-notification').empty().append(DOMpurify.sanitize(message));
    $('.cart-error-notification').removeClass('d-none');
    $('.toast-oos').addClass('d-none');
    $('.float-toast-message').remove();
  }
}
/**
 * re-renders the approaching discount messages
 * @param {Object} approachingDiscounts - updated approaching discounts for the cart
 */


function updateApproachingDiscounts(approachingDiscounts) {
  var html = '';
  $('.approaching-discounts').empty();

  if (approachingDiscounts.length > 0) {
    approachingDiscounts.forEach(function (item) {
      html += '<div class="single-approaching-discount text-center">' + item.discountMsg + '</div>';
    });
  }

  $('.approaching-discounts').append(html);
}
/**
 * Updates the quantity of a product line item
 * @param {Object} lineItem - AJAX response from the server
 * @param {string} uuid - The uuid of the product line item to update
 */


function cartUpdateQuantity(lineItem, uuid) {
  var max = lineItem.quantityOptions.maxOrderQuantity;
  var min = lineItem.quantityOptions.minOrderQuantity;
  var length = $('#quantity-' + uuid).find('option').length;

  for (var j = 0; j < length; j++) {
    var $option = $('option:eq(' + j + ')');
    var val = $option.val();

    if (!(val >= min && val <= max)) {
      $option.addClass('d-none');
    } else {
      $option.removeClass('d-none');
    }
  }
}
/**
 * Updates the availability of a product line item
 * @param {Object} data - AJAX response from the server
 * @param {string} uuid - The uuid of the product line item to update
 */


function updateAvailability(data, uuid) {
  var lineItem;
  var messages = '';

  for (var i = 0; i < data.items.length; i++) {
    if (data.items[i].UUID === uuid) {
      lineItem = data.items[i];
      break;
    }
  }

  cartUpdateQuantity(lineItem, uuid);

  if (lineItem != null) {
    $('.availability-' + lineItem.UUID).empty();

    if (lineItem.availability) {
      if (lineItem.availability.messages) {
        lineItem.availability.messages.forEach(function (message) {
          messages += '<p class="line-item-attributes product-promocode product-available text-uppercase">' + message + '</p>';
        });
      }

      if (lineItem.availability.inStockDate) {
        messages += '<p class="line-item-attributes line-item-instock-date product-promocode product-available text-uppercase">' + lineItem.availability.inStockDate + '</p>';
      }
    }

    $('.availability-' + lineItem.UUID).html(messages);
  }
}
/**
 * Finds an element in the array that matches search parameter
 * @param {array} array - array of items to search
 * @param {function} match - function that takes an element and returns a boolean indicating if the match is made
 * @returns {Object|null} - returns an element of the array that matched the query.
 */


function findItem(array, match) {
  // eslint-disable-line no-unused-vars
  for (var i = 0, l = array.length; i < l; i++) {
    if (match.call(this, array[i])) {
      return array[i];
    }
  }

  return null;
}
/**
 * Updates details of a product line item
 * @param {Object} data - AJAX response from the server
 * @param {string} uuid - The uuid of the product line item to update
 * @param {string} shipmentType - Type of Shipment
 * @param {boolean} updateLineOnly - update only current line item
 */


function updateProductDetails(data, uuid, shipmentType, updateLineOnly) {
  var isFulfillmentChanged = data.shipmentChanged;
  var indexOfCartItem = DOMpurify.sanitize(data.indexOfCartItem) || 0;
  var targetElement;

  if (isFulfillmentChanged) {
    if (shipmentType === 'storePickup') {
      $('.cartproduct-card.uuid-' + uuid).parent('.js-cart-product-section').remove();
      targetElement = $('.pickupInStore_section .js-cart-product-section:nth-child(' + indexOfCartItem + ')');
      var template = data.renderedTemplate;
      template = template.replace('modaltoogle', 'toogle' + indexOfCartItem);
      template = template.replace('#modaltoogle', '#toogle' + indexOfCartItem);

      if (targetElement.length > 0) {
        $(targetElement).after(DOMpurify.sanitize(template));
      } else {
        $('.pickupInStore_section .product-card-section').append(DOMpurify.sanitize(template));
      }

      $('.pickupInStore_section').removeClass('d-none');
      $('.pickup-instore-row').removeClass('d-none');

      if (data.cartModel.noOfEcomItems === 0) {
        $('.shipToHome_section').addClass('d-none');
        $('.shipping-cost-row').addClass('d-none');
      }
    } else {
      $('.pickupInStore_section .cartproduct-card.uuid-' + uuid).parent('.js-cart-product-section').remove();
      $('.shipToHome_section .product-card-section').html(DOMpurify.sanitize(data.renderedTemplate));
      $('.shipToHome_section').removeClass('d-none');
      $('.shipping-cost-row').removeClass('d-none');

      if (data.cartModel.noOfStoreItems === 0) {
        $('.pickupInStore_section').addClass('d-none');
        $('.pickup-instore-row').addClass('d-none');
      }
    }
  } else if (updateLineOnly) {
    $('.cartproduct-card.uuid-' + uuid).replaceWith(DOMpurify.sanitize(data.renderedTemplate));
  } else {
    $('.shipToHome_section .product-card-section').html(DOMpurify.sanitize(data.renderedTemplate));

    if (data.cartModel.noOfEcomItems > 0) {
      $('.shipToHome_section').removeClass('d-none');
      $('.shipping-cost-row').removeClass('d-none');
    }

    if (data.cartModel.noOfStoreItems === 0) {
      $('.pickupInStore_section').addClass('d-none');
      $('.pickup-instore-row').addClass('d-none');
    }
  }
}
/**
 * Generates the modal window on the first call.
 * @param {string} selector - Modal id and ada label
 * @param {Object} classes - Classes for modal customization
 */


function getModalHtmlElement() {
  var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'editProductModal';
  var classes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    container: '',
    content: '',
    footer: ''
  };

  if ($('#editProductModal').length !== 0) {
    $('#editProductModal').remove();
  }

  if ($('#notifyme-modal').length !== 0) {
    $('#notifyme-modal').remove();
  }

  var adaLabel = selector === 'editProductModal' ? 'edit-modal' : selector;
  var htmlString = '<!-- Modal -->' + '<div class="modal right fade edit-product-modal pr-0 ' + classes.container + '" id="' + selector + '" tabindex="-1" role="dialog" aria-label="' + adaLabel + '">' + '<span class="enter-message sr-only" ></span>' + '<div class="modal-dialog quick-view-dialog cart-quick-view-dialog">' + '<!-- Modal content-->' + '<div class="modal-content rounded-0 ' + classes.content + '">' + '<div class="modal-header rounded-0">' + '    <button type="button" class="close pull-right" data-dismiss="modal">' + '        <span class="sr-only"> </span>' + '    </button>' + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer ' + classes.footer + '"></div>' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
 * Parses the html for a modal window
 * @param {string} html - representing the body and footer of the modal window
 *
 * @return {Object} - Object with properties body and footer.
 */


function parseHtml(html) {
  var $html = $('<div>').append($.parseHTML(html));
  var body = $html.find('.product-quickview');
  var footer = $html.find('.modal-footer').children();
  return {
    body: body,
    footer: footer
  };
}
/**
 * Restrict white space in textarea
 */


function submitWriteUs() {
  $(document).on('submit', '.contact-us', function (e) {
    e.preventDefault();
    var form = $('form.contact-us');
    var formObj = form.get(0);
    var formValid = clientSideValidation.functions.validateForm(formObj);
    var url = form.attr('action');

    if (formValid) {
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: form.serialize(),
        success: function success(data) {
          if (data.success) {
            $('.modal-content').empty().append(DOMpurify.sanitize(data.renderingTemplate));
            $('.contact-us').trigger('reset');
            clientSideValidation.invalid();
            clientSideValidation.submit();
            clientSideValidation.buttonClick();
            $.spinner().stop();
          }
        },
        error: function error() {
          $.spinner().stop();
        }
      });
    }
  });
}
/**
 * load notify me form
 * @param {string} pid - product ID
 * @param {Object} $selector - selector for form container
 * @param {string} url - url to GET form from
 */


function loadNotifyMeForm(pid, $selector, url) {
  $.ajax({
    url: url + '&formOnly=true',
    method: 'GET',
    dataType: 'json',
    success: function success(data) {
      if (data.success) {
        $selector.empty();
        $selector.html(DOMpurify.sanitize(data.renderedTemplate));
        $('#notify-email').focus();
      } else {
        $selector.html('');
      }
    },
    error: function error() {
      $selector.html('');
    }
  });
}
/**
 * replaces the content in the modal window
 * @param {string} modalDataUrl - url to be used to retrieve model data
 * @param {string} modalSelector - Modal id and ada label
 */


function populateModalElement(modalDataUrl, modalSelector) {
  var $elementID = $('#' + modalSelector);
  $elementID.find('.modal-body').spinner().start();
  $.ajax({
    url: modalDataUrl,
    method: 'GET',
    dataType: 'json',
    success: function success(data) {
      if (data.success) {
        var parsedHtml = parseHtml(data.renderedTemplate);
        $elementID.find('.modal-body').empty();
        $elementID.find('.modal-body').html(parsedHtml.body);
        $('.edit-product-modal .loyal-details-container').removeClass('d-flex').addClass('d-none');
        $elementID.find('.modal-footer').html(parsedHtml.footer);
        $elementID.find('.modal-header .close .sr-only').text(data.closeButtonText);
        $elementID.find('.enter-message').text(data.enterDialogMessage);
        $elementID.modal('show');
        $('body').on('click', '#notifyme-cancel', function () {
          $elementID.modal('hide');
        });
        $('#notify-email').focus();
        $('body').trigger('event:notifyMeEvent', data);
      } else {
        clientSideUtil.floatToastMessage(data.errorMsg, data.toastMessageDisplayTime, false);
        $elementID.modal('hide');
      }

      $.spinner().stop();
    },
    error: function error() {
      $.spinner().stop();
    }
  });
}
/**
 * to make order summary checkout CTA sticky in mobile & mobile landscape mode
 */


function stickyCheckoutCTA() {
  if (isMobile && $('.js-checkout-CTA').length > 0 || isLandScape && $('.js-checkout-CTA').length > 0) {
    var $checkoutCTA = $('.js-checkout-CTA');
    var $orderSummaryEl = $('.js-order-summary');
    var orderSummaryBox = $orderSummaryEl.offset().top + $orderSummaryEl.height() + window.innerHeight - $('header').height();
    $(window).scroll(function () {
      var currentTopPos = window.innerHeight + $(window).scrollTop();
      var heightCheckoutButtons = $('.js-checkout-CTA').innerHeight();

      if (currentTopPos > orderSummaryBox) {
        $checkoutCTA.addClass('sticky-btn');
        $('body').css('margin-bottom', heightCheckoutButtons + 'px');
      } else {
        $checkoutCTA.removeClass('sticky-btn');
        $('body').css('margin-bottom', 0);
      }
    });
  }
}
/**
 * to check if user session was expired
 */


function checkCSRFexpiration() {
  var url = window.location.href;

  if (url.includes('#csrf-expiration')) {
    $('.csrf-error').removeClass('d-none');
  }
}
/**
 * to update loyalty points on cart
 * @param {Object} data - AJAX response from the server
 */


function loyaltyPointsCartEdit(data) {
  if (data.loyaltyData) {
    $('.cart-korsVIP-container .potential-points-border').html('+' + data.loyaltyData.pointsCouldEarned);
    $('.cart-korsVIP-container .pointscouldEarn').html('+' + data.loyaltyData.pointsCouldEarned);

    if (data.loyaltyData.totalLoyaltyPoints) {
      $('.cart-korsVIP-container .earned-total-point').html('+' + data.loyaltyData.totalLoyaltyPoints);
    }
  }
}
/**
 * updateCartAndWishlist - updates cart after move fav to cart
 * @param {string} addToCartUrl - add to cart url
 * @param {Object} form - add to cart url
 */


function updateCartAndWishlist(addToCartUrl, form) {
  $(this).trigger('updateAddToCartFormData', form);

  if (addToCartUrl) {
    $.spinner().start();
    $.ajax({
      url: addToCartUrl,
      method: 'POST',
      data: form,
      success: function success(data) {
        var isSuccess = true;
        var editWishlistModal = $('#editWishlistProductModal');

        if (editWishlistModal) {
          editWishlistModal.modal('hide');
        }

        if (DOMpurify.sanitize(data.wishlistOOSError)) {
          $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
          var el = $('.product-grid:visible').find('.product-info.pid-' + DOMpurify.sanitize(data.productID) + '.product-tile-wrapper');
          el.find('.invalid-feedback').css('display', 'block').addClass('visible').empty().append(DOMpurify.sanitize(data.OOSProductErrorMsg));
          el.find('.secondary-button-custom').addClass('is-invalid').closest('.buttons-wishlist');
          el.find('.sold-out').addClass('d-none');
          el.find('.remove-sold-out').removeClass('d-none');
          wishlist.errorMessages();
          wishlist.updateHeaderHeartIcon(data.wishlistedItems);
          $.spinner().stop();

          if ($('.float-toast-message-perma').children('.float-toast-errors').length !== 0) {
            $('.cart-toasters').find('.toast-alert-error.wishlist-error').removeClass('d-none').empty().append(DOMpurify.sanitize(data.message));
            var toastMargin = $('.float-toast-message-perma').height() + 18;
            $('.cart-toasters .float-toast-message').css('margin-top', toastMargin);
          }
        } else if (data.cart.numItems - 1 === 0) {
          if (data.cart.onlyGiftCards && data.cart.onlyGiftCards != null) {
            $('.vat-block').addClass('d-none');
          } else {
            $('.vat-block').removeClass('d-none');
          }

          $('body').trigger('event:favAddToCart', data);
          clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, isSuccess);
          location.reload();
        } else {
          if (data.cart.onlyGiftCards && data.cart.onlyGiftCards != null) {
            $('.vat-block').addClass('d-none');
          } else {
            $('.vat-block').removeClass('d-none');
          }

          $('body').trigger('product:afterAddToCart', data.message);
          $.spinner().stop();
          base.miniCartReportingUrl(data.reportingURL);
          $('.minicart-quantity').html(DOMpurify.sanitize(data.quantityTotal)).removeClass('invisible');
          var isProductAdded = true;
          $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime]);
          var selector = '.minicart .popover';
          var timer = setTimeout(function () {
            $(selector).removeClass('show');
          }, data.miniBagFlyOutTimeinMilliSec);
          $('.minicart .popover').on('mouseenter', function () {
            clearTimeout(timer);
          });
          $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
          $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));
          $('.cart-toasters .toast-alert-error.wishlist-error').addClass('d-none').empty();
          wishlist.updateHeaderHeartIcon(data.wishlistedItems);

          if (data.cartRenderedTemplate) {
            $('.shipToHome_section .product-card-section').empty().append(DOMpurify.sanitize(data.cartRenderedTemplate));
            $('.count-shipping-item-cart').empty().append('(' + DOMpurify.sanitize(data.cart.noOfEcomItems) + ')');
            $('.coupons-and-promos').empty().append(DOMpurify.sanitize(data.cart.totals.discountsHtml));
            updateCartTotals(data.cart);

            if (data.cart.totals && data.cart.totals.giftwrapTotals) {
              giftWrap.updateGiftWrapSummary(data.cart.totals.giftwrapTotals);
            }

            updateProductLineItemBorder(data.cart);
            updateApproachingDiscounts(data.cart.approachingDiscounts);
            $('body').trigger('setShippingMethodSelection', data.cart);
            validateBasket(data.cart);

            if (data.cart.noOfEcomItems === 0) {
              $('.shipToHome_section').addClass('d-none');
              $('.shipping-cost-row').addClass('d-none');
            }

            if (data.cart.noOfStoreItems === 0) {
              $('.pickupInStore_section').addClass('d-none');
              $('.pickup-instore-row').addClass('d-none');
            }

            loyaltyPointsCartEdit(data);
          }

          $('.sub-total-wishlist').html($('.favourite-count').html());
          wishlist.borderBottomInRows();

          if (toastMessageFlag) {
            clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, isSuccess);
          }

          $('body').trigger('event:addToCart', data);
        }

        if (data.cart && typeof data.cart.employeeCouponApplied !== 'undefined') {
          $('body').trigger('event:updateEmployeeStatus', data.cart.employeeCouponApplied);
        }
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  }
}
/**
 * Get Items in Cart
 * @returns {Object} - itemsInCart : returns the Array of items in cart
 */


function getItemsInCart() {
  var itemsInCart = [];
  $('.cartproduct-card').each(function (_i, el) {
    itemsInCart.push($(el).attr('data-item-uuid'));
  });
  return itemsInCart;
}
/**
 * Remove items in cart without refreshing
 * @param {Object} basketItems :updated basket items
 * @param {Object} itemsInCart : Existing cart items
 */


function itemsToMove(basketItems, itemsInCart) {
  var updatedCart = basketItems.map(function (item) {
    return item.UUID;
  });
  itemsInCart.forEach(function (item) {
    if (updatedCart.indexOf(item) < 0) {
      $('.uuid-' + item).parent('.js-cart-product-section').remove();
    }
  });
}

module.exports = function () {
  $(window).on('load', function () {
    if ($('.float-toast-message-perma').children('.float-toast-errors').length !== 0) {
      $('.cart-toasters').append('<div class="float-toast-message"></div>');
      var toastMargin = $('.float-toast-message-perma').height() + 18;
      $('.cart-toasters .float-toast-message').css('margin-top', toastMargin);
    }
  });
  $('body').on('click', '.remove-product', function (e) {
    e.preventDefault();
    var productID = $(this).data('pid');
    var url = $(this).data('action');
    var uuid = $(this).data('uuid');
    var isSuccess = true;
    var urlParams = {
      pid: productID,
      uuid: uuid
    };
    var itemsInCart = getItemsInCart();
    url = appendToUrl(url, urlParams);
    $('body > .modal-backdrop').remove();

    if ($(this).hasClass('cart-remove-btn')) {
      $.spinner().start();
    }

    $('.popover .minicart-products').spinner().start();
    $('body').trigger('cart:beforeUpdate');
    $.ajax({
      url: url,
      type: 'get',
      dataType: 'json',
      success: function success(data) {
        var isProductRemoved = true;

        if (data.basket.items.length === 0) {
          if ($('.cart-page').length) {
            location.reload(); // reloading the cart page because the slots won't be there in rendered template
          } else {
            // mini cart scenario
            $('.number-of-items').html(DOMpurify.sanitize(data.basket.resources.numberOfItems));
            $('.minicart-quantity').html(DOMpurify.sanitize(data.basket.numItems)).addClass('invisible');
          }
        } else {
          itemsToMove(data.basket.items, itemsInCart);
          $('.uuid-' + uuid).remove();

          if (data.basket.onlyGiftCards != null && data.basket.onlyGiftCards) {
            $('.vat-block').addClass('d-none');
          } else {
            $('.vat-block').removeClass('d-none');
          }

          if ($('.pickupInStore_section').find('.cartproduct-card').length === 0) {
            $('.pickupInStore_section').addClass('d-none');
          }

          if (!data.basket.hasBonusProduct) {
            $('.bonus-product').remove();
          }

          $('.count-shipping-item-cart').empty().append('(' + DOMpurify.sanitize(data.basket.noOfEcomItems) + ')');
          $('.coupons-and-promos').empty().append(DOMpurify.sanitize(data.basket.totals.discountsHtml));
          updateCartTotals(data.basket);

          if (data.basket.totals && data.basket.totals.giftwrapTotals) {
            giftWrap.updateGiftWrapSummary(data.basket.totals.giftwrapTotals);
          }

          updateProductLineItemBorder(data.basket);
          updateApproachingDiscounts(data.basket.approachingDiscounts);
          $('body').trigger('setShippingMethodSelection', data.basket);
          validateBasket(data.basket);

          if (data.basket.noOfEcomItems === 0) {
            $('.shipToHome_section').addClass('d-none');
            $('.shipping-cost-row').addClass('d-none');
          }

          if (data.basket.noOfStoreItems === 0) {
            $('.pickupInStore_section').addClass('d-none');
            $('.pickup-instore-row').addClass('d-none');
          }

          loyaltyPointsCartEdit(data);
        }

        $('.popover .minicart-products').spinner().stop();
        $('body').trigger('cart:update', data);
        $('.minicart').trigger('minicart:remove', [isProductRemoved, data.toastMsgAndTimeOutSec.toastMessageDisplayTime, data.basket.resources.minicartCountOfItems]);
        $('.toast-remove').removeClass('d-none');
        $('.toast-success').addClass('d-none');
        clientSideUtil.clearAndSetTime('.toast-basket-alert.toast-remove', data.toastMsgAndTimeOutSec.toastMessageDisplayTime);

        if ($('.remove-product').parents('.cartproduct-card').length > 0) {
          clientSideUtil.floatToastMessage(data.toastMsgAndTimeOutSec.message, data.toastMsgAndTimeOutSec.toastMessageDisplayTime, isSuccess);
        }

        $('body').trigger('event:productRemoveFromCart', data);

        if (data.basket && typeof data.basket.employeeCouponApplied !== 'undefined') {
          $('body').trigger('event:updateEmployeeStatus', data.basket.employeeCouponApplied);
        }
      },
      error: function error(err) {
        isSuccess = false;

        if (err.responseJSON.redirectUrl) {
          window.location.href = err.responseJSON.redirectUrl;
        } else {
          if ($('.remove-product').parents('.cartproduct-card').length > 0) {
            clientSideUtil.floatToastMessage(err.responseJSON.errorMessage, err.responseJSON.toastMsgAndTimeOutSec.toastMessageDisplayTime, isSuccess);
          }

          $.spinner().stop();
        }
      }
    });
  });
  $(document).on('click', '.static-text-content-section .create-btn', function () {
    var url = $('.write-us-now').attr('href');
    $.ajax({
      url: url,
      type: 'get',
      success: function success(data) {
        $('.modal-content').empty().append(DOMpurify.sanitize(data.contactUsHtmlTemplate));
        clientSideValidation.invalid();
        clientSideValidation.submit();
        clientSideValidation.buttonClick();
        submitWriteUs();
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  });
  $('body').on('shipmentChanged', function (e, response) {
    var data = response.data;
    var shipmentType = response.shipmentType;

    if (data) {
      updateCartTotals(data.cartModel);
      updateApproachingDiscounts(data.cartModel.approachingDiscounts);
      updateAvailability(data.cartModel, data.uuid);
      updateProductDetails(data, data.uuid, shipmentType);
      updateProductLineItemBorder(data.cartModel);
      validateBasket(data.cartModel);
      $('body').trigger('cart:update', data);
      $.spinner().stop();
      $('#inStoreInventoryModal').modal('hide').attr('showQuickView', false);
      clientSideUtil.floatToastMessage(data.toastMsgAndTimeOutSec.message, data.toastMsgAndTimeOutSec.toastMessageDisplayTime, true);
    }
  });
  $('body').on('hidden.bs.modal', '#chooseBonusProductModal', function () {
    $('#chooseBonusProductModal').remove();
    $('.modal-backdrop').remove();
    $('body').removeClass('modal-open');

    if ($('.cart-page').length) {
      $('.launched-modal .btn-outline-primary').trigger('focus');
      $('.launched-modal').removeClass('launched-modal');
    } else {
      $('.product-detail .add-to-cart').focus();
    }
  });
  $(document).on('click', '.notify-me-btn', function (e) {
    e.preventDefault();
    var notifyMeProductUrl = $(this).attr('href');
    getModalHtmlElement('notifyme-modal', {
      container: 'notifyme-modal',
      content: 'notifyme-content',
      footer: 'd-none'
    });
    populateModalElement(notifyMeProductUrl, 'notifyme-modal');
    notifyMe.submitRecaptchaNotifyMe();
  });
  $('body').on('shown.bs.modal', '#editProductModal', function () {
    $('#editProductModal').siblings().attr('aria-hidden', 'true');
    $('#editProductModal .close').focus();
  });
  $('body').on('hidden.bs.modal', '#editProductModal', function () {
    $('#editProductModal').siblings().attr('aria-hidden', 'false');
  });
  $('body').on('keydown', '#editProductModal', function (e) {
    var focusParams = {
      event: e,
      containerSelector: '#editProductModal',
      firstElementSelector: '.close',
      lastElementSelector: '.edit-flyout-cancel-btn',
      nextToLastElementSelector: '.modal-footer .quantity-select'
    };
    focusHelper.setTabNextFocus(focusParams);
  });
  $('body').on('product:updateAddToCart', function (e, response) {
    // update global add to cart (single products, bundles)
    var dialog = $(response.$productContainer).closest('.quick-view-dialog');
    $('.update-cart-product-global', dialog).attr('disabled', !$('.global-availability', dialog).data('ready-to-order') || !$('.global-availability', dialog).data('available'));
    var $notifyMeContainer = $('div.notify-me-form-container', response.$productContainer);
    var $addToCartGrid = $('.cart-quick-view-dialog div.quantity-addtocart-grid-quick-view', response.$productContainer);

    if (!response.product.available) {
      if (response.product.isNotifyMeActive) {
        $addToCartGrid.addClass('d-none');
        $notifyMeContainer.removeClass('d-none');
        loadNotifyMeForm(response.product.id, $notifyMeContainer, response.product.notifyURL);
      } else {
        $addToCartGrid.removeClass('d-none');
        $notifyMeContainer.addClass('d-none');
        $('button.update-cart-product-global', response.$productContainer).html(response.product.soldOutLabel.pdp);
      }
    } else {
      $addToCartGrid.removeClass('d-none');
      $notifyMeContainer.addClass('d-none');
      var addToCartLabel = $('button.update-cart-product-global', response.$productContainer).data('primary-label');
      $('button.update-cart-product-global', response.$productContainer).html(addToCartLabel);
    }
  });
  $('body').on('product:updateAvailability', function (e, response) {
    // bundle individual products
    $('.product-availability', response.$productContainer).data('ready-to-order', response.product.readyToOrder).data('available', response.product.available).find('.availability-msg li').empty().html(response.product.availability.messages[0] ? '<div class="availability">' + response.product.availability.messages[0] + '</div>' : '');
    var dialog = $(response.$productContainer).closest('.quick-view-dialog');

    if ($('.product-availability', dialog).length) {
      // bundle all products
      var allAvailable = $('.product-availability', dialog).toArray().every(function (item) {
        return $(item).data('available');
      });
      var allReady = $('.product-availability', dialog).toArray().every(function (item) {
        return $(item).data('ready-to-order');
      });
      $('.global-availability', dialog).data('ready-to-order', allReady).data('available', allAvailable);
      $('.global-availability .availability-msg', dialog).empty().html(allReady ? response.message : response.resources.info_selectforstock);
    } else {
      // single product
      $('.global-availability', dialog).data('ready-to-order', response.product.readyToOrder).data('available', response.product.available).find('.availability-msg li').empty().html(response.product.availability.messages[0] ? '<div class="availability">' + response.product.availability.messages[0] + '</div>' : '');
    }
  });
  $('body').on('product:afterAttributeSelect', function (e, response) {
    // if size is selected, prevent the focus to move to first color variant - instead stay on the same element
    if ($('.cart-page').length > 0 && $(response.target).attr('id') !== undefined && $(response.target).attr('id').indexOf('size') > -1) {
      $('#size_' + response.data.product.id + '_' + response.data.product.variationAttributes[1].displayValue + '_' + response.data.locale.split('_')[1]).focus();
    }

    if ($('.modal.show .product-quickview .bundle-items').length > 0) {
      $('.modal.show').find(response.container).data('pid', response.data.product.id);
      $('.modal.show').find(response.container).find('.product-id').text(response.data.product.id);
    } else {
      $('.modal.show .product-quickview').data('pid', response.data.product.id);
    }

    $('.edit-product-modal .loyal-details-container').removeClass('d-flex').addClass('d-none');
  });
  $('body').on('change', '.quantity-select', function () {
    var selectedQuantity = $(this).val();
    $('.modal.show .update-cart-url').data('selected-quantity', selectedQuantity);

    if ($(this).parents('.edit-product-modal').length > 0) {
      base.attributeSelect($(this).find('option:selected').data('url'), $('#editProductModal'));
    }
  });
  $('body').on('change', '.options-select', function () {
    var selectedOptionValueId = $(this).children('option:selected').data('value-id');
    $('.modal.show .update-cart-url').data('selected-option', selectedOptionValueId);
  });
  $('body').on('click', '.edit-flyout-cancel-btn', function () {
    $('#editProductModal').modal('hide');
  });
  $('body').on('click', '.update-cart-product-global', function (e) {
    e.preventDefault();
    var updateProductUrl = $(this).closest('.cart-and-ipay').find('.update-cart-url').val();
    var selectedQuantity = $(this).closest('.cart-and-ipay').find('.update-cart-url').data('selected-quantity');
    var selectedOptionValueId = $(this).closest('.cart-and-ipay').find('.update-cart-url').data('selected-option');
    var uuid = $(this).closest('.cart-and-ipay').find('.update-cart-url').data('uuid');
    var isSuccess = true;
    var form = {
      uuid: uuid,
      pid: base.getPidValue($(this)),
      quantity: selectedQuantity,
      selectedOptionValueId: selectedOptionValueId
    };
    $(this).parents('.card').spinner().start();
    $('body').trigger('cart:beforeUpdate');

    if (updateProductUrl) {
      $('.modal-body').spinner().start();
      $.ajax({
        url: updateProductUrl,
        type: 'post',
        context: this,
        data: form,
        dataType: 'json',
        success: function success(data) {
          $('#editProductModal').modal('hide');
          $('.coupons-and-promos').empty().append(DOMpurify.sanitize(data.cartModel.totals.discountsHtml));
          updateCartTotals(data.cartModel);
          updateApproachingDiscounts(data.cartModel.approachingDiscounts);
          updateAvailability(data.cartModel, uuid);
          updateProductDetails(data, uuid);
          updateProductLineItemBorder(data.cartModel);

          if (data.uuidToBeDeleted) {
            $('.uuid-' + DOMpurify.sanitize(data.uuidToBeDeleted)).remove();
          }

          validateBasket(data.cartModel);
          loyaltyPointsCartEdit(data);
          $('body').trigger('event:editCartUpdateProduct', data);
          $('body').trigger('cart:update', data);
          $.spinner().stop();

          if (toastMessageFlag) {
            clientSideUtil.floatToastMessage(data.toastMsgAndTimeOutSec.message, data.toastMsgAndTimeOutSec.toastMessageDisplayTime, isSuccess, 'updateCart');
          }

          if (data.cartModel && typeof data.cartModel.employeeCouponApplied !== 'undefined') {
            $('body').trigger('event:updateEmployeeStatus', data.cartModel.employeeCouponApplied);
          }
        },
        error: function error(err) {
          isSuccess = false;
          $('#editProductModal').modal('hide');

          if (err.responseJSON.redirectUrl) {
            window.location.href = err.responseJSON.redirectUrl;
          } else {
            clientSideUtil.floatToastMessage(err.responseJSON.errorMessage, err.responseJSON.toastMsgAndTimeOutSec.toastMessageDisplayTime, isSuccess);
            $.spinner().stop();
          }
        }
      });
    }
  });
  $(document).on('click', '.quick-view-dialog .move-to-cart-wishlist', function () {
    var productDetail = $(this).closest('.product-detail');

    if (!wishlist.isSizeSelected(productDetail)) {
      return;
    }

    var buttonBlock = $(this).closest('.wishlist-item-update-button-block').find('.add-to-cart-url').not('.notify-me-enabled');
    var addToCartUrl = buttonBlock.val();
    var uuid = buttonBlock.data('uuid');
    var pid = base.getPidValue($(this));
    var quantityNew = 1;
    var elMyAccount = $('.product-info').length;
    var action = $('.page').data('action');
    var querystring = $('.page').data('querystring');
    var sharedListid = null;

    if (querystring) {
      sharedListid = querystring.split('&id=')[1];
    }

    $('body').trigger('product:beforeAddToCart', this);
    var form = {
      pid: pid,
      uuid: uuid,
      quantity: quantityNew,
      options: [],
      productCount: elMyAccount,
      action: action,
      sharedListid: sharedListid
    };
    updateCartAndWishlist(addToCartUrl, form);
  });
  checkCSRFexpiration();
  stickyCheckoutCTA();
  base.selectAttribute();
  base.colorAttribute();
  base.sizeChart();
  base.removeBonusProduct();
  base.selectBonusProduct();
  base.enableBonusProductSelection();
  base.showMoreBonusProducts();
  base.addBonusProductsToCart();
  base.focusChooseBonusProductModal();
  base.trapChooseBonusProductModalFocus();
  base.onClosingChooseBonusProductModal();
  base.addToCart();
  clientSideUtil.initTooltip();
  shareFlyout.shareFormSubmit();
  shareFlyout.shareLinkClick();
};

module.exports.methods = {
  appendToUrl: appendToUrl,
  validateBasket: validateBasket,
  updateCartTotals: updateCartTotals,
  updateProductLineItemBorder: updateProductLineItemBorder,
  createErrorNotification: createErrorNotification,
  updateApproachingDiscounts: updateApproachingDiscounts,
  cartUpdateQuantity: cartUpdateQuantity,
  updateAvailability: updateAvailability,
  updateProductDetails: updateProductDetails,
  loyaltyPointsCartEdit: loyaltyPointsCartEdit,
  updateCartAndWishlist: updateCartAndWishlist,
  getItemsInCart: getItemsInCart,
  itemsToMove: itemsToMove
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/address.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/address.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var formHelpers = __webpack_require__(/*! ../checkout/formErrors */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js");

var phoneFormatter = __webpack_require__(/*! ../utilities/phoneFormatter */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/phoneFormatter.js");

var CONSTANTS = __webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js");
/**
 * Populate the Billing Address Summary View
 * @param {string} parentSelector - the top level DOM selector for a unique address summary
 * @param {Object} address - the address data
 */


function populateAddressSummary(parentSelector, address) {
  $.each(address, function (attr) {
    var val = address[attr];
    $('.' + attr, parentSelector).text(val || '');
  });
}
/**
* Remove loqate field from address form
 */


function removeLoqateField() {
  $('.js-shipping-address-block').removeClass('collapsed');
  $('.js-loqate-address-block').addClass('d-none');
  $('.js-address-method-link').addClass('d-none');
  $('.js-address-suggestion').removeAttr('required');
  $('.js-address-suggestion').removeAttr('aria-required');
  $('.js-loqate-address-block .form-group').removeClass('required');
  var addr1 = $('.shippingAddressOne').val();
  $('.js-address-suggestion').val(addr1);
}
/**
 * Add loqate field in address form
 */


function addLoqateField() {
  $('.js-shipping-address-block').addClass('collapsed');
  $('.js-loqate-address-block').removeClass('d-none');
  $('.js-address-method-link').removeClass('d-none');
}
/**
 * returns a formed <option /> element
 * @param {Object} shipping - the shipping object (shipment model)
 * @param {boolean} selected - current shipping is selected (for PLI)
 * @param {order} order - the Order model
 * @param {Object} [options] - options
 * @returns {Object} - the jQuery / DOMElement
 */


function optionValueForAddress(shipping, selected, order, options) {
  var safeOptions = options || {};
  var isBilling = safeOptions.type && safeOptions.type === 'billing';
  var className = safeOptions.className || '';
  var isSelected = selected;
  var isNew = !shipping;

  if (typeof shipping === 'string') {
    return $('<option class="' + className + '" disabled>' + shipping + '</option>');
  }

  var safeShipping = shipping || {};
  var shippingAddress = safeShipping.shippingAddress || {};

  if (isBilling && isNew && !order.billing.matchingAddressId) {
    shippingAddress = order.billing.billingAddress.address || {};
    isNew = false;
    isSelected = true;
    safeShipping.UUID = 'manual-entry';
  }

  var uuid = safeShipping.UUID ? safeShipping.UUID : 'new';
  var optionEl = $('<option class="' + className + '" />');
  optionEl.val(uuid);

  if (safeShipping.matchingAddressId) {
    optionEl.val(safeShipping.matchingAddressId);
  }

  var title;

  if (isNew) {
    title = order.resources.addNewAddress;
  } else {
    title = [];

    if (shippingAddress.firstName) {
      title.push(shippingAddress.firstName);
    }

    if (shippingAddress.lastName) {
      title.push(shippingAddress.lastName);
    }

    if (shippingAddress.address1) {
      title.push(shippingAddress.address1);
    }

    if (shippingAddress.address2) {
      title.push(shippingAddress.address2);
    }

    if (shippingAddress.city) {
      if (shippingAddress.state) {
        title.push(shippingAddress.city + ',');
      } else {
        title.push(shippingAddress.city);
      }
    }

    if (shippingAddress.stateCode) {
      title.push(shippingAddress.stateCode);
    }

    if (shippingAddress.postalCode) {
      title.push(shippingAddress.postalCode);
    }

    if (!isBilling && safeShipping.selectedShippingMethod) {
      title.push('-');
      title.push(safeShipping.selectedShippingMethod.displayName);
    }

    if (title.length > 2) {
      title = title.join(' ');
    } else {
      title = order.resources.newAddress;
    }
  }

  optionEl.text(title);
  var keyMap = {
    'data-first-name': 'firstName',
    'data-last-name': 'lastName',
    'data-address1': 'address1',
    'data-address2': 'address2',
    'data-city': 'city',
    'data-state-code': 'stateCode',
    'data-postal-code': 'postalCode',
    'data-country-code': 'countryCode',
    'data-phone': 'phone',
    'data-phonee164': 'phoneE164',
    'data-isverified': 'isVerified'
  };
  $.each(keyMap, function (key) {
    var mappedKey = keyMap[key];
    var mappedValue = shippingAddress[mappedKey]; // In case of country code

    if (mappedValue && _typeof(mappedValue) === 'object') {
      mappedValue = mappedValue.value;
    }

    optionEl.attr(key, mappedValue || '');

    if (key === 'data-isverified' && typeof mappedValue === 'boolean') {
      optionEl.attr(key, mappedValue);
    }
  });
  var giftObj = {
    'data-is-gift': 'isGift',
    'data-gift-message': 'giftMessage'
  };
  $.each(giftObj, function (key) {
    var mappedKey = giftObj[key];
    var mappedValue = safeShipping[mappedKey];
    optionEl.attr(key, mappedValue || '');
  });

  if (isSelected) {
    optionEl.attr('selected', true);
  }

  return optionEl;
}
/**
 * returns address properties from a UI form
 * @param {Form} form - the Form element
 * @returns {Object} - a JSON object with all values
 */


function getAddressFieldsFromUI(form) {
  var address = {
    firstName: $('input[name$=_firstName]', form).val(),
    lastName: $('input[name$=_lastName]', form).val(),
    address1: $('input[name$=_address1]', form).val(),
    address2: $('input[name$=_address2]', form).val(),
    city: $('input[name$=_city]', form).val(),
    postalCode: $('input[name$=_postalCode]', form).val(),
    stateCode: $('select[name$=_stateCode],input[name$=_stateCode]', form).val(),
    countryCode: $('select[name$=_country]', form).val(),
    phone: phoneFormatter.methods.getPhoneNumberE164('input#shippingPhoneNumberdefault')
  };
  return address;
}
/**
 * Update the key
 * @param {Form} key - the Form element
 * @param {Form} value - the Form element
 * @param {Form} field - the Form element
 */


function updateField(key, value, field) {
  if (!$(field).hasClass('js-phone-pattern')) {
    if (key === 'regEx') {
      $(field).attr('pattern', value);
      return;
    } else if (key === 'mandatory') {
      if (value === false) {
        $(field).removeAttr('required');
      } else {
        $(field).prop('required', true);
      }
    }

    $(field).attr(key, value);
  }
}
/**
 * Make the field required
 * @param {Form} field - the field to be changed
 */


function makeFieldRequired(field) {
  field.parent('.form-group').addClass('required');
  field.prev('.form-control-label').removeClass('d-none');
  field.closest('.row-custom').removeClass('grid-1');
  field.attr('required');
  field.parents('.content-form').find('.state-left').removeClass('d-none');
}
/**
 * Make the field not required
 * @param {Form} field - the field to be changed
 */


function makeFieldNotRequired(field) {
  field.parent('.form-group').removeClass('required');
  field.prev('.form-control-label').addClass('d-none');
  field.closest('.row-custom').addClass('grid-1');
  field.removeAttr('required');
  field.next('.invalid-feedback').text('');
  field.parents('.content-form').find('.state-left').addClass('d-none');
}
/**
 * Update the country fields based on the country selected
 * @param {Form} addressForm - the Form element
 */


function toggleAddressFields(addressForm) {
  var jsonData = __webpack_require__(/*! ../../../../config/customAddressConfig.json */ "./cartridges/app_mk_storefront/cartridge/config/customAddressConfig.json");

  var $form = addressForm;
  var countrySelected = $form.find('.js-checkout-country-select').val();
  var AddressFieldsPerCountry = jsonData; // look for the appropriate fields to be shown

  var countryFields = AddressFieldsPerCountry[countrySelected]; // if country is not on the list, use default fields

  if (!countryFields) {
    countryFields = AddressFieldsPerCountry.default;
  }

  var fields = {
    address1: $form.find('input[name*=_address1]'),
    address2: $form.find('input[name*=_address2]'),
    postalCode: $form.find('input[name*=_postalCode]'),
    city: $form.find('input[name*=_city]'),
    phone: $form.find('input[name*=_phone]'),
    states: $form.find('[name*=_stateCode]')
  };
  var addressformurl = $form.find('.js-address-form-url').data('getaddressformurl');
  var formData = {};
  $.ajax({
    url: addressformurl,
    type: 'get',
    dataType: 'json',
    async: false,
    data: {
      countrySelected: countrySelected
    },
    success: function success(data) {
      formData = data;
    },
    error: function error() {}
  });
  var statesCodeForm = formData.statesField && formData.statesField.stateCode ? formData.statesField.stateCode : '';
  var postalIsMandatory;
  $.each(countryFields, function (index, fieldToUpdate) {
    var currentField;

    if (fields[index]) {
      if (index === 'states') {
        currentField = $($(fields[index])[0]); // iterate over the state fields options

        Object.keys(fieldToUpdate).every(function (key) {
          if (key === 'options') {
            if ($.isEmptyObject(fieldToUpdate[key])) {
              /*
              * check for empty options, i.e. when there is no state
              * either hide if its hidden set to false and remove required attributes
              * else convert into input field
              */
              if (fieldToUpdate.mandatory === false && fieldToUpdate.hidden === true) {
                makeFieldNotRequired(currentField);
                $(fields[index]).find('option').remove();
              } else {
                makeFieldRequired(currentField);
                $(fields[index]).find('option').remove();
                currentField.replaceWith($(fields[index])[0].outerHTML.replace(/<select/g, '<input').replace(/<\/select>/g, '</input>'));
                fields.states = $form.find('[name*=_stateCode]');
              }
            } else {
              /*
              * check for options, i.e. when there are states presemt
              * check if its input then convert to select
              * populate the options based on the JSON of states present
              */
              makeFieldRequired(currentField);

              if (currentField.is('input')) {
                currentField.replaceWith($(fields[index])[0].outerHTML.replace(/<input/g, '<select').replace(/<\/input>/g, '</select>'));
                fields.states = $form.find('[name*=_stateCode]');
              }

              $(fields[index]).find('option').remove();
              var optionsHTML = '';

              if (statesCodeForm && statesCodeForm.options && statesCodeForm.options.length > 0) {
                var _iterator = _createForOfIteratorHelper(statesCodeForm.options),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var option = _step.value;
                    optionsHTML = optionsHTML + '<option id="' + option.id + '" value="' + option.htmlValue + '">' + option.label + '</option>';
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                $(optionsHTML).appendTo(fields[index]);
                var selectedAddressState = $(fields[index]).attr('data-selected-state');

                if (typeof selectedAddressState !== 'undefined') {
                  $(fields[index]).find('option').removeAttr('selected');
                  var selectedState = $(fields[index]).find('option[value=' + selectedAddressState + ']');
                  selectedState.attr('selected', true);
                  $(fields[index]).trigger('change');
                  $(fields[index]).removeClass('is-invalid');
                  $(fields[index]).closest('.form-group').removeClass('is-invalid');
                }
              } else {
                $.each(fieldToUpdate[key], function (optionId) {
                  optionsHTML = optionsHTML + '<option id="' + optionId + '" value="' + optionId + '">' + optionId + ' - ' + fieldToUpdate.options[optionId] + '</option>';
                });
                $(optionsHTML).appendTo(fields[index]);
              }
            }
          } else {
            // update the attributes for state field
            updateField(key, fieldToUpdate[key], fields[index]);
          }

          return true;
        });
      } else {
        // update the attributes for all fields
        Object.keys(fieldToUpdate).every(function (key) {
          updateField(key, fieldToUpdate[key], fields[index]);
          return true;
        });

        if (index === 'postalCode') {
          postalIsMandatory = fieldToUpdate.mandatory || false;
        }
      }
    } else if (index === 'resources') {
      // updating localized state & post code form field error messages
      if (statesCodeForm && statesCodeForm.errorMsg) {
        var $postalCodefield = $(fields.postalCode).parent().find('input');
        var $statesField = $(fields.states);
        updateField('data-missing-error', statesCodeForm.errorMsg.postalCodeMissingError, $postalCodefield);
        updateField('data-range-error', statesCodeForm.errorMsg.postalCodeRangeOrMismatchError, $postalCodefield);
        updateField('data-pattern-mismatch', statesCodeForm.errorMsg.postalCodeRangeOrMismatchError, $postalCodefield);
        updateField('data-missing-error', statesCodeForm.errorMsg.stateOrProvinceMissingError, $statesField);

        if (fieldToUpdate.stateLabel !== CONSTANTS.STATELABEL) {
          updateField('data-pattern-mismatch', statesCodeForm.errorMsg.provincePatternMismatch, $statesField);
        }
      } // change the state and zip label based on country


      if (statesCodeForm.mandatory) {
        $(fields.states).parent().find('label').text($($(fields.states)[0]).data(fieldToUpdate.stateLabel + 'label') + '*');
      } else {
        $(fields.states).parent().find('label').text($($(fields.states)[0]).data(fieldToUpdate.stateLabel + 'label'));
      }

      if (postalIsMandatory) {
        $(fields.postalCode).parent().find('label').text($($(fields.postalCode)[0]).data(fieldToUpdate.zipLabel + 'label') + '*');
      } else {
        $(fields.postalCode).parent().find('label').text($($(fields.postalCode)[0]).data(fieldToUpdate.zipLabel + 'label'));
      }
    }
  });
  var checkedBillingAddress = $('.show-billing-address');

  if (checkedBillingAddress.is(':checked')) {
    $('.billingState').val($('.shippingState').val());
  }
}
/**
 * update isverified attribute based on selected option from address book
 */


function updateVerifiedAttr() {
  if ($('#checkout-main').data('customer-type') === 'registered') {
    var $shipmentAddressOption = $('#shipmentSelector-default option:selected');
    $('.submit-shipping').attr('data-isverified', $shipmentAddressOption.data('isverified'));
    var $billingAddressOption = $('#billingAddressSelector option:selected');
    $('.submit-payment').attr('data-isverified', $billingAddressOption.data('isverified'));
  }
}

module.exports = {
  methods: {
    populateAddressSummary: populateAddressSummary,
    optionValueForAddress: optionValueForAddress,
    getAddressFieldsFromUI: getAddressFieldsFromUI,
    toggleAddressFields: toggleAddressFields,
    removeLoqateField: removeLoqateField,
    addLoqateField: addLoqateField,
    updateVerifiedAttr: updateVerifiedAttr
  },
  showDetails: function showDetails() {
    $('.btn-show-details').on('click', function () {
      var form = $(this).closest('form');
      form.attr('data-address-mode', 'details');
      form.find('.multi-ship-address-actions').removeClass('d-none');
      form.find('.multi-ship-action-buttons .col-12.btn-save-multi-ship').addClass('d-none');
    });
  },
  addNewAddress: function addNewAddress() {
    $('.btn-add-new').on('click', function () {
      var $el = $(this);

      if ($el.parents('#dwfrm_billing').length > 0) {
        // Handle billing address case
        $('body').trigger('checkout:clearBillingForm');
        var $option = $($el.parents('form').find('.addressSelector option')[0]);
        $option.attr('value', 'new');
        var $newTitle = $('#dwfrm_billing input[name=localizedNewAddressTitle]').val();
        $option.text($newTitle);
        $option.prop('selected', 'selected');
        $el.parents('[data-address-mode]').attr('data-address-mode', 'new');
      } else {
        // Handle shipping address case
        var $newEl = $el.parents('form').find('.addressSelector option[value=new]');
        $('.addressSelector option').prop('selected', '');
        $('.addressSelector option').removeAttr('selected');

        if (!$newEl.length > 0) {
          var optionLabel = $el.parents('form').find('.addressSelector').data('new-address-label');
          var addressNewOption = "<option value=\"new\" data-first-name=\"\"\n                    data-last-name=\"\"\n                    data-address1=\"\"\n                    data-address2=\"\"\n                    data-addressId=\"\"\n                    data-city=\"\"\n                    data-state-code=\"\"\n                    data-country-code=\"\"\n                    data-postal-code=\"\"\n                    data-phone=\"\"\n                    data-phonee164=\"\">" + optionLabel + '</option>';
          $el.parents('form').find('.addressSelector').prepend(addressNewOption);
          $newEl = $el.parents('form').find('.addressSelector option[value=new]');
        }

        $newEl.prop('selected', 'selected');
        $newEl.parent().trigger('change');
      }
    });
  },
  enterAddressManually: function enterAddressManually() {
    $(document).on('click', '.js-address-method-link', function (e) {
      e.preventDefault();
      var form = $('.js-address-suggestion').closest('form');
      var fieldset = $(this).closest('fieldset');
      fieldset.find('#iOS_dummy_address1').addClass('d-none');
      $('.js-shipping-address-block').removeClass('collapsed');
      $('.js-loqate-address-block').addClass('d-none');
      $('.js-shipping-address-block .form-input-custom').val('');
      $('.js-address-suggestion').removeAttr('required');
      $('.js-address-suggestion').removeAttr('aria-required');
      $('.js-loqate-address-block .form-group').removeClass('is-invalid');
      formHelpers.clearPreviousErrors(form);
      $(this).addClass('d-none');

      if ($(this).closest('.shipping-address-block').length > 0 && $('button.submit-shipping').data('address-verify-enabled')) {
        if ($('button.submit-shipping').data('address-suggestion-enabled')) {
          $('button.submit-shipping').addClass('active-suggestion');
        }
      } else if ($(this).closest('.billing-address').length > 0 && $('button.submit-payment').data('address-verify-enabled')) {
        if ($('button.submit-payment').data('address-suggestion-enabled')) {
          $('button.submit-payment').addClass('active-suggestion');
        }
      } else if ($(this).closest('#addressFormAccordion').length > 0 && $('.save-address-btn a').data('address-verify-enabled')) {
        if ($('.save-address-btn a').data('address-suggestion-enabled')) {
          $('.save-address-btn a').addClass('active-suggestion');
        }
      }
    });
    $(document).on('change', '.shippingAddressOne', function () {
      var addr1 = $(this).val();
      $('.js-address-suggestion').val(addr1);
    });
  },
  removeSuggestion: function removeSuggestion() {
    $(document).on('click', '.js-remove-suggestion', function () {
      $('.js-address-suggestion').val('');
      $(this).addClass('d-none');
    });
  },
  clearAddressSuggestion: function clearAddressSuggestion() {
    $(document).on('keyup', '.js-address-suggestion', function () {
      if ($(this).val().length === 0) {
        $('.pcaautocomplete.pcatext').each(function () {
          if ($(this).css('display') === 'block') {
            $(this).css('display', 'none');
          }
        });
        $('.js-remove-suggestion').addClass('d-none');
      } else {
        $('.js-remove-suggestion').removeClass('d-none');
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js":
/*!*****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var scrollAnimate = __webpack_require__(/*! ../components/scrollAnimate */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * Display error messages and highlight form fields with errors.
 * @param {string} parentSelector - the form which contains the fields
 * @param {Object} fieldErrors - the fields with errors
 */


function loadFormErrors(parentSelector, fieldErrors) {
  // eslint-disable-line
  // Display error messages and highlight form fields with errors.
  $.each(fieldErrors, function (attr) {
    $('*[name=' + DOMpurify.sanitize(attr) + ']', DOMpurify.sanitize(parentSelector)).addClass('is-invalid').siblings('.invalid-feedback').html(DOMpurify.sanitize(fieldErrors[attr]));
  }); // Animate to top of form that has errors

  scrollAnimate($(parentSelector));
  $(parentSelector).find('.is-invalid:first').focus();
}
/**
 * Display error messages and highlight form fields with errors for Billing Section.
 * @param {string} parentSelector - the form which contains the fields
 * @param {Object} fieldErrors - the fields with errors
 */


function loadFormErrorsForBilling(parentSelector, fieldErrors) {
  // eslint-disable-line
  // Display error messages and highlight form fields with errors.
  $.each(fieldErrors, function (attr) {
    $('*[name=' + DOMpurify.sanitize(attr) + ']', DOMpurify.sanitize(parentSelector)).addClass('is-invalid').siblings('.invalid-feedback').html(DOMpurify.sanitize(fieldErrors[attr]));

    if (attr === 'dwfrm_billing_creditCardFields_cardNumber') {
      $('#cardNumber-container').addClass('is-invalid');
      $('.invalid-feedback.cardNumber').removeClass('d-none').text(fieldErrors[attr]); // show billing address form if billing address errors
    } else if (attr.startsWith('dwfrm_billing_addressFields')) {
      var $billingAddressSameAsShipping = $('input[name$="_shippingAddressUseAsBillingAddress"]');

      if ($billingAddressSameAsShipping.is(':checked')) {
        $billingAddressSameAsShipping.prop('checked', false);
        $('.show-billing-address').click();
        $('.edit-billing-address').click();
      }
    }
  });
}
/**
 * Clear the form errors.
 * @param {string} parentSelector - the parent form selector.
 */


function clearPreviousErrors(parentSelector) {
  // empty errors shown at top of checkout page
  $('div.primary-checkout > div.alert.alert-danger').each(function () {
    this.innerHTML = '';
  });
  $(parentSelector).find('.form-control.is-invalid').removeClass('is-invalid');
  $(parentSelector).find('.form-group.is-invalid').removeClass('is-invalid');
  $('.error-message').hide();
}

module.exports = {
  loadFormErrors: loadFormErrors,
  clearPreviousErrors: clearPreviousErrors,
  loadFormErrorsForBilling: loadFormErrorsForBilling
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/giftWrap.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/giftWrap.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var formHelpers = __webpack_require__(/*! ./formErrors */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js");

var summaryHelpers = __webpack_require__(/*! ./summary */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/summary.js");

var shippingHelpers = __webpack_require__(/*! ./shipping */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/shipping.js");

var giftWrapFormId = 'form-giftwrap';
var giftWrapFormSelector = '#' + giftWrapFormId;
var $giftWrapForm = $(giftWrapFormSelector);

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * display giftwrap card in sidebar if applicable
 * @param {Object} giftWrapData - ajax call data
 */


function giftwrapCard(giftWrapData) {
  var $giftWrapItem = $('.secondary-checkout .js-giftwrap-card');
  var $giftwrapCheckbox = $('.gift-wrap-checkbox:checked');
  var $giftWrapTotals = giftWrapData.giftwrapTotals;
  var totalGiftwrapItems = $giftWrapTotals.items;

  if (totalGiftwrapItems === 0) {
    $giftWrapItem.addClass('d-none');
    return;
  }

  var giftwrapMsg = $giftwrapCheckbox.closest('.product-content-block').find('.gift-wrap-message').attr('data-text-value');

  if (giftwrapMsg !== 'null') {
    $giftWrapItem.find('.js-giftwrap-msg').text(giftwrapMsg);
  }

  $giftWrapItem.find('.quantity-form span').text('Qty: ' + totalGiftwrapItems || 0);
  $giftWrapItem.find('.giftwrap-row span').text($giftWrapTotals.price && $giftWrapTotals.price.formatted || 'FREE');
  $giftWrapItem.removeClass('d-none');
}
/**
 * @param {obj} textarea textarea input to validate
 * @returns {boolean} if the message is valid
 */


function validateGiftWrapMessage(textarea) {
  // eslint-disable-next-line  no-useless-escape
  var giftWrapRegex = new RegExp('^([#-;]|[=]|[!]|[{-~]|[\]-`]|[\\s]|[\\?-[]|[\\]-\\~]|[Μμ€¡£\\§«»°²´¿¨µ·º]|[À-ÿ]|[Ā-İ]|[Ĳ-ſ]|[Ș-ț])*$');
  var isValid = giftWrapRegex.test(textarea.val());
  return isValid;
}
/**
 *
 * @param {Object} giftwrapTotals totals data
 */


function updateGiftWrapSummary(giftwrapTotals) {
  var $giftwrapWrapper = $('.giftwrap-row');
  var $giftwrapWrapperOrderSummary = $('.giftwrap-order-summary-row');

  if (!giftwrapTotals) {
    return;
  }

  $giftwrapWrapperOrderSummary.find('.giftwrap-items').html(DOMpurify.sanitize(giftwrapTotals.label));
  $giftwrapWrapperOrderSummary.find('.giftWrap-cost-wrap .giftwrap-cost').html(DOMpurify.sanitize(giftwrapTotals.price.formatted));
  $giftwrapWrapper.find('.giftwrap-items').html(DOMpurify.sanitize(giftwrapTotals.label));
  $giftwrapWrapper.find('.giftWrap-cost-wrap').html(DOMpurify.sanitize(giftwrapTotals.price.formatted));

  if (giftwrapTotals.items > 0) {
    $giftwrapWrapper.removeClass('d-none');
    $giftwrapWrapperOrderSummary.removeClass('d-none');
  } else {
    $giftwrapWrapper.addClass('d-none');
    $giftwrapWrapperOrderSummary.addClass('d-none');
  }
}
/**
 *
 * @param {Object} totals totals data
 */


function updateCartTotals(totals) {
  if (totals && totals.giftwrapTotals) {
    updateGiftWrapSummary(totals.giftwrapTotals);
  }

  $('.sub-total').empty().append(DOMpurify.sanitize(totals.subTotal));
  $('.tax-total').empty().append(DOMpurify.sanitize(totals.totalTax));

  if (totals.orderLevelDiscountTotal) {
    $('.order-discount-total').empty().append('-' + DOMpurify.sanitize(totals.orderLevelDiscountTotal.formatted));
  }

  if (totals.additionalTaxes && totals.additionalTaxes.taxGSTHST) {
    $('.taxGSTHST-cost').empty().append(DOMpurify.sanitize(totals.additionalTaxes.taxGSTHST.price.formatted));
  }

  if (totals.additionalTaxes && totals.additionalTaxes.taxPSTQST) {
    $('.taxPSTQST-cost').empty().append(DOMpurify.sanitize(totals.additionalTaxes.taxPSTQST.price.formatted));
  }

  $('.grand-total-sum').empty().append(DOMpurify.sanitize(totals.grandTotal.formatted));
}
/**
 *
 * @param {string} key key
 * @param {Object} obj object
 * @returns {Object} custom object
 */


function buildProductObject(key, obj) {
  return _defineProperty({}, key, {
    checked: obj[key + '-giftWrapOption'] ? true : false,
    // eslint-disable-line no-unneeded-ternary
    message: obj[key + '-giftWrapMessage']
  });
}
/**
 *
 * @param {any} e Event
 */


function submitGiftWrapForm(e) {
  e.preventDefault();
  var defer = $.Deferred(); // eslint-disable-line

  var giftWrapObj = clientSideUtil.convertFormDataToObj(giftWrapFormId);
  var giftWrapProductsObj = [];

  if (!Array.isArray(giftWrapObj.productUUID)) {
    giftWrapObj.productUUID = giftWrapObj.productUUID.split();
  }

  giftWrapObj.productUUID.forEach(function (uuid) {
    var productObj = buildProductObject(uuid, giftWrapObj); // eslint-disable-line no-shadow

    giftWrapProductsObj.push(productObj);
  });
  $.ajax({
    url: $giftWrapForm.attr('action'),
    type: 'POST',
    data: {
      giftWrapProducts: JSON.stringify(giftWrapProductsObj),
      csrf_token: giftWrapObj.csrf_token
    },
    success: function success(data) {
      formHelpers.clearPreviousErrors(giftWrapFormSelector);
      $giftWrapForm.find('.invalid-feedback').val('');

      if (data.error) {
        if (data.fieldErrors.length) {
          data.fieldErrors.forEach(function (error) {
            if (Object.keys(error).length) {
              formHelpers.loadFormErrors(giftWrapFormSelector, error);
            }
          });
          defer.reject(data);
        }

        if (data.serverErrors.length) {
          data.serverErrors.forEach(function (error) {
            $('.error-message').show();
            $('.error-message-text').text(error);
          });
        }
      } else {
        $('#giftWrapModal').modal('hide');
        updateCartTotals(data.totals); // ToDo - updateCartTotals should be removed and instead we should use summaryHelpers.updateTotals only

        summaryHelpers.updateTotals(data.totals);
        giftwrapCard(data.totals);

        if (data.shippingMethods && data.shippingMethods[0]) {
          shippingHelpers.methods.updateShippingMethods(data.shippingMethods[0]);
        }

        $('.gift-wrap-checkbox').removeClass('checked-gift-wrap');
        $('.gift-wrap-checkbox:checked').addClass('checked-gift-wrap');
        $('.gift-wrap-checkbox:checked').closest('.product-content-block').find('textarea').each(function () {
          $(this).attr('data-text-value', $(this).val());

          if ($(this).val().replace(/^\s+|\s+$/g, '').length !== 0) {
            $(this).addClass('textarea-checked');
          } else {
            $(this).removeClass('textarea-checked');
          }
        });
      }
    }
  });
}
/**
 *
 * @param {string} removeNoteDomElement Dom Element
 * @param {string} textAreaMessage TextArea placeholder
 *  @param {string} charNum Dom Element
 */


function removeNote(removeNoteDomElement, textAreaMessage, charNum) {
  textAreaMessage.val('');
  charNum.text('140/140');
}
/**
 * @param {obj} obj this
 * @param {string} charNum Dom Element
 */


function countChars(obj, charNum) {
  var charNumber = charNum;
  var maxLength = 140;
  var strLength = obj.value.length;

  if (strLength < 0) {
    charNumber.text('140/ ' + maxLength);
  } else {
    charNumber.text(140 - strLength + '/' + maxLength);
  }
}
/**
 * @param {obj} obj this
 * @param {string} charNum Dom Element
 */


function giftWrapToggleMessage() {
  $giftWrapForm.find('.product-content-block').each(function () {
    var checkbox = $(this).find('.gift-wrap-checkbox');
    var message = $(this).find('.gift-wrap-message');
    var messageTextWrap = $(this).find('.gift-wrap-character-text-wrapper');
    var $removeNote = $(this).find('.gift-wrap-remove-note');
    var characterCount = $(this).find('#charNum');
    checkbox.on('change', function () {
      if (this.checked) {
        message.removeClass('hidden');
        messageTextWrap.removeClass('hidden').addClass('show');
        removeNote($removeNote, message, characterCount);
      } else {
        message.addClass('hidden').val('');
        messageTextWrap.addClass('hidden').removeClass('show');
      }
    });

    if (checkbox.prop('checked')) {
      message.removeClass('hidden');
      messageTextWrap.removeClass('hidden').addClass('show');
    }

    message.keyup(function () {
      countChars(this, characterCount);
    });
  });
}
/**
 * Initialize the click handlers for gift wrap flyout
 *
 */


function initClickEvents() {
  $('.gift-wrap-checkbox:checked').addClass('checked-gift-wrap');
  $('.gift-wrap-remove-note').on('click', function () {
    var message = $(this).parent().prev('.gift-wrap-message');
    var errorMessageContainer = message.nextAll('.giftwrap-error-message');
    var characterCount = $(this).prev('#charNum');
    removeNote($(this), message, characterCount);
    message.removeClass('is-invalid');
    errorMessageContainer.text('').removeClass('d-block');
  });
  $('.close-giftWrapFlyout').on('click', function () {});
  $('.gift-wrap-message').on('blur', function (event) {
    var textarea = $(this);
    var errorMessageContainer = textarea.nextAll('.giftwrap-error-message');
    var invalidCharsMessage = textarea.data('errorPatternMsg'); // Clear exisiting error

    textarea.removeClass('is-invalid');
    errorMessageContainer.text('').removeClass('d-block');
    var isMsgValid = validateGiftWrapMessage(textarea);

    if (!isMsgValid) {
      textarea.addClass('is-invalid');
      errorMessageContainer.text(invalidCharsMessage).addClass('d-block');
      return false;
    }

    if (event.relatedTarget && event.relatedTarget.type === 'submit') {
      $('#submit-giftWrapForm').trigger('click');
    }
  });
  $('#giftWrapModal').on('hide.bs.modal', function (e) {
    var invalidMsg = $('.gift-wrap-message.is-invalid');

    if (invalidMsg.length) {
      e.preventDefault();
      invalidMsg[0].focus();
    }
  });
  $(document).on('click', '.gift-heading', function () {
    $('.gift-wrap-checkbox').prop('checked', true);
    $('.gift-wrap-checkbox:checked').closest('.product-content-block').find('textarea').each(function () {
      $(this).val($(this).attr('data-text-value'));
    });
    $('.gift-wrap-checkbox').each(function () {
      if (!$(this).hasClass('checked-gift-wrap')) {
        $(this).prop('checked', false);
      }
    });
    $('.gift-wrap-message').each(function () {
      $(this).val($(this).attr('data-text-value'));

      if (!$(this).hasClass('textarea-checked') && !$(this).val() || $(this).val() === 'null') {
        $(this).val('');
        $(this).empty();
      }
    });
    giftWrapToggleMessage();
  });
}

module.exports = {
  giftWrapformSubmission: function giftWrapformSubmission() {
    var submitForm = $('#submit-giftWrapForm');

    if (submitForm.length) {
      submitForm.on('click', submitGiftWrapForm);
    }
  },
  updateGiftWrapSummary: updateGiftWrapSummary,
  giftWrapToggleMessage: giftWrapToggleMessage,
  initClickEvents: initClickEvents
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/shipping.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/shipping.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var addressHelpers = __webpack_require__(/*! ./address */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/address.js");

var formHelpers = __webpack_require__(/*! ./formErrors */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js");

var scrollAnimate = __webpack_require__(/*! ../components/scrollAnimate */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js");

var clientSideValidation = __webpack_require__(/*! ../components/clientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js");

var loqateAddressSuggestion = __webpack_require__(/*! ../thirdParty/loqateAddressSuggestion */ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/loqateAddressSuggestion.js");

var customClientSideValidation = __webpack_require__(/*! ../components/customClientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/customClientSideValidation.js");

var FREESHIPPING = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").FREESHIPPING);

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");

var phoneFormatter = __webpack_require__(/*! ../utilities/phoneFormatter */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/phoneFormatter.js");
/**
 * updates the shipping address summary
 * @param  {string} selectedShippingAddressType - Selected shipping address type
 */


function _initialLoadAddressDisplay(selectedShippingAddressType) {
  $('.shipment-summary-auth').removeClass('d-none');
  var $shipmentAddressOption = $('#shipmentSelector-default option:selected');

  if (selectedShippingAddressType === 'new') {
    $('.shippment-name-summary-authenticated').empty();
    $('.shippment-phone-summary-authenticated').empty();
    $('.shippment-address1-summary-authenticated').empty();
    $('.shippment-address2-summary-authenticated').empty();
    $('.shippment-city-summary-authenticated').empty();
    $('.shipping-address-block').find('.shippingFirstName, .shippingLastName, .shippingPhoneNumber').val('');
    $('.shipping-address-block').find('.shippingFirstName, .shippingLastName, .shippingPhoneNumber').attr('value', '');
  } else {
    $('.shippment-name-summary-authenticated').empty().append($shipmentAddressOption.data('first-name') + ' ').append($('option:selected').data('last-name'));
    $('.shippment-phone-summary-authenticated').empty().append($shipmentAddressOption.data('phone'));
    $('.shippment-address1-summary-authenticated').empty().append($shipmentAddressOption.data('address1'));
    $('.shippment-address2-summary-authenticated').empty().append($shipmentAddressOption.data('address2'));
    $('.shippment-city-summary-authenticated').empty().append($shipmentAddressOption.data('city')).append($shipmentAddressOption.data('city').length !== 0 ? ', ' : '').append($shipmentAddressOption.data('state-code') === null ? '' : $shipmentAddressOption.data('state-code') + ' ').append($shipmentAddressOption.data('postal-code') + ' ');
  }

  if ($('.shipping-address-block').hasClass('d-none') || $('.shipping-address-block').css('display') === 'none') {
    $('.shipment-summary-change-block').removeClass('d-none');
  } else {
    $('.shipment-summary-change-block').addClass('d-none');
  }
}
/**
 * Compare edited address changes for address verification
 * @returns{boolean} isVerified
 */


function verifyEditedAddress() {
  var $shipmentAddressOption = $('#shipmentSelector-default option:selected');
  var isVerified = true;

  if ($('.submit-shipping').data('address-verify-enabled')) {
    var address1 = $shipmentAddressOption.data('address1');
    isVerified = $shipmentAddressOption.data('isverified');
    var address2 = $shipmentAddressOption.data('address2') === null ? '' : $shipmentAddressOption.data('address2');
    var city = $shipmentAddressOption.data('city');
    var state = $shipmentAddressOption.data('state-code');
    var postCode = $shipmentAddressOption.data('postal-code');

    if (!(address1 === $('.shippingAddressOne').val() && address2 === $('.shippingAddressTwo').val() && city === $('.shippingAddressCity').val() && state === $('.shippingState').val() && postCode.toString() === $('.shippingZipCode').val())) {
      $('.save-address-shipping a').addClass('active-suggestion');
      $('.submit-shipping').addClass('active-suggestion');
      isVerified = 'false';
    }
  }

  return isVerified;
}
/**
 * Populate the fields using selcted option
 */


function _populateAddressFields() {
  var $shipmentAddressOption = $('#shipmentSelector-default option:selected');
  $('.shippingFirstName').val($shipmentAddressOption.data('first-name'));
  $('.shippingFirstName').closest('.form-group').removeClass('is-invalid');
  $('.shippingLastName').val($shipmentAddressOption.data('last-name'));
  $('.shippingLastName').closest('.form-group').removeClass('is-invalid');
  $('.shippingPhoneNumber').val($shipmentAddressOption.data('phone'));
  $('.shippingPhoneNumber').closest('.form-group').removeClass('is-invalid');
  phoneFormatter.methods.setPhoneCountry($('.shippingPhoneNumber'), $shipmentAddressOption.data('phonee164'));
  $('.shippingAddressOne').val($shipmentAddressOption.data('address1'));
  $('.shippingAddressOne').closest('.form-group').removeClass('is-invalid');
  $('.shippingAddressTwo').val($shipmentAddressOption.data('address2'));
  $('.shippingAddressTwo').closest('.form-group').removeClass('is-invalid');
  $('.shippingAddressCity').val($shipmentAddressOption.data('city'));
  $('.shippingAddressCity').closest('.form-group').removeClass('is-invalid');
  $('.shippingState').val($shipmentAddressOption.data('state-code'));
  $('.shippingState').closest('.form-group').removeClass('is-invalid');
  $('.shippingZipCode').val($shipmentAddressOption.data('postal-code'));
  $('.shippingZipCode').closest('.form-group').removeClass('is-invalid');
  $('.shipping-address-id').val($shipmentAddressOption.data('addressid'));
  $('.shipping-address-id').closest('.form-group').removeClass('is-invalid');
  var shippingCountry = $shipmentAddressOption.data('country-code');

  if (shippingCountry) {
    $('.shippingCountry').find('option[value=' + shippingCountry + ']').prop('selected', true);
    $('.shippingCountry').closest('.form-group').removeClass('is-invalid');
  }
}
/**
 * updates the shipping address selector within shipping forms to edit it
 * @param {Object} response - the saved address fields
 * @returns {Object} addressOption
 */


function getAddresssDropdownOption(response) {
  var addressFields = response.address;
  var addressOption = "<option data-first-name=\"".concat(addressFields.firstName, "\" \n    data-last-name=\"").concat(addressFields.lastName, "\"\n    data-address1=\"").concat(addressFields.address1, "\" \n    data-address2=\"").concat(addressFields.address2, "\"\n    data-addressId=\"").concat(addressFields.addressId, "\"\n    data-city=\"").concat(addressFields.city, "\" \n    data-state-code=\"").concat(addressFields.stateCode, "\"\n    data-country-code=\"").concat(addressFields.countryCode.value, "\" \n    data-postal-code=\"").concat(addressFields.postalCode, "\"\n    data-phone=\"").concat(addressFields.phone, "\"\n    data-phonee164=\"").concat(addressFields.phoneE164, "\" \n    data-is-gift=\"").concat(response.shippingAddress.isGift, "\" \n    data-isverified=\"").concat(response.isVerified, "\"\n    data-gift-message=\"", "\" selected=\"selected\">\n    ").concat(addressFields.address1, " ").concat(addressFields.address2 !== null ? addressFields.address2 : '', " ").concat(addressFields.city, " ").concat(addressFields.stateCode !== null ? addressFields.stateCode : '', " ").concat(addressFields.postalCode, "\n    </option>");
  return addressOption;
}
/**
 * updates the shipping address selector within shipping forms
 * @param {Object} productLineItem - the productLineItem model
 * @param {Object} shipping - the shipping (shipment model) model
 * @param {Object} order - the order model
 * @param {Object} customer - the customer model
 */


function updateShippingAddressSelector(productLineItem, shipping, order, customer) {
  var uuidEl = $('input[value=' + productLineItem.UUID + ']');
  var shippings = order.shipping;
  var form;
  var $shippingAddressSelector;
  var hasSelectedAddress = false;

  if (uuidEl && uuidEl.length > 0) {
    form = uuidEl[0].form;
    $shippingAddressSelector = $('.addressSelector', form);
  }

  if ($shippingAddressSelector && $shippingAddressSelector.length === 1) {
    $shippingAddressSelector.empty(); // Add New Address option

    $shippingAddressSelector.append(addressHelpers.methods.optionValueForAddress(null, false, order));

    if (customer.addresses && customer.addresses.length > 0) {
      $shippingAddressSelector.append(addressHelpers.methods.optionValueForAddress(order.resources.accountAddresses, false, order));
      customer.addresses.forEach(function (address) {
        var isSelected = shipping.matchingAddressId === address.ID;
        $shippingAddressSelector.append(addressHelpers.methods.optionValueForAddress({
          UUID: 'ab_' + address.ID,
          shippingAddress: address
        }, isSelected, order));
      });
    } // Separator -


    $shippingAddressSelector.append(addressHelpers.methods.optionValueForAddress(order.resources.shippingAddresses, false, order, {
      className: 'multi-shipping'
    }));
    shippings.forEach(function (aShipping) {
      var isSelected = shipping.UUID === aShipping.UUID;
      hasSelectedAddress = hasSelectedAddress || isSelected;
      var addressOption = addressHelpers.methods.optionValueForAddress(aShipping, isSelected, order, {
        className: 'multi-shipping'
      });
      var newAddress = addressOption.html() === order.resources.addNewAddress;
      var matchingUUID = aShipping.UUID === shipping.UUID;

      if (newAddress && matchingUUID || !newAddress && matchingUUID || !newAddress && !matchingUUID) {
        $shippingAddressSelector.append(addressOption);
      }

      if (newAddress && !matchingUUID) {
        $(addressOption[0]).remove();
      }
    });
  }

  if (!hasSelectedAddress) {
    // show
    $(form).addClass('hide-details');
  } else {
    $(form).removeClass('hide-details');
  }

  $('body').trigger('shipping:updateShippingAddressSelector', {
    productLineItem: productLineItem,
    shipping: shipping,
    order: order,
    customer: customer
  });
}
/**
 * updates the shipping address form values within shipping forms
 * @param {Object} shipping - the shipping (shipment model) model
 */


function updateShippingAddressFormValues(shipping) {
  var addressObject = $.extend({}, shipping.shippingAddress);

  if (!addressObject) {
    addressObject = {
      firstName: null,
      lastName: null,
      address1: null,
      address2: null,
      city: null,
      postalCode: null,
      stateCode: null,
      countryCode: null,
      phone: null
    };
  }

  addressObject.isGift = shipping.isGift;
  addressObject.giftMessage = shipping.giftMessage;
  $('input[value=' + shipping.UUID + ']').each(function (formIndex, el) {
    var form = el.form;
    if (!form) return;
    var countryCode = addressObject.countryCode;
    $('input[name$=_firstName]', form).val(addressObject.firstName);
    $('input[name$=_lastName]', form).val(addressObject.lastName);
    $('input[name$=_address1]', form).val(addressObject.address1);
    $('input[name$=_address2]', form).val(addressObject.address2);
    $('input[name$=_city]', form).val(addressObject.city);
    $('input[name$=_postalCode]', form).val(addressObject.postalCode);
    $('select[name$=_stateCode],input[name$=_stateCode]', form).val(addressObject.stateCode);

    if (countryCode && _typeof(countryCode) === 'object') {
      $('select[name$=_country]', form).val(addressObject.countryCode.value);
    } else if (addressObject.countryCodes) {
      $('select[name$=_country]', form).val(addressObject.countryCode);
    }

    $('input[name$=_phone]', form).val(addressObject.phone);
    $('input[name$=_isGift]', form).prop('checked', addressObject.isGift);
    $('textarea[name$=_giftMessage]', form).val(addressObject.isGift && addressObject.giftMessage ? addressObject.giftMessage : '');
  });
  $('body').trigger('shipping:updateShippingAddressFormValues', {
    shipping: shipping
  });
}
/**
 * updates the shipping section
 * @param {Object} order - the order (order model) model
 */


function updateShippingMethodInformation(order) {
  var shippingModel = order.shipping[0];
  var $restrictedShippmentMsg = $('#smRestrictedDiv');

  if (shippingModel.applicableShippingMethods.length > 0) {
    $restrictedShippmentMsg.addClass('d-none');
  }

  if (shippingModel.shippingAddress && shippingModel.shippingAddress.postalCode && order.noOfEcomItems > 0 && order.noOfOnlyVGCItems === 0) {
    if (shippingModel.applicableShippingMethods && shippingModel.applicableShippingMethods.length === 0) {
      $restrictedShippmentMsg.addClass('js-no-shipping-methods');
      $restrictedShippmentMsg.removeClass('d-none');
    } else {
      $restrictedShippmentMsg.removeClass('js-no-shipping-methods');
    }
  }
}
/**
 * Checked whether valid shipping method is selected on checkout flow.
 * @returns {boolean} isValid shipping methods
 */


function validateShippingMethod() {
  var isValid = true;

  if ($('#smRestrictedDiv:visible').hasClass('js-no-shipping-methods')) {
    $('#smRestrictedDiv').removeClass('d-none');
    isValid = false;
  }

  return isValid;
}
/**
 * updates the shipping method radio buttons within shipping forms
 * @param {Object} shipping - the shipping (shipment model) model
 */


function updateShippingMethods(shipping) {
  var uuidEl = $('input[value=' + shipping.UUID + ']');

  if (uuidEl && uuidEl.length > 0) {
    $.each(uuidEl, function (shipmentIndex, el) {
      var form = el.form;
      if (!form) return;
      var $shippingMethodList = $('.shipping-method-list', form);

      if ($shippingMethodList && $shippingMethodList.length > 0) {
        $shippingMethodList.empty();
        var shippingMethods = shipping.applicableShippingMethods;
        var selected = shipping.selectedShippingMethod || {};
        var shippingMethodFormID = form.name + '_shippingAddress_shippingMethodID'; //
        // Create the new rows for each shipping method
        //

        $.each(shippingMethods, function (methodIndex, shippingMethod) {
          var tmpl = $('#shipping-method-template').clone(); // set input

          $('input', tmpl).prop('id', 'shippingMethod-' + shippingMethod.ID + '-' + shipping.UUID).prop('class', 'shipping-method-radio').prop('name', shippingMethodFormID).prop('value', shippingMethod.ID).attr('checked', shippingMethod.ID === selected.ID);
          $('label', tmpl).prop('for', 'shippingMethod-' + shippingMethod.ID + '-' + shipping.UUID); // set shipping method name

          $('.display-name', tmpl).text(shippingMethod.displayName); // set or hide arrival time

          if (shippingMethod.estimatedArrivalTime) {
            $('.arrival-time', tmpl).text(shippingMethod.estimatedArrivalTime).show();
          } // set shipping cost


          $('.shipping-cost', tmpl).text(shippingMethod.shippingCost);

          if ($(this)[0].promotionalShippingPrice !== '') {
            $('.promotion-cost', tmpl).text(shippingMethod.promotionalShippingPrice);
          }

          $shippingMethodList.append(tmpl.html());

          if ($(this)[0].promotionalShippingPrice !== '') {
            $($('.shipping-method-section')[methodIndex]).find('.shipping-cost').addClass('strike-off-price');
            $($('.shipping-method-section')[methodIndex]).find('.shipping-costsr').removeClass('d-none');
            $($('.shipping-method-section')[methodIndex]).find('.promotion-costsr').removeClass('d-none');
          } else {
            $($('.shipping-method-section')[methodIndex]).find('.shipping-cost').removeClass('strike-off-price');
            $($('.shipping-method-section')[methodIndex]).find('.shipping-costsr').addClass('d-none');
            $($('.shipping-method-section')[methodIndex]).find('.promotion-costsr').addClass('d-none');
          }
        });
      }
    });
  }

  $('body').trigger('shipping:updateShippingMethods', {
    shipping: shipping
  });
}
/**
 * Update list of available shipping methods whenever user modifies shipping address details.
 * @param {jQuery} $shippingForm - current shipping form
 */


function updateShippingMethodList($shippingForm) {
  // delay for autocomplete!
  setTimeout(function () {
    var $shippingMethodList = $shippingForm.find('.shipping-method-list');
    var urlParams = addressHelpers.methods.getAddressFieldsFromUI($shippingForm);
    var shipmentUUID = $shippingForm.find('[name=shipmentUUID]').val();
    var url = $shippingMethodList.data('actionUrl');
    urlParams.shipmentUUID = shipmentUUID;
    $shippingMethodList.spinner().start();
    $.ajax({
      url: url,
      type: 'post',
      dataType: 'json',
      data: urlParams,
      success: function success(data) {
        if (data.error) {
          window.location.href = data.redirectUrl;
        } else {
          $('body').trigger('checkout:updateCheckoutView', {
            order: data.order,
            customer: data.customer,
            options: {
              keepOpen: true
            }
          });

          if (data.order.shipping[0].applicableShippingMethods.length > 0) {
            $('.shipping-method-cost').removeClass('d-none');
          }

          $shippingMethodList.spinner().stop();
          $('.shipping-method-list input:checked').closest('.shipping-method-section').find('.shipping-method-pricing').addClass('selectedRadio');
        }
      }
    });
  }, 300);
}
/**
 * updates the order shipping summary for an order shipment model
 * @param {Object} shipping - the shipping (shipment model) model
 * @param {Object} order - the order model
 */


function updateShippingSummaryInformation(shipping, order) {
  $('[data-shipment-summary=' + shipping.UUID + ']').each(function (i, el) {
    var $container = $(el);
    var $shippingAddressLabel = $container.find('.shipping-addr-label');
    var $addressContainer = $container.find('.shipping .address-summary');
    var $shippingPhone = $container.find('.js-shipping-phone');
    var $methodTitle = $container.find('.shipping-method-title');
    var $methodArrivalTime = $container.find('.shipping-method-arrival-time');
    var $methodPrice = $container.find('.shipping-method-price');
    var $shippingSummaryLabel = $container.find('.shipping-method-label');
    var $summaryDetails = $container.find('.row.summary-details');
    var giftMessageSummary = $container.find('.gift-summary');
    var address = shipping.shippingAddress;
    var selectedShippingMethod = shipping.selectedShippingMethod;
    var isGift = shipping.isGift;
    addressHelpers.methods.populateAddressSummary($addressContainer, address);

    if (address && address.phone) {
      $shippingPhone.text(address.phone);
    } else {
      $shippingPhone.empty();
    }

    if (selectedShippingMethod) {
      $('body').trigger('shipping:updateAddressLabelText', {
        selectedShippingMethod: selectedShippingMethod,
        resources: order.resources,
        shippingAddressLabel: $shippingAddressLabel
      });
      $shippingSummaryLabel.show();
      $summaryDetails.show();
      $methodTitle.text(selectedShippingMethod.displayName);

      if (selectedShippingMethod.estimatedArrivalTime) {
        $methodArrivalTime.text(selectedShippingMethod.estimatedArrivalTime);
      } else {
        $methodArrivalTime.empty();
      }

      if (selectedShippingMethod.promotionalShippingPrice) {
        $methodPrice.text(' ' + selectedShippingMethod.promotionalShippingPrice);
      } else {
        $methodPrice.text(' ' + selectedShippingMethod.shippingCost);
      }
    }

    if (isGift) {
      giftMessageSummary.find('.gift-message-summary').text(shipping.giftMessage);
      giftMessageSummary.removeClass('d-none');
    } else {
      giftMessageSummary.addClass('d-none');
    }
  });
  $('body').trigger('shipping:updateShippingSummaryInformation', {
    shipping: shipping,
    order: order
  });
}
/**
 * Update the read-only portion of the shipment display (per PLI)
 * @param {Object} productLineItem - the productLineItem model
 * @param {Object} shipping - the shipping (shipment model) model
 * @param {Object} order - the order model
 * @param {Object} [options] - options for updating PLI summary info
 * @param {Object} [options.keepOpen] - if true, prevent changing PLI view mode to 'view'
 */


function updatePLIShippingSummaryInformation(productLineItem, shipping, order, options) {
  var $pli = $('input[value=' + productLineItem.UUID + ']');
  var form = $pli && $pli.length > 0 ? $pli[0].form : null;
  if (!form) return;
  var $viewBlock = $('.view-address-block', form);
  var address = shipping.shippingAddress || {};
  var selectedMethod = shipping.selectedShippingMethod;
  var nameLine = address.firstName ? address.firstName + ' ' : '';
  if (address.lastName) nameLine += address.lastName;
  var address1Line = address.address1;
  var address2Line = address.address2;
  var phoneLine = address.phone;
  var shippingCost = selectedMethod ? selectedMethod.shippingCost : '';
  var methodNameLine = selectedMethod ? selectedMethod.displayName : '';
  var methodArrivalTime = selectedMethod && selectedMethod.estimatedArrivalTime ? '(' + selectedMethod.estimatedArrivalTime + ')' : '';
  var tmpl = $('#pli-shipping-summary-template').clone();
  $('.ship-to-name', tmpl).text(nameLine);
  $('.ship-to-address1', tmpl).text(address1Line);
  $('.ship-to-address2', tmpl).text(address2Line);
  $('.ship-to-city', tmpl).text(address.city);

  if (address.stateCode) {
    $('.ship-to-st', tmpl).text(address.stateCode);
  }

  $('.ship-to-zip', tmpl).text(address.postalCode);
  $('.ship-to-phone', tmpl).text(phoneLine);

  if (!address2Line) {
    $('.ship-to-address2', tmpl).hide();
  }

  if (!phoneLine) {
    $('.ship-to-phone', tmpl).hide();
  }

  if (shipping.selectedShippingMethod) {
    $('.display-name', tmpl).text(methodNameLine);
    $('.arrival-time', tmpl).text(methodArrivalTime);
    $('.price', tmpl).text(shippingCost);
  }

  if (shipping.isGift) {
    $('.gift-message-summary', tmpl).text(shipping.giftMessage);
    var shipment = $('.gift-message-' + shipping.UUID);
    $(shipment).val(shipping.giftMessage);
  } else {
    $('.gift-summary', tmpl).addClass('d-none');
  } // checking h5 title shipping to or pickup


  var $shippingAddressLabel = $('.shipping-header-text', tmpl);
  $('body').trigger('shipping:updateAddressLabelText', {
    selectedShippingMethod: selectedMethod,
    resources: order.resources,
    shippingAddressLabel: $shippingAddressLabel
  });
  $viewBlock.html(tmpl.html());
  $('body').trigger('shipping:updatePLIShippingSummaryInformation', {
    productLineItem: productLineItem,
    shipping: shipping,
    order: order,
    options: options
  });
}
/**
 * Update the hidden form values that associate shipping info with product line items
 * @param {Object} productLineItem - the productLineItem model
 * @param {Object} shipping - the shipping (shipment model) model
 */


function updateProductLineItemShipmentUUIDs(productLineItem, shipping) {
  $('input[value=' + productLineItem.UUID + ']').each(function (key, pli) {
    var form = pli.form;
    $('[name=shipmentUUID]', form).val(shipping.UUID);
    $('[name=originalShipmentUUID]', form).val(shipping.UUID);
    $(form).closest('.card').attr('data-shipment-uuid', shipping.UUID);
  });
  $('body').trigger('shipping:updateProductLineItemShipmentUUIDs', {
    productLineItem: productLineItem,
    shipping: shipping
  });
}
/**
 * Update the shipping UI for a single shipping info (shipment model)
 * @param {Object} shipping - the shipping (shipment model) model
 * @param {Object} order - the order/basket model
 * @param {Object} customer - the customer model
 * @param {Object} [options] - options for updating PLI summary info
 * @param {Object} [options.keepOpen] - if true, prevent changing PLI view mode to 'view'
 */


function updateShippingInformation(shipping, order, customer, options) {
  // First copy over shipmentUUIDs from response, to each PLI form
  order.shipping.forEach(function (aShipping) {
    aShipping.productLineItems.items.forEach(function (productLineItem) {
      updateProductLineItemShipmentUUIDs(productLineItem, aShipping);
    });
  }); // Now update shipping information, based on those associations

  updateShippingMethods(shipping);
  updateShippingAddressFormValues(shipping);
  updateShippingSummaryInformation(shipping, order); // Update shipping restricted message

  updateShippingMethodInformation(order); // And update the PLI-based summary information as well

  shipping.productLineItems.items.forEach(function (productLineItem) {
    updateShippingAddressSelector(productLineItem, shipping, order, customer);
    updatePLIShippingSummaryInformation(productLineItem, shipping, order, options);
  });
  $('body').trigger('shipping:updateShippingInformation', {
    order: order,
    shipping: shipping,
    customer: customer,
    options: options
  });
}
/**
 * Update the checkout state (single vs. multi-ship)
 * @param {Object} order - checkout model to use as basis of new truth
 */


function updateMultiShipInformation(order) {
  var $checkoutMain = $('#checkout-main');
  var $checkbox = $('[name=usingMultiShipping]');
  var $submitShippingBtn = $('button.submit-shipping');
  $('.shipping-error .alert-danger').remove();

  if (order.usingMultiShipping) {
    $checkbox.prop('checked', true);
    $submitShippingBtn.prop('disabled', null);
  } else {
    $checkoutMain.removeClass('multi-ship');
    $checkbox.prop('checked', null);
    $submitShippingBtn.prop('disabled', null);
  }

  $('body').trigger('shipping:updateMultiShipInformation', {
    order: order
  });
}
/**
  * Create an alert to display the error message
  * @param {Object} message - Error message to display
  */


function createErrorNotification(message) {
  var errorHtml = '<div class="alert alert-danger alert-dismissible valid-cart-error ' + 'fade show" role="alert">' + '<button type="button" class="close" data-dismiss="alert" aria-label="Close">' + '<span aria-hidden="true">&times;</span>' + '</button>' + message + '</div>';
  $('.shipping-error').append(DOMpurify.sanitize(errorHtml));
  scrollAnimate($('.shipping-error'));
}
/**
 * Handle response from the server for valid or invalid form fields.
 * @param {Object} defer - the deferred object which will resolve on success or reject.
 * @param {Object} data - the response data with the invalid form fields or
 *  valid model data.
 */


function shippingFormResponse(defer, data) {
  var isMultiShip = $('#checkout-main').hasClass('multi-ship');
  var formSelector = isMultiShip ? '.multi-shipping .active form' : '.single-shipping form'; // highlight fields with errors

  if (data.error) {
    if (data.fieldErrors.length) {
      data.fieldErrors.forEach(function (error) {
        if (Object.keys(error).length) {
          formHelpers.loadFormErrors(formSelector, error);
        }
      });
      loqateAddressSuggestion.methods.loqateRequiredValidation(formSelector);
      $('.shipping-address-block').removeClass('d-none').css('display', 'block');
      defer.reject(data);
    }

    if (data.serverErrors && data.serverErrors.length) {
      $.each(data.serverErrors, function (index, element) {
        createErrorNotification(element);
      });
      defer.reject(data);
    }

    if (data.cartError) {
      window.location.href = data.redirectUrl;
      defer.reject();
    }
  } else {
    // Populate the Address Summary
    $('body').trigger('checkout:updateCheckoutView', {
      order: data.order,
      customer: data.customer
    });
    var isShippingMethod = $('.shipping-method-list .shipping-method-section').length > 0;
    var onlyPISorVGC = $('.shipping-address-wrap').data('disable-address-fields');

    if (isShippingMethod || onlyPISorVGC) {
      defer.resolve(data);
      scrollAnimate($('.payment-section'), true);
    }
  }
}
/**
 * Clear out all the shipping form values and select the new address in the drop down
 * @param {Object} order - the order object
 */


function clearShippingForms(order) {
  order.shipping.forEach(function (shipping) {
    $('input[value=' + DOMpurify.sanitize(shipping.UUID) + ']').each(function (formIndex, el) {
      var form = el.form;
      if (!form) return;
      $('input[name$=_firstName]', form).val('');
      $('input[name$=_lastName]', form).val('');
      $('input[name$=_address1]', form).val('');
      $('input[name$=_address2]', form).val('');
      $('input[name$=_city]', form).val('');
      $('input[name$=_postalCode]', form).val('');
      $('select[name$=_stateCode],input[name$=_stateCode]', form).val('');
      $('select[name$=_country]', form).val('');
      $('input[name$=_phone]', form).val('');
      $('input[name$=_isGift]', form).prop('checked', false);
      $('textarea[name$=_giftMessage]', form).val('');
      $(form).find('.gift-message').addClass('d-none');
      $(form).attr('data-address-mode', 'new');
      var addressSelectorDropDown = $('.addressSelector option[value=new]', form);
      $(addressSelectorDropDown).prop('selected', true);
    });
  });
  $('body').trigger('shipping:clearShippingForms', {
    order: order
  });
}
/**
 * Does Ajax call to select shipping method
 * @param {string} url - string representation of endpoint URL
 * @param {Object} urlParams - url params
 * @param {Object} el - element that triggered this call
 */


function selectShippingMethodAjax(url, urlParams, el) {
  $.spinner().start();
  $('body').trigger('checkout:beforeShippingMethodSelected');
  var couponBlock = '';
  $.ajax({
    url: url,
    type: 'post',
    dataType: 'json',
    data: urlParams
  }).done(function (data) {
    if (data.error) {
      window.location.href = data.redirectUrl;
    } else {
      $('body').trigger('checkout:updateCheckoutView', {
        order: data.order,
        customer: data.customer,
        options: {
          keepOpen: true
        },
        urlParams: urlParams
      });
      $('.shipping-method-section').removeClass('d-none');
      $('body').trigger('checkout:postUpdateCheckoutView', {
        el: el
      });
      $('.shipping-method-list input:checked').closest('.shipping-method-section').find('.shipping-method-pricing').addClass('selectedRadio');
      var shippingInterval = setInterval(function () {
        if ($('.shipping-method-block').is(':visible')) {
          clearInterval(shippingInterval);
          $(document).find('.shipping-method-section').each(function () {
            var shippingCost = $(this).find('.shipping-method-pricing .shipping-cost') ? $(this).find('.shipping-method-pricing .shipping-cost').text() : '';
            var promotionCost = $(this).find('.shipping-method-pricing .promotion-cost') ? $(this).find('.shipping-method-pricing .promotion-cost').text() : '';
            var labelText = $(this).find('label .display-name').text() + ' ' + $(this).find('label .arrival-time').text() + ' ' + (promotionCost ? $(this).find('.shipping-method-pricing .shipping-costsr').text() : '') + shippingCost + ' ' + (promotionCost ? $(this).find('.shipping-method-pricing .promotion-costsr').text() : '') + promotionCost;
            $(this).find('input').attr('aria-label', labelText);
          });
        }
      }, 100);

      if (data.order.totals.couponDiscountsTotal && data.order.totals.couponDiscountsTotal.value < 0) {
        $('.order-coupon-total-checkout').empty().append(DOMpurify.sanitize(data.order.totals.couponDiscountsTotal.formatted));
      } else {
        $('.order-coupon-total-checkout').empty().append('--');
      }

      data.order.totals.discounts.forEach(function (couponval) {
        var code;
        var uuid;
        var remove = $('.coupon-price-adjustment button').data('action');
        code = couponval.couponCode;
        uuid = couponval.UUID;

        if (couponval.applied) {
          couponBlock += '<div class="coupon-price-adjustment coupon-uuid-' + uuid + '" data-uuid="' + uuid + '"><div class="coupon-code text-uppercase">' + couponval.couponCode + '<button data-uuid="' + uuid + '" data-code="' + code + '" data-action="' + remove + '"class="float-right pr-0 bg-transparent border-0 delete-coupon-confirmation-btn"><span aria-hidden="true">×</span></button></div></div>';
          $('.appliedcode').html(couponBlock);
        } else if ((data.order.totals.totalShippingCost === FREESHIPPING || data.order.totals.totalShippingCost === 0) && !couponval.applied) {
          // hiding shipping promotion if it is not applied for updated shipping method
          couponBlock += '<div class="coupon-price-adjustment d-none coupon-uuid-' + uuid + '" data-uuid="' + uuid + '">';
          $('.appliedcode').html(couponBlock);
        }
      });
    }

    $('body').trigger('checkout:shippingMethodSelected', data);
    $.spinner().stop();
    $('.shipping-method-list input:checked').focus();
  }).fail(function () {
    $.spinner().stop();
  });
}
/**
 * Format phone number input field
 */


function _invalidFirstAndLastName() {
  $('.shipping-content input').on('blur', function (e) {
    e.preventDefault();
    var form = $('form.shipping-form');
    customClientSideValidation.fetchFirstLastName(form);
  });
}

module.exports = {
  methods: {
    updateShippingAddressSelector: updateShippingAddressSelector,
    updateShippingAddressFormValues: updateShippingAddressFormValues,
    updateShippingMethods: updateShippingMethods,
    updateShippingSummaryInformation: updateShippingSummaryInformation,
    updateMultiShipInformation: updateMultiShipInformation,
    updatePLIShippingSummaryInformation: updatePLIShippingSummaryInformation,
    updateProductLineItemShipmentUUIDs: updateProductLineItemShipmentUUIDs,
    updateShippingInformation: updateShippingInformation,
    shippingFormResponse: shippingFormResponse,
    selectShippingMethodAjax: selectShippingMethodAjax,
    updateShippingMethodList: updateShippingMethodList,
    clearShippingForms: clearShippingForms,
    createErrorNotification: createErrorNotification,
    updateShippingMethodInformation: updateShippingMethodInformation,
    validateShippingMethod: validateShippingMethod,
    verifyEditedAddress: verifyEditedAddress
  },
  addNewShippingAddress: function addNewShippingAddress() {
    $('.save .btn-save-shipping-address').on('click', function (e) {
      e.preventDefault();

      if ($('.shipping-address  .customer-checkout-label').attr('data-address-method') === 'new') {
        $('.shipping-address-block .js-checkout-country-select').find('option:first').prop('selected', true);
        var form = $(this).closest('form');
        var formObj = form.get(0);
        var formValid = clientSideValidation.functions.validateForm(formObj);
        var isValidPhone = phoneFormatter.methods.validatePhoneNumber(form.find('.js-phone'));

        if ($('.loqate-address-block').is(':visible')) {
          loqateAddressSuggestion.methods.loqateRequiredValidation(form);
        }

        var addressSuggestionField = loqateAddressSuggestion.methods.formValid(form);
        var formValidCustom = customClientSideValidation.fetchFirstLastName(form);
        var addressFieldsValidation = customClientSideValidation.isAddressTooLong(form.find('.js-loqate-addressOne'), form.find('.js-loqate-addressTwo'));
        var isVerified = $('.btn-save-shipping-address').attr('data-isverified'); // var saveAndContinue = loqateAddressSuggestion.methods.saveAndContinue();

        if (formValid && formValidCustom && addressSuggestionField && addressFieldsValidation && isValidPhone) {
          $.spinner().start();
          var url = $(this).attr('href');
          var shippingFormData = phoneFormatter.methods.serializeFormData(form);
          loqateAddressSuggestion.methods.verifyNewAddress('#loqateSelectedAddress', '.shipping-address-block');

          if ($('.save-address-shipping.save a').hasClass('active-suggestion') && isVerified === 'false') {
            $('input[name="isVerified"]').val('true');
            shippingFormData = phoneFormatter.methods.serializeFormData(form);

            if ($('body .loqate-address-suggestion').length === 0) {
              loqateAddressSuggestion.methods.createAddressSuggestionModal();
              $('body').find('.loqate-address-suggestion').addClass('active-shipping');
              $.ajax({
                url: $('.submit-shipping').data('address-suggestion-url'),
                type: 'post',
                dataType: 'json',
                data: shippingFormData,
                success: function success(data) {
                  if (data.modalType) {
                    $('body').find('.loqate-address-suggestion .modal-content').append(DOMpurify.sanitize(data.renderedTemplate));
                    $('body').find('#loqate-address-suggestion').modal('show');
                  } else {
                    $('.submit-shipping').removeClass('active-suggestion');
                    loqateAddressSuggestion.methods.destroySuggestionModal();
                    $('.save .btn-save-shipping-address').click();
                  }

                  $.spinner().stop();
                },
                error: function error() {
                  location.reload();
                }
              });
            }
          } else {
            if ($('.save-address-shipping.save a').data('address-verify-enabled') && $('.save-address-shipping a').data('address-suggestion-enabled')) {
              $('input[name="isVerified"]').val('true');
              shippingFormData = phoneFormatter.methods.serializeFormData(form);
            }

            $.ajax({
              url: url,
              type: 'post',
              dataType: 'json',
              data: shippingFormData,
              success: function success(response) {
                $.spinner().stop();
                var addressOption = getAddresssDropdownOption(response);

                if (addressOption) {
                  var selectedAddressOption = $('#shipmentSelector-default option:selected');
                  var selectedOptionAddressID = selectedAddressOption && selectedAddressOption.data('addressid') ? selectedAddressOption.data('addressid') : '';

                  if (selectedAddressOption && selectedOptionAddressID && selectedOptionAddressID === response.shippingAddress.addressFields.addressId) {
                    selectedAddressOption.replaceWith(DOMpurify.sanitize(addressOption));
                  } else {
                    $('#shipmentSelector-default').append(DOMpurify.sanitize(addressOption));
                  }
                }

                _initialLoadAddressDisplay('save');

                $('.shipping-address-block').addClass('d-none');
                $('.shipment-selector-block').removeClass('d-none');
                $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'inline-block');
                $('.save-address-shipping ~ .invalid-saved-address').addClass('d-none');
                $('.single-shipping .addressSelector').trigger('change');
                $('.shipment-summary-change-block').removeClass('d-none');
                $('.edit-save-block').removeClass('d-none');
              },
              error: function error() {
                location.reload();
              }
            });
          }
        } else {
          return formValid;
        }
      }
    });
  },
  editShippingAddress: function editShippingAddress() {
    $('.edit .btn-save-shipping-address').on('click', function (e) {
      e.preventDefault();

      if ($('.shipping-address  .customer-checkout-label').attr('data-address-method') === 'edit') {
        var form = $(this).closest('form');
        var formObj = form.get(0);
        var formValid = clientSideValidation.functions.validateForm(formObj);
        loqateAddressSuggestion.methods.loqateRequiredValidation(form);
        var addressSuggestionField = loqateAddressSuggestion.methods.formValid(form);
        var formValidCustom = customClientSideValidation.fetchFirstLastName(form);
        var isValidPhone = phoneFormatter.methods.validatePhoneNumber(form.find('.js-phone'));
        var isVerified = $('#shipmentSelector-default option:selected').attr('data-isverified');
        var saveShippingAddressBtn = $('.edit .btn-save-shipping-address');

        if (!saveShippingAddressBtn.attr('data-isModalNull')) {
          isVerified = verifyEditedAddress();
        }

        saveShippingAddressBtn.removeAttr('data-isModalNull');

        if (formValid && addressSuggestionField && formValidCustom && isValidPhone) {
          var url = $(this).attr('href');
          var shippingFormData = phoneFormatter.methods.serializeFormData(form);
          $.spinner().start();

          if ($('.save-address-shipping.edit a').hasClass('active-suggestion') && isVerified.toString() === 'false') {
            $('input[name="isVerified"]').val('true'); // TODO: append isVerfied

            shippingFormData = phoneFormatter.methods.serializeFormData(form);

            if ($('body .loqate-address-suggestion').length === 0) {
              loqateAddressSuggestion.methods.createAddressSuggestionModal();
              $('body').find('.loqate-address-suggestion').addClass('active-shipping');
              $.ajax({
                url: $('.submit-shipping').data('address-suggestion-url'),
                type: 'post',
                dataType: 'json',
                data: shippingFormData,
                success: function success(data) {
                  if (data.modalType) {
                    $('body').find('.loqate-address-suggestion .modal-content').append(DOMpurify.sanitize(data.renderedTemplate));
                    $('body').find('#loqate-address-suggestion').modal('show');
                  } else {
                    $('.submit-shipping').removeClass('active-suggestion');
                    loqateAddressSuggestion.methods.destroySuggestionModal();
                    saveShippingAddressBtn.attr('data-isModalNull', true);
                    saveShippingAddressBtn.click();
                  }

                  $('.shipment-summary-change-block').removeClass('d-none');
                  $('.edit-save-block').removeClass('d-none');
                  $.spinner().stop();
                },
                error: function error() {
                  location.reload();
                }
              });
            }
          } else {
            if ($('.save-address-shipping a').data('address-verify-enabled') && $('.save-address-shipping a').data('address-suggestion-enabled')) {
              $('input[name="isVerified"]').val('true');
              shippingFormData = phoneFormatter.methods.serializeFormData(form);
            }

            $.ajax({
              url: url,
              type: 'post',
              dataType: 'json',
              data: shippingFormData,
              success: function success(response) {
                $.spinner().stop();
                var addressOption = getAddresssDropdownOption(response);

                if (addressOption) {
                  $('#shipmentSelector-default option:selected').replaceWith(DOMpurify.sanitize(addressOption));
                }

                _initialLoadAddressDisplay('edit');

                $('.edit-save-block').removeClass('d-none');
                $('.shipping-address-block').removeClass('d-block').addClass('d-none');
                $('.shipment-selector-block').removeClass('d-none');
                $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'inline-block');
                $('.save-address-shipping ~ .invalid-saved-address').addClass('d-none');
                $('.shipment-summary-change-block').removeClass('d-none');
              },
              error: function error() {
                location.reload();
              }
            });
          }
        } else {
          customClientSideValidation.scrollFunctionForError(form);
          return formValid;
        }
      }
    });
  },
  storeAddressPreviousState: function storeAddressPreviousState() {
    $('.btn-add-new').on('click', function () {
      var index = $($('.single-shipping .addressSelector').find('option:not(".multi-shipping"):selected')).index();
      $('.single-shipping .addressSelector').attr('previousSelected', index);
    });
  },
  validateShippingForm: function validateShippingForm() {
    $('form input, form select').on('focusout', function () {
      clientSideValidation.validateFormOnBlur($(this));
    });
  },
  selectShippingMethod: function selectShippingMethod() {
    var baseObj = this;
    $('.shipping-method-list').change(function () {
      var $shippingForm = $(this).parents('form');
      var methodID = $(':checked', this).val();
      var shipmentUUID = $shippingForm.find('[name=shipmentUUID]').val();
      var urlParams = addressHelpers.methods.getAddressFieldsFromUI($shippingForm);
      urlParams.shipmentUUID = shipmentUUID;
      urlParams.methodID = methodID;
      urlParams.isGift = $shippingForm.find('.gift').prop('checked');
      urlParams.giftMessage = $shippingForm.find('textarea[name$=_giftMessage]').val();
      var url = $(this).data('select-shipping-method-url');

      if (baseObj.methods && baseObj.methods.selectShippingMethodAjax) {
        baseObj.methods.selectShippingMethodAjax(url, urlParams, $(this));
      } else {
        selectShippingMethodAjax(url, urlParams, $(this));
      }
    });
  },
  cancelSavingShippingAddress: function cancelSavingShippingAddress() {
    $('.checkout-cancel').on('click', function () {
      var $shippingForm = $(this).parents('.shipping-form');
      var $cancelShippingButton = $(this).parents('.shipping-address').find('.customer-checkout-label');
      customClientSideValidation.clearFirstLastNameError($shippingForm);
      var replaceSelected = $('.single-shipping .addressSelector').attr('previousSelected');

      if ($('.single-shipping .addressSelector option').length > 1) {
        $($('.single-shipping .addressSelector').find('option')[replaceSelected]).prop('selected', true);
        $('.shipment-summary-auth').removeClass('d-none');
        $('.shipping-address-block').removeClass('d-block').addClass('d-none');
        $('.btn-add-new, .btn-show-details, .edit-save-block').removeClass('d-none').css('display', 'inline-block');

        if ($cancelShippingButton.data('check') === 'add') {
          $('.shipment-selector-block .customer-checkout-label').attr('data-address-method', 'new');
          setTimeout(function () {
            $('.btn-add-new').focus();
          }, 500);
        } else {
          $('.shipment-selector-block .customer-checkout-label').attr('data-address-method', 'edit');
          setTimeout(function () {
            $('.btn-show-details').focus();
          }, 500);
        }

        $('.shipment-selector-block').removeClass('d-none');
        $('.save-address-shipping ~ .invalid-saved-address').addClass('d-none');

        _initialLoadAddressDisplay('cancel');

        _populateAddressFields();

        setTimeout(function () {
          $('.btn-show-details, .edit-save-block').focus();
        }, 200);
        addressHelpers.methods.updateVerifiedAttr();
      } else {
        $shippingForm.find('.shipping-address-block .form-input-custom').val('');
      }

      formHelpers.clearPreviousErrors('.shipping-section');
      var isAddressSuggestionEnabled = $('#isAddressSuggestionEnabled').val();

      if (isAddressSuggestionEnabled === 'true') {
        addressHelpers.methods.addLoqateField();
      }
    });
  },
  btnShowDetails: function btnShowDetails() {
    var defaultCountryFlag = $('#shipmentSelector-default option[data-phonee164]').data('country-code');
    $('.btn-show-details').on('click', function () {
      $(this).closest('.shipping-form').attr('data-address-mode', 'details');
      $('.shipping-address-block').removeClass('d-none');
      $('.shipment-summary-auth').addClass('d-none');
      $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'none');
      $('.save-address-shipping.edit').removeClass('d-none');
      $('.save-address-shipping.save').addClass('d-none');
      $('.shipment-selector-block .customer-checkout-label').removeAttr('data-check');
      $('.shipment-selector-block .customer-checkout-label').attr('data-check', 'edit');
      $('.shipment-selector-block .customer-checkout-label').attr('data-address-method', 'edit');

      _populateAddressFields();

      loqateAddressSuggestion.methods.addClassToCTA($('.save-address-shipping a'));
      loqateAddressSuggestion.methods.reIntialiseSuggestionModal();
      var isAddressSuggestionEnabled = $('#isAddressSuggestionEnabled').val();

      if (isAddressSuggestionEnabled === 'true') {
        addressHelpers.methods.removeLoqateField();
      }
    });
    $('.btn-add-new').on('click', function () {
      $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'none');
      $('.save-address-shipping.edit').addClass('d-none');
      $('.save-address-shipping.save').removeClass('d-none');
      $('.shipment-selector-block .customer-checkout-label').removeAttr('data-check');
      $('.shipment-selector-block .customer-checkout-label').attr('data-check', 'add');
      $('.shipment-selector-block .customer-checkout-label').attr('data-address-method', 'new');
      var isAddressSuggestionEnabled = $('#isAddressSuggestionEnabled').val();
      var isShippingSuggestEnabled = $('#isShippingSuggestEnabled').val();

      if (isAddressSuggestionEnabled === 'true' && isShippingSuggestEnabled === 'true') {
        addressHelpers.methods.addLoqateField();
      } else {
        addressHelpers.methods.removeLoqateField();
      }

      loqateAddressSuggestion.methods.addClassToCTA($('.save-address-shipping a'));
      $('input[name="isVerified"]').val('false');
      loqateAddressSuggestion.methods.reIntialiseSuggestionModal();
      $('.btn-save-shipping-address').attr('data-isverified', 'false');
      $('.js-address-suggestion').val('');
      phoneFormatter.methods.setCountryFlag($('.shippingPhoneNumber'), defaultCountryFlag);
    });
  },
  toggleMultiship: function toggleMultiship() {
    var baseObj = this;
    $('input[name="usingMultiShipping"]').on('change', function () {
      var url = $('.multi-shipping-checkbox-block form').attr('action');
      var usingMultiShip = this.checked;
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: {
          usingMultiShip: usingMultiShip
        },
        success: function success(response) {
          if (response.error) {
            window.location.href = response.redirectUrl;
          } else {
            $('body').trigger('checkout:updateCheckoutView', {
              order: response.order,
              customer: response.customer
            });

            if ($('#checkout-main').data('customer-type') === 'guest') {
              if (baseObj.methods && baseObj.methods.clearShippingForms) {
                baseObj.methods.clearShippingForms(response.order);
              } else {
                clearShippingForms(response.order);
              }
            } else {
              response.order.shipping.forEach(function (shipping) {
                $('input[value=' + DOMpurify.sanitize(shipping.UUID) + ']').each(function (formIndex, el) {
                  var form = el.form;
                  if (!form) return;
                  $(form).attr('data-address-mode', 'edit');
                  var addressSelectorDropDown = $(form).find('.addressSelector option[value="ab_' + shipping.matchingAddressId + '"]');
                  $(addressSelectorDropDown).prop('selected', true);
                  $('input[name$=_isGift]', form).prop('checked', false);
                  $('textarea[name$=_giftMessage]', form).val('');
                  $(form).find('.gift-message').addClass('d-none');
                });
              });
            }

            if (usingMultiShip) {
              $('body').trigger('shipping:selectMultiShipping', {
                data: response
              });
            } else {
              $('body').trigger('shipping:selectSingleShipping', {
                data: response
              });
            }
          }

          $.spinner().stop();
        },
        error: function error() {
          $.spinner().stop();
        }
      });
    });
  },
  selectSingleShipping: function selectSingleShipping() {
    $('body').on('shipping:selectSingleShipping', function () {
      $('.single-shipping .shipping-address').removeClass('d-none');
    });
  },
  initialLoadAddressDisplay: function initialLoadAddressDisplay() {
    _initialLoadAddressDisplay('init');
  },
  initShippingPhoneFormatting: function initShippingPhoneFormatting() {
    var currentCountry = $('.shippingCountry').val();
    var $input = $('.js-phone.shippingPhoneNumber');
    phoneFormatter.methods.initialIntlTel($input, currentCountry);
  },
  populateAddressFields: function populateAddressFields() {
    // if ($('#checkout-main').data('customer-type') === 'guest' || $('.single-shipping .addressSelector option').length === 0) {
    //     $('.shipping-method-list input').prop('checked', false);
    //     $('.shipping-method-list').empty();
    // }
    var pisOrVgc = $('#pisOrVgc').val();

    if (pisOrVgc === 'false' && $('#shipmentSelector-default option').val() !== 'new') {
      _populateAddressFields();
    }
  },
  selectSingleShipAddress: function selectSingleShipAddress() {
    $('.single-shipping .addressSelector').on('change', function () {
      var form = $(this).parents('form')[0];
      var selectedOption = $('option:selected', this);
      var attrs = selectedOption.data();
      var shipmentUUID = selectedOption[0].value;
      var selectedShippingAddId = selectedOption[0].dataset.addressid;
      loqateAddressSuggestion.methods.addClassToCTA($('.submit-shipping'));

      if (shipmentUUID === 'new') {
        selectedShippingAddId = 'null';
      }

      $('.shipping-address-id').attr('value', selectedShippingAddId);
      var originalUUID = $('input[name=shipmentUUID]', form).val();
      var element;
      Object.keys(attrs).forEach(function (attr) {
        element = attr === 'countryCode' ? 'country' : attr;
        $('[name$=' + element + ']', form).val(attrs[attr]);
        $('[name$=' + element + ']', form).attr('value', attrs[attr]);
      });
      formHelpers.clearPreviousErrors('.shipping-section');

      _initialLoadAddressDisplay(shipmentUUID);

      $('.save-address-shipping ~ .invalid-saved-address').addClass('d-none');
      var $shipmentAddressOption = $('#shipmentSelector-default option:selected');
      $('.submit-shipping').attr('data-isverified', $shipmentAddressOption.data('isverified'));
      phoneFormatter.methods.setPhoneCountry($('.shippingPhoneNumber'), $shipmentAddressOption.data('phonee164'));

      if (shipmentUUID === 'new') {
        $(form).attr('data-address-mode', 'new');
        $(form).find('.shipping-address-block').removeClass('d-none');
      } else if (shipmentUUID === originalUUID) {
        $(form).attr('data-address-mode', 'shipment');
        $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'inline-block');
      } else if (shipmentUUID.indexOf('ab_') === 0) {
        $(form).attr('data-address-mode', 'customer');
        $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'inline-block');
        $('.edit-save-block').removeClass('d-none');
        $('.shipping-address-block').removeClass('d-block').addClass('d-none');
      } else {
        $(form).attr('data-address-mode', 'edit');
        $('.btn-add-new, .btn-show-details, .edit-save-block').css('display', 'inline-block');
      }

      $('.shipment-summary-change-block').removeClass('d-none');
    });
  },
  updateShippingList: function updateShippingList() {
    var baseObj = this;
    $('select[name$="shippingAddress_addressFields_states_stateCode"], .single-shipping .addressSelector').on('change', function (e) {
      if (baseObj.methods && baseObj.methods.updateShippingMethodList) {
        baseObj.methods.updateShippingMethodList($(e.currentTarget.form));
      } else {
        updateShippingMethodList($(e.currentTarget.form));
      }
    });
  },
  addressTooLong: function addressTooLong() {
    $(document).on('blur', '.js-loqate-addressOne', function () {
      customClientSideValidation.addressTooLong($(this));
    });
    $(document).on('blur', '.js-loqate-addressTwo', function () {
      customClientSideValidation.addressTooLong($(this));
    });
  },
  updateShippingMethodsOnAddressChange: function updateShippingMethodsOnAddressChange() {
    $(document).on('change', '.update-shipping-method-js', function (e) {
      $(this).trigger('invalid', this.validity);

      if (!$('.update-shipping-method-js').hasClass('is-invalid')) {
        updateShippingMethodList($(e.currentTarget.form));
      }
    });
  },
  invalidSavedAddress: function invalidSavedAddress() {
    $('.submit-shipping').on('click', function () {
      if (($('.shipping-form').find('.form-control').hasClass('is-invalid') || $('#smRestrictedDiv:visible').hasClass('js-no-shipping-methods')) && !$('.shipping-address-block').css('display') === 'none') {
        var $errorElm = $('.save-address-shipping ~ .invalid-saved-address').removeClass('d-none');
        scrollAnimate($errorElm);
      } else {
        var isOnlyPIS = $('#pisOrVgc').val();

        if (!isOnlyPIS) {
          $('.js-address-suggestion').removeAttr('required');
          $('.js-address-suggestion').removeAttr('aria-required');
          $('.js-address-suggestion').removeAttr('aria-invalid');
          $('.js-address-suggestion').removeClass('is-invalid');
          $('.js-loqate-address-block .form-group').removeClass('required').removeClass('is-invalid');
          $('.js-loqate-address-block').addClass('d-none');
        }
      }
    });
  },
  updateDataAddressMode: function updateDataAddressMode() {
    $('body').on('shipping:updateDataAddressMode', function (e, data) {
      $(data.form).attr('data-address-mode', data.mode);
    });
  },
  isLoqateVerificationEnable: function isLoqateVerificationEnable() {
    if ($('button.submit-shipping').is(':visible')) {
      loqateAddressSuggestion.methods.addClassToCTA($('button.submit-shipping'));
    }
  },
  invalidFirstAndLastName: function invalidFirstAndLastName() {
    _invalidFirstAndLastName();
  },
  isGift: function isGift() {
    $('.gift-receipt-row .gift').on('change', function (e) {
      e.preventDefault();

      if (this.checked) {
        $(this).prop('checked', true);
        $(this).attr('value', true);
      } else {
        $(this).prop('checked', false);
        $(this).attr('value', false);
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/summary.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/summary.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * Renders Bonus product in order summary sidebar
 * @param {Object} item - line item
 * @return {jQuery} - Bonus line item jQuery Object
 */


function bonusProductCard(item) {
  var bonusItemAttr;
  var bonusItemName = '<span>' + item.productName + '</span>';
  var bonusItemPrice = '<div class="gwp-cart-price text-uppercase mb-1">FREE</div>';
  var bonusItemImg = '<img class="product-image" src="' + item.images.base[0].url + '?$ProductThumbnail$" alt="' + item.images.base[0].alt + '" />';
  var $bonusItem = $('.secondary-checkout .product-line-item').first().clone();
  var $gwpPrice = $bonusItem.find('.gwp-cart-price');

  if ($gwpPrice.length) {
    $gwpPrice.remove();
  }

  $bonusItem.attr('data-product-line-item', item.UUID);
  $bonusItem.find('.quantity-form').after(bonusItemPrice);
  $bonusItem.find('.item-image').html(bonusItemImg);
  $bonusItem.find('.line-item-name').html(bonusItemName);
  $bonusItem.find('.quantity-form span').text('Qty: ' + item.quantity);
  $bonusItem.find('.line-item-unit-price, .line-item-total-price, .customizedPrdInfo').remove();
  $bonusItem.find('.line-item-attributes').remove();

  if (item.variationAttributes.length) {
    item.variationAttributes.forEach(function (attr) {
      bonusItemAttr = '<p class="line-item-attributes">' + attr.displayName + ': ' + attr.displayValue + '</p>';
      $bonusItem.find('.variation').prepend(bonusItemAttr);
    });
  }

  return $bonusItem;
}
/**
 * re-renders the order totals and the number of items in the Ceheckout
 * @param {Object} data - AJAX response from the server
 */


function updateCheckoutTotals(data) {
  var couponBlock = '';

  if (data.totals.couponDiscountsTotal && data.totals.couponDiscountsTotal.value && data.totals.couponDiscountsTotal.value < 0) {
    $('.order-coupon-total').empty().append(DOMpurify.sanitize(data.totals.couponDiscountsTotal.formatted));
    $('.order-coupon-total-checkout').empty().append(DOMpurify.sanitize(data.totals.couponDiscountsTotal.formatted));
  } else {
    DOMpurify.sanitize($('.order-coupon-total').empty().append('--'));
    $('.order-coupon-total-checkout').empty().append('--');
  }

  data.totals.discounts.forEach(function (couponval) {
    var code;
    var uuid;
    var promoActionUrl = data.actionUrls.removeCouponLineItem;

    if (couponval.applied) {
      code = couponval.couponCode;
      uuid = couponval.UUID;
      couponBlock += '<div class="coupon-price-adjustment coupon-uuid-' + uuid + '" data-uuid="' + uuid + '"><div class="coupon-code text-uppercase">' + couponval.couponCode + '<button data-uuid="' + uuid + '" data-code="' + code + '" data-action="' + promoActionUrl + '"class="float-right pr-0 bg-transparent border-0 delete-coupon-confirmation-btn"><span aria-hidden="true">×</span></button></div></div>';
      $('.appliedcode').html(DOMpurify.sanitize(couponBlock));
    }
  });
  data.items.items.forEach(function (item) {
    if (data.totals.orderLevelDiscountTotal.value > 0) {
      $('.coupons-and-promos').empty().append(DOMpurify.sanitize(data.totals.discountsHtml));
    }

    if (item.renderedPromotions) {
      $('.item-' + item.UUID).empty().append(DOMpurify.sanitize(item.renderedPromotions));
    } else {
      $('.item-' + item.UUID).empty();
    }

    $('.uuid-' + item.UUID + ' .unit-price').empty().append(item.renderedPrice);
    $('.line-item-price-' + item.UUID + ' .unit-price').empty().append(DOMpurify.sanitize(item.priceTotal.renderedPrice));
    $('.item-total-' + item.UUID).empty().append(item.priceTotal.renderedPrice);
  });

  if (data.totals.klarnaTotal) {
    $('klarna-placement').attr('data-purchase-amount', DOMpurify.sanitize(data.totals.klarnaTotal));
    window.KlarnaOnsiteService = window.KlarnaOnsiteService || [];
    window.KlarnaOnsiteService.push({
      eventName: 'refresh-placements'
    });
  }

  if ($('.gift-payment-methods').find('.applied-gift-header').length > 0) {
    // giftcard calculations
    if (data.totals.renderedPaymentInstruments === null) {
      $('.gift-payment-methods').empty();
      $('.payment-form .card-body').find('.payment-section').removeClass('d-none');
      $('.button-review').addClass('d-none');
    } else {
      $('.gift-payment-methods').empty().append(DOMpurify.sanitize(data.totals.renderedPaymentInstruments));
    }
  }
  /*
      afterPay calculation after the cart-updation
  */


  var afterPayPlacementLength = $('.afterpay-messaging afterpay-placement').length;

  if (data.isCartAfterpayEligible) {
    if (afterPayPlacementLength > 0) {
      if (data.totals && data.totals.grandTotal) {
        // updates afterPay amount
        if ($('.afterpay-messaging afterpay-placement.d-none').length > 0) {
          // unhides afterPay payment
          $('.afterpay-messaging afterpay-placement, .afterpay-messaging').removeClass('d-none');
        }

        $('.afterpay-messaging afterpay-placement').attr('data-amount', DOMpurify.sanitize(data.totals.grandTotal.value || data.totals.grandTotal));
      }
    } else {
      $('body').find('.afterpay-messaging').append(DOMpurify.sanitize(data.renderedTemplate)); // renders afterPay when it is eligible after updating the cart
    }
  } else if (afterPayPlacementLength > 0) {
    // hide afterPay payment method when it is not applicable for updated cart
    $('.afterpay-messaging afterpay-placement, .afterpay-messaging').addClass('d-none');
  }
}
/**
 * updates the totals summary
 * @param {Array} totals - the totals data
 */


function updateTotals(totals) {
  $('.shipping-total-cost').html(totals.ecomShipmentCost);
  $('.pickup-instore-cost').empty().append(totals.storeShipmentCost);
  $('.sub-total').text(totals.subTotal);
  $('.grand-total-sum').html(totals.grandTotal.formatted);
  $('.total-cart-amount p').text(totals.grandTotal.formatted);
  $('.coupons-and-promos').empty().append(DOMpurify.sanitize(totals.discountsHtml));

  if (!totals.taxCalculated) {
    $('.tax-total').html('--');
    $('.estimated-tax').removeClass('d-none');
    $('.calculated-tax').addClass('d-none');
  } else if (totals.totalTax.length >= 0) {
    $('.tax-total').html(totals.totalTax);
    $('.estimated-tax').addClass('d-none');
    $('.calculated-tax').removeClass('d-none');
  }

  if (totals.orderLevelDiscountTotal.value > 0) {
    $('.order-discount').removeClass('hide-order-discount');
    $('.order-discount-total').text('- ' + totals.orderLevelDiscountTotal.formatted);
  } else {
    $('.order-discount').addClass('hide-order-discount');
  }

  if (totals.shippingLevelDiscountTotal.value > 0) {
    $('.shipping-discount').removeClass('hide-shipping-discount');
    $('.shipping-discount-total').text('- ' + totals.shippingLevelDiscountTotal.formatted);
  } else {
    $('.shipping-discount').addClass('hide-shipping-discount');
  }

  if (totals.deliveryFee && totals.deliveryFee.priceValue > 0) {
    $('.order-fee').removeClass('hide-fee-discount');
    $('.order-fee-label').text(totals.deliveryFee.text);
    $('.order-fee-total').text(totals.deliveryFee.price);
  } else {
    $('.order-fee').addClass('hide-fee-discount');
  }

  if (totals.discounts.length > 0) {
    $('.applied-promo-title').removeClass('d-none').addClass('d-block');
  } else {
    $('.applied-promo-title').removeClass('d-block').addClass('d-none');
  }

  if (totals.additionalTaxes) {
    if (totals.additionalTaxes.taxGSTHST || totals.additionalTaxes.taxPSTQST) {
      $('.sales-tax-item').addClass('d-none');
    }

    if (totals.additionalTaxes.taxGSTHST && totals.additionalTaxes.taxGSTHST.enabled && totals.additionalTaxes.taxGSTHST.price.value >= 0) {
      $('.taxGSTHST-cost').text(totals.additionalTaxes.taxGSTHST.price.formatted);
      $('.taxGSTHST-label').text(totals.additionalTaxes.taxGSTHST.label);
      $('.taxGSTHST-label').parent().parent().removeClass('hide-additional-taxes');
    } else {
      $('.taxGSTHST-label').parent().parent().addClass('hide-additional-taxes');
    }

    if (totals.additionalTaxes.taxPSTQST && totals.additionalTaxes.taxPSTQST.enabled && totals.additionalTaxes.taxPSTQST.price.value >= 0) {
      $('.taxPSTQST-cost').text(totals.additionalTaxes.taxPSTQST.price.formatted);
      $('.taxPSTQST-label').text(totals.additionalTaxes.taxPSTQST.label);
      $('.taxPSTQST-label').parent().parent().removeClass('hide-additional-taxes');
    } else {
      $('.taxPSTQST-label').parent().parent().addClass('hide-additional-taxes');
    }
  }
}
/**
 * updates the order product shipping summary for an order model
 * @param {Object} order - the order model
 */


function updateOrderProductSummaryInformation(order) {
  var $productSummary = $('<div />');
  var $giftWrapItem = $('.secondary-checkout .js-giftwrap-card');
  var $giftwrapCheckbox = $('.gift-wrap-checkbox:checked');
  var giftCardId;
  order.shipping.forEach(function (shipping) {
    shipping.productLineItems.items.forEach(function (lineItem) {
      var pli;

      if (!$('.cart-page').length && lineItem.isBonusProductLineItem) {
        pli = bonusProductCard(lineItem);
      } else {
        pli = $('.checkout-sidebar-section [data-product-line-item=' + lineItem.UUID + ']').first();
      }

      if (lineItem.is_gift_card) {
        giftCardId = lineItem.UUID;
      }

      $productSummary.append(pli);
    });
    var $shippingTextChange = $('.shipping-text-change');

    if (order.shipping && order.shipping.length && order.shipping[0].selectedShippingMethod) {
      $shippingTextChange.text(order.shipping[0].selectedShippingMethod.displayName + ' (' + order.noOfEcomItems + ')');
    } else {
      $shippingTextChange.html(order.resources.noOfEcomItems);
    }

    var address = shipping.shippingAddress || {};
    var selectedMethod = shipping.selectedShippingMethod;
    var nameLine = address.firstName ? address.firstName + ' ' : '';
    if (address.lastName) nameLine += address.lastName;
    var address1Line = address.address1;
    var address2Line = address.address2;
    var phoneLine = address.phone;
    var shippingCost = selectedMethod ? selectedMethod.shippingCost : '';
    var methodNameLine = selectedMethod ? selectedMethod.displayName : '';
    var methodArrivalTime = selectedMethod && selectedMethod.estimatedArrivalTime ? '( ' + selectedMethod.estimatedArrivalTime + ' )' : '';
    var tmpl = $('#pli-shipping-summary-template').clone();

    if (shipping.productLineItems.items && shipping.productLineItems.items.length > 1) {
      $('h5 > span').text(' - ' + shipping.productLineItems.items.length + ' ' + order.resources.items);
    } else {
      $('h5 > span').text('');
    }

    var stateRequiredAttr = $('#shippingState').attr('required');
    var isRequired = stateRequiredAttr !== undefined && stateRequiredAttr !== false;
    var stateExists = shipping.shippingAddress && shipping.shippingAddress.stateCode ? shipping.shippingAddress.stateCode : false;
    var stateBoolean = false;

    if (isRequired && stateExists || !isRequired) {
      stateBoolean = true;
    }

    var shippingForm = $('.multi-shipping input[name="shipmentUUID"][value="' + shipping.UUID + '"]').parent();

    if (shipping.shippingAddress && shipping.shippingAddress.firstName && shipping.shippingAddress.address1 && shipping.shippingAddress.city && stateBoolean && shipping.shippingAddress.countryCode && (shipping.shippingAddress.phone || shipping.productLineItems.items[0].fromStoreId)) {
      $('.ship-to-name', tmpl).text(nameLine);
      $('.ship-to-address1', tmpl).text(address1Line);
      $('.ship-to-address2', tmpl).text(address2Line);
      $('.ship-to-city', tmpl).text(address.city);

      if (address.stateCode) {
        $('.ship-to-st', tmpl).text(address.stateCode);
      }

      $('.ship-to-zip', tmpl).text(address.postalCode);
      $('.ship-to-phone', tmpl).text(phoneLine);

      if (!address2Line) {
        $('.ship-to-address2', tmpl).hide();
      }

      if (!phoneLine) {
        $('.ship-to-phone', tmpl).hide();
      }

      shippingForm.find('.ship-to-message').text('');
    } else {
      shippingForm.find('.ship-to-message').text(order.resources.addressIncomplete);
    }

    if (shipping.isGift) {
      $('.gift-message-summary', tmpl).text(shipping.giftMessage);
    } else {
      $('.gift-summary', tmpl).addClass('d-none');
    } // checking h5 title shipping to or pickup


    var $shippingAddressLabel = $('.shipping-header-text', tmpl);
    $('body').trigger('shipping:updateAddressLabelText', {
      selectedShippingMethod: selectedMethod,
      resources: order.resources,
      shippingAddressLabel: $shippingAddressLabel
    });

    if (shipping.selectedShippingMethod) {
      $('.display-name', tmpl).text(methodNameLine);
      $('.arrival-time', tmpl).text(methodArrivalTime);
      $('.price', tmpl).text(shippingCost);
    }

    if (order.hasAppliedCoupons) {
      $('.checkout-promocode').removeClass('d-none');
      $('.checkout-applied-coupon').removeClass('d-none');
    } else {
      $('.checkout-promocode').addClass('d-none');
      $('.checkout-applied-coupon').addClass('d-none');
    }

    var $shippingSummary = $('<div class="multi-shipping d-none" data-shipment-summary="' + shipping.UUID + '" />');
    $shippingSummary.html(tmpl.html());
    $productSummary.append($shippingSummary);
  });
  $('.product-summary-block').html($productSummary.html()); // update product count for order summary and cart bag

  var orderSummaryCount = $('.order-summary-product-count');
  var miniCartCount = $('.minicart-quantity');
  var totalOrderQty = order.items.totalQuantity;

  if (orderSummaryCount.length && miniCartCount.length && (parseInt(orderSummaryCount.text(), 10) || parseInt(miniCartCount.text(), 10)) !== totalOrderQty) {
    var orderCountText = totalOrderQty === 1 ? ' item' : ' items';
    orderSummaryCount.text(totalOrderQty + orderCountText);
    miniCartCount.text(totalOrderQty);
  } // display giftwrap card in sidebar if applicable


  if ($giftwrapCheckbox.length) {
    var giftwrapMsg = $giftwrapCheckbox.closest('.product-content-block').find('.gift-wrap-message').attr('data-text-value');

    if (giftwrapMsg !== 'null') {
      $giftWrapItem.find('.js-giftwrap-msg').text(giftwrapMsg);
    }

    $giftWrapItem.find('.quantity-form span').text('Qty: ' + order.totals.giftwrapTotals.items || 0);
    $giftWrapItem.removeClass('d-none').detach();
  }

  $('.product-summary-block').append($giftWrapItem); // Reorder product cards in sidebar if giftcard is present

  if (giftCardId && order.items.items.length > 1) {
    var siblingProductId;
    var $siblingProduct;
    var $giftCardProduct = $('.secondary-checkout [data-product-line-item="' + giftCardId + '"]').detach();
    var giftCardIdx = order.items.items.findIndex(function (lineItem) {
      return lineItem.UUID === giftCardId;
    });

    if (giftCardIdx === 0) {
      siblingProductId = order.items.items[giftCardIdx + 1].UUID;
      $siblingProduct = $('.secondary-checkout [data-product-line-item="' + siblingProductId + '"]');
      $siblingProduct.before($giftCardProduct);
    } else if (giftCardIdx > 0) {
      siblingProductId = order.items.items[giftCardIdx - 1].UUID;
      $siblingProduct = $('.secondary-checkout [data-product-line-item="' + siblingProductId + '"]');
      $siblingProduct.after($giftCardProduct);
    }
  } // Also update the line item prices, as they might have been altered


  $('.grand-total-price').text(order.totals.subTotal);
  order.items.items.forEach(function (item) {
    if (item.priceTotal && item.priceTotal.renderedPrice) {
      var $itemPrice = $('.secondary-checkout [data-product-line-item="' + item.UUID + '"] .back-to-product-anchor-js');
      $itemPrice.html(item.priceTotal.renderedPrice);

      if (!item.priceTotal.nonAdjustedPrice && item.priceTotal.listPrice) {
        var $itemListPrice = $itemPrice.find('.strike-through span');
        $itemListPrice.first().text(item.priceTotal.listPrice);
        $itemListPrice.last().text(item.priceTotal.listPrice);
      } else if (item.priceTotal.nonAdjustedPrice) {
        var $itemAdjustedPrice = $itemPrice.find('.strike-through span');
        $itemAdjustedPrice.first().text(item.priceTotal.nonAdjustedPrice);
        $itemAdjustedPrice.last().text(item.priceTotal.nonAdjustedPrice);
      }

      $('.item-total-' + item.UUID).empty().append(item.priceTotal.renderedPrice);
    }
  });
}
/**
 * updates the order product shipping summary for an order model
 * @param {Object} data - ajax response
 */


function updateReviewSummary(data) {
  $('.review-summary .review-section').empty().append(DOMpurify.sanitize(data.renderedProductReview));
  $('.review-summary .review-header-visibility').addClass('d-none');
  $('.order-summary-review-section').empty();
  $('.secondary-checkout .checkout-sidebar-section').clone().appendTo('.order-summary-review-section');
  $('.secondary-checkout .review-mobile-bg-color').clone().appendTo('.order-summary-review-section');

  if ($('.gift-wrap-checkbox:checked').length) {
    var $checkoutReviewSection = $('.checkout-review-section');
    $checkoutReviewSection.find('.js-giftwrap-msg').text($('.orderSummary p.js-giftwrap-msg:first').text());
    $checkoutReviewSection.find('.js-giftwrap-card').removeClass('d-none');
  }
}

module.exports = {
  updateTotals: updateTotals,
  updateOrderProductSummaryInformation: updateOrderProductSummaryInformation,
  updateReviewSummary: updateReviewSummary,
  updateCheckoutTotals: updateCheckoutTotals
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/ada.js":
/*!************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/ada.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() < SCREENSIZE.TABLETMIN;

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");
/**
 * Function to remove tabindex from slider image
 */


function removeTabindex() {
  setTimeout(function () {
    $('.list-unstyled .large-images').removeAttr('tabindex');
  }, 1000);
}
/**
 * update the aria-label for the shipping methos radio buttons in checkout-shipping section
 */


function updateShippingRadioButtons() {
  var shippingInterval = setInterval(function () {
    if ($('.shipping-method-block').is(':visible')) {
      clearInterval(shippingInterval);
      $(document).find('.shipping-method-section').each(function () {
        var shippingCost = $(this).find('.shipping-method-pricing .shipping-cost') ? $(this).find('.shipping-method-pricing .shipping-cost').text() : '';
        var promotionCost = $(this).find('.shipping-method-pricing .promotion-cost') ? $(this).find('.shipping-method-pricing .promotion-cost').text() : '';
        var labelText = $(this).find('label .display-name').text() + ' ' + $(this).find('label .arrival-time').text() + ' ' + (promotionCost ? $(this).find('.shipping-method-pricing .shipping-costsr').text() : '') + shippingCost + ' ' + (promotionCost ? $(this).find('.shipping-method-pricing .promotion-costsr').text() : '') + promotionCost;
        $(this).find('input').attr('aria-label', labelText);
      });
    }
  }, 100);
}
/**
 * updatePricingValues - Update the sr-only spans with price values
 */
// function updatePricingValues() {
//     $(document).find('.default-price').each(function () {
//         if ($(this).find('.list').length) {
//             $(this).find('.list .sr-only').text($(this).find('.list').text());
//         }
//         $(this).find('.sales .sr-only').text($(this).find('.sales').text());
//     });
// }


module.exports = function () {
  $(document).ready(function () {
    updateShippingRadioButtons();
    $(document).find('.submit-customer, .submit-customer-login').on('click', function () {
      updateShippingRadioButtons();
    });

    if (isMobile) {
      removeTabindex();
      $(document).on('click', '.image-detail-container .slick-arrow, .image-detail-container .js-thumbnail-btn', function () {
        removeTabindex();
      });
      $(document).find('.login-information-block .info-icon, .checkout-registration .info-icon, .account-information-block .info-icon').on('click', function () {
        var tooltipSelector = '#' + $(this).attr('aria-describedby');
        $(tooltipSelector).attr('role', 'tooltip');
        $(tooltipSelector).attr('aria-live', 'assertive');
      });

      if ($('#mobile-accordion').is(':visible')) {
        $('.mobile-order-summary').removeClass('order-summary-sticky-js');
        $('#mobile-accordion').addClass('collapsed');
        $('.js-mobile-summary').find('#collapaseOrderConfirmation').removeClass('show');
      }
    }

    $(document).find('form input').on('focus', function () {
      $(this).removeAttr('aria-invalid');
    });
    $(document).find('.shipping-form input[type="text"], .shipping-form input[type="tel"]').on('focus', function () {
      $(this).attr('aria-label', $(this).parents('.form-group').find('label').text().trim() + ' ' + $(this).siblings('.invalid-feedback').text().trim());
    });
    $(document).find('#login-form #login-form-email, #login-form #login-form-password').on('focus', function () {
      $(this).attr('aria-label' + $(this).siblings('.invalid-feedback').text().trim());
    });
  });
  $(document).on('mouseenter', 'a, button, input, img', function (ele) {
    var focusTags = ele.currentTarget;
    focusTags.classList.add('mouseFocusUnActive');
  });
  $(document).on('keydown', 'a, button, input, img', function () {
    $('a, button, input, img').removeClass('mouseFocusUnActive');
  }); // Find the last element which is clicked to open the modal window
  // Need to have this 'modal-js' class to the modal element which will trigger the modal

  $(document).on('click', '.modal-js', function () {
    $('.modal-js').removeClass('refocus');
    $(this).addClass('refocus');
  });
  $(document).on('shown.bs.modal', '.modal', function () {
    $('#footercontent').attr('aria-hidden', true);
    $('#footercontent').attr('tabindex', '-1');
    $(this).removeAttr('role');
    $(this).find('.close').removeClass('mouseFocusUnActive');
    $(this).find('.close').focus();
  });
  $(document).find('.product-item-edit .edit').on('click', function () {
    var $editLink = $(this);
    $(document).on('hidden.bs.modal', '.modal', function () {
      $editLink.focus();
    });
  });
  $(document).on('hidden.bs.modal', '.modal', function () {
    $('#footercontent').attr('aria-hidden', false);
    $('#footercontent').removeAttr('tabindex');

    if ($('#deletePaymentModal').length > 0) {
      $('.payment-main-container').attr('aria-hidden', false);
    }

    $('.modal-js.refocus').focus();

    if ($(this).hasClass('instore-pickup-modal')) {
      setTimeout(function () {
        $('.btn-get-in-store-inventory').focus();
      }, 100);
    }
  });
  $('body').on('addressDeleted', function (e, toastObject) {
    $(document).on('hidden.bs.modal', '.modal', function () {
      clientSideUtil.floatToastMessage(toastObject.toastMessage, toastObject.toastMessageDisplayTime, toastObject.isSuccess);
    });
  });
  $('.afterpay-messaging').on('click', function () {
    $('.webchatStartButtonContainer').css('z-index', 0);
  });
  $('.skip[href="#maincontent"]').click(function () {
    setTimeout(function () {
      $('#maincontent').attr('tabIndex', -1).focus();
    }, 500);
  });
  $('.skip[href="#footercontent"]').click(function () {
    $('.store-locator-text').addClass('avoid-blue-border');
    setTimeout(function () {
      $('.store-locator-text').focus();
    }, 500);
  });
  $('body').on('keydown', '#inStoreInventoryModal', function (e) {
    var focusParams = {};

    if ($('#inStoreInventoryModal .results-card .card-body').length !== 0) {
      focusParams = {
        event: e,
        containerSelector: '#inStoreInventoryModal',
        firstElementSelector: '.close',
        lastElementSelector: '.toggle-store-details:last:visible',
        nextToLastElementSelector: '.btn-storelocator-search:visible'
      };
    } else {
      focusParams = {
        event: e,
        containerSelector: '#inStoreInventoryModal',
        firstElementSelector: '.close',
        lastElementSelector: '.btn-storelocator-search:visible',
        nextToLastElementSelector: '.btn-storelocator-search:visible'
      };
    }

    focusHelper.setTabNextFocus(focusParams);
  });
  $('body').on('click', '.toggle-store-details', function () {
    if ($(this).attr('aria-expanded') !== 'true') {
      var target = $(this).attr('href');
      setTimeout(function () {
        $(target).find('button, a, input, select, textarea, [tabindex]:not([tabindex="-1"])').first().focus();
      }, 500);
    }
  });
};
/**
 * ADA fix - Function to mark labels with hyphen as 'to'
 * @param {Object} $element - the DOM element whose aria-labels needs to be rewritten
 */


function fixAriaLabels($element) {
  $element.each(function () {
    var label = $(this).attr('aria-label').replace(/-/g, 'to');
    $(this).attr('aria-label', label);
  });
}

module.exports.fixAriaLabels = fixAriaLabels;

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/capriCountrySelector.js":
/*!*****************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/capriCountrySelector.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js"); // {boolean} isDesktop - Desktop check condition
// {interger} mobileULBuildCount - UL build for mobile view check condition
// {interger} desktopModalBuildCount - Modal build for desktop view check condition


var isDesktop = $(window).width() > SCREENSIZE.DESKTOPMIN; // window.width > 1024

var mobileULBuildCount = 0;
var desktopModalBuildCount = 0;

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js"); // Resize device


$(window).on('resize', function () {
  isDesktop = $(window).width() > SCREENSIZE.DESKTOPMIN; // window.width > 1024
});
/**
* Create cookie for cookie language
* @param {string} locale - locale id
* @param {string} isConfirmationModal - isConfirmationModal
*/

function createCookieLanguage(locale, isConfirmationModal) {
  var localeID = locale.replace('-', '_');
  var actionURL = $('.onchangecountry').data('action-url');

  if (locale && actionURL) {
    $.ajax({
      url: actionURL,
      type: 'get',
      dataType: 'json',
      data: {
        locale: localeID,
        isConfirmationModal: isConfirmationModal
      },
      success: function success() {// nothing needs to be done
      }
    });
  }
}
/**
* Notification/Confirmation popup
*/


function isConfirmationModalShown() {
  $('.multi-language-list-item a').click(function (e) {
    var countrySelector = $('.country-selector-body').find('.lanuage-name.selected').closest('.country-label-name');
    var $url = $(this).attr('href');
    var $currentSite = $('.country-selector-body').data('hostname');
    var $selectedCountry = $(this).hasClass('selected-country');
    var locale = $(this).data('locale-id');
    createCookieLanguage(locale, false);

    if (countrySelector.data('site-id') !== $(this).closest('.country-label-name').data('site-id')) {
      if ($url.indexOf($currentSite) > -1 && $selectedCountry) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    } else {
      $(this).removeAttr('data-target');
      window.location.href = $url;
    }
  });
}
/**
* parsing an html
* @param  {string} html -pageHtml
* @returns {string} appended countryselector popup modal
*/


function parseHtml(html) {
  var $html = $('<div>').append($.parseHTML(html));
  var body = $html.find('.country-selector-body');
  var footer = $html.find('.modal-footer').children();
  return {
    body: body,
    footer: footer
  };
}
/**
* struture of popup modal
*/


function getModalHtmlElement() {
  var htmlString = '<!-- Modal -->' + '<div class="modal fade show" id="country-selector" tabindex="-1" role="dialog" aria-labelledby="selectacountry">' + '<span class="enter-message sr-only" ></span>' + '<div class="modal-dialog country-selector-dialog">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<div class="modal-header border-0">' + '    <button type="button" class="close pull-right m-0 p-0" data-dismiss="modal" aria-label="Close">' + '        <span class="sr-only">close</span>' + '    </button>' + '</div>' + '<div class="modal-body"></div>' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
*
* @param {string} selectedValueUrl passing an country url
*/


function fillModalElement(selectedValueUrl) {
  var $countrySelector = $('#country-selector');
  var $presentCountryCode = $('.country-selector').data('current-country');
  var $presentLocale = $('.country-selector').data('current-locale');
  $countrySelector.find('.modal-body').spinner().start();
  $.ajax({
    url: selectedValueUrl,
    type: 'get',
    dataType: 'json',
    success: function success(data) {
      var parsedHtml = parseHtml(data.renderedTemplate);
      $countrySelector.find('.modal-body').empty().html(parsedHtml.body);
      $countrySelector.find('.country-label-name').each(function () {
        if ($presentCountryCode === $(this).data('country-code') && $presentLocale === $(this).find('.selected-language').data('locale')) {
          $(this).find('.selected-language').addClass('selected-country');
        }
      });
      $countrySelector.modal('show');
      $('.country-selector-body').attr('data-isShowConfirmationpopup', DOMpurify.sanitize(data.isShowConfirmationpopup)).attr('data-hostName', DOMpurify.sanitize(data.hostName));
      $.spinner().stop();
      isConfirmationModalShown();
      var confirmationModal = $countrySelector.find('#confirmationModal').clone();
      $('body').append(confirmationModal);
      $countrySelector.find('#confirmationModal').detach();
      $('.main-menu').find('#confirmationModal').detach();
    },
    error: function error() {
      $.spinner().stop();
    }
  });
}
/**
 *
 * @param {string} currentValue current element
 */


function closeMenuHamburger(currentValue) {
  var $closeMenu = $('<li class="nav-menu"></li>');
  $closeMenu.append($('.close-menu').first().clone());
  $(currentValue).attr('aria-expanded', 'true');
  $(currentValue).closest('.mobile-country-selector-container').children('.dropdown-menu').prepend($closeMenu).attr('aria-hidden', 'false');
}
/**
*
* @param {string} currentValue current element
* @param {string} selectedValueUrl passing an country url
*/


function fillHamburgerMenu(currentValue, selectedValueUrl) {
  $.ajax({
    url: selectedValueUrl,
    type: 'get',
    dataType: 'json',
    success: function success(data) {
      $(currentValue).closest('.mobile-country-selector-container').append(DOMpurify.sanitize(data.renderedTemplate));
      closeMenuHamburger(currentValue);
      $('.country-selector-body').attr('data-isShowConfirmationpopup', DOMpurify.sanitize(data.isShowConfirmationpopup)).attr('data-hostName', DOMpurify.sanitize(data.hostName));
      isConfirmationModalShown();
      $(currentValue).closest('.mobile-country-selector-container').addClass('show');
      var $countrySelector = $('.country-selector-body');
      var $presentCountryCode = $('.country-selector').data('current-country');
      $countrySelector.find('.country-label-name').each(function () {
        if ($presentCountryCode === $(this).data('country-code')) {
          $(this).addClass('selected-country');
        }
      });
    }
  });
}
/**
*country selector popup
*/


function showCountrySelectorPopup() {
  $('.js-country-selector').on('click', function (e) {
    e.preventDefault();
    var $this = $(this);
    var $selectedValueUrl = $this.attr('data-href');
    $this.attr('aria-expanded', 'true');

    if (isDesktop) {
      if (desktopModalBuildCount === 0) {
        getModalHtmlElement();
        fillModalElement($selectedValueUrl);
        desktopModalBuildCount = 1;
      } else {
        $('#country-selector').modal('show'); // When user reopen close all filter classes

        $('.country-search-text-box').val('');
        var $countrySelectorModal = $('.country-selector-body');
        $countrySelectorModal.find('.country-search-text-box').removeClass('d-none');
        $countrySelectorModal.find('.region-name, .flag-icon').removeClass('d-none');
        $countrySelectorModal.find('.country-selector-data').removeClass('flex-column');
        $countrySelectorModal.find('.country-label-name, .country-selector-list').removeClass('filter').removeClass('d-none');
        $countrySelectorModal.find('.search-result-container').addClass('d-none');
        $countrySelectorModal.find('.no-search-result-country').addClass('d-none');
      }

      if ($(this).parent('div').hasClass('modal-footer')) {
        $('#countryRedirectModal').modal('hide');
      }
    } else if ($('.mobile-country-selector-container').find('.country-selector-body').length === 0) {
      var regionsSelector = $(this).parents('.mobile-country-selector-container').children('.country-selector-body');

      if ($(regionsSelector).children('li').length <= 5) {
        $('.menu-group').addClass('overflow-hidden');
        $('.menu-group').scrollTop(0);
      }

      if ($(this).parent('div').hasClass('modal-footer')) {
        // This is to open the country modal when clicked from redirect modal
        $('.navbar-toggler').trigger('click');
        $('.mobile-country-selector .js-country-selector').trigger('click');
        $('#countryRedirectModal').modal('hide');
      }

      fillHamburgerMenu($this, $selectedValueUrl);
    } else {
      if ($(this).parent('div').hasClass('modal-footer')) {
        // This is to open the country modal when clicked from redirect modal
        $('.navbar-toggler').trigger('click');
        $('.mobile-country-selector .js-country-selector').trigger('click');
        $('#countryRedirectModal').modal('hide');
      }

      $('.mobile-country-selector-container').addClass('show');
      $('.menu-group').scrollTop(0);
      $('.menu-group').addClass('overflow-hidden');
      $('.country-selector-body').addClass('active-dropdown');
      closeMenuHamburger($this);
    }

    $('.navbar').scrollTop(0);
    $('.main-menu').attr('aria-hidden', 'false');
    $('.main-menu').siblings().attr('aria-hidden', 'true');
    $('header').siblings().attr('aria-hidden', 'true');
  });
}
/**
*Different languages for country
*/


function showLanguages() {
  $(document).on('mouseenter', '.country-name', function () {
    if (isDesktop) {
      $(this).find('.country-label').addClass('d-none');
      $(this).closest('.country-label-name').find('.language-container').removeClass('d-none');
    }
  }).on('mouseleave', '.country-name', function () {
    if (isDesktop) {
      $(this).find('.country-label').removeClass('d-none');
      $(this).closest('.country-label-name').find('.language-container').addClass('d-none');
    }
  });
}
/**
*Desktop filter for country
*@param {string} currentCountryName Current country name
*@param {string} value Current search value
*/


function desktopFilterCountry(currentCountryName, value) {
  var $countrySelectorModal = $('.country-selector-body');
  var $countryColumn = $countrySelectorModal.find('.country-selector-data');
  var $countryNameIcon = $countrySelectorModal.find('.region-name, .flag-icon');
  var $countryLabelList = $countrySelectorModal.find('.country-label-name, .country-selector-list');
  var $countryContainer = $countrySelectorModal.find('.search-result-container');
  var $noSearchResult = $countrySelectorModal.find('.no-search-result-country');

  if ($(currentCountryName).find('.country-label').text().toLowerCase().trim().indexOf(value) === -1) {
    $(currentCountryName).addClass('d-none');
    $countryColumn.addClass('flex-column');
    $countryNameIcon.addClass('d-none');
    $countryLabelList.addClass('filter');
    $countryContainer.removeClass('d-none');
    $noSearchResult.addClass('d-none');
  } else {
    $(currentCountryName).removeClass('d-none');
  }
}
/**
*Mobile filter for country
*@param {string} value Current search value
*/


function mobileFilterCountry(value) {
  var $countrySelectorModal = $('.country-selector-body');
  var $countryContainer = $countrySelectorModal.find('.search-result-container');

  if (mobileULBuildCount === 0) {
    $('.mobile-country-selector-container .country-selector-data .country-label-name').each(function () {
      var ul = $('<ul class="list-unstyled d-none"></ul>');
      var link = $(this).clone();
      ul.append(link);
      $('.country-selector-filter').append(ul);
    });
  }

  $('.country-selector-header').not('.search-label').addClass('d-none');
  $('.search-label').removeClass('d-none');
  $('.country-selector-filter').removeClass('d-none');
  $('.country-selector-body').addClass('active-dropdown');

  if (!$('.country-selector-list').not('.country-selector-filter').hasClass('d-none') && !$('.country-selector-body').hasClass('inner-search-util')) {
    $('.country-selector-list').addClass('d-none');
  }

  $('.country-selector-filter .country-label-name').each(function () {
    if ($(this).attr('name').toLowerCase().trim().indexOf(value) !== -1) {
      $(this).closest('ul').removeClass('d-none');
    } else {
      $(this).closest('ul').addClass('d-none');
    }
  });
  mobileULBuildCount = 1;
  $countryContainer.removeClass('d-none');
}
/**
*No search result for country
*/


function noSearchResult() {
  $('.no-search-result-country').removeClass('d-none');
  $('.search-result-container').addClass('d-none');
}
/**
*No search result for country
*@param {string} searchCount search match count
*@param {string} value Current search value
*/


function searchResultCount(searchCount, value) {
  var $searchResultValue = $('.search-result-text');
  $searchResultValue.find('.count').html(searchCount);
  $searchResultValue.find('.search-term').html(value);
  $('.no-search-result-country').addClass('d-none');
  $('.search-result-container').removeClass('d-none');
}
/**
* Hide container country element when we don't have any key on search field
*/


function hideContainerForCountrySearch() {
  var $countrySelectorModal = $('.country-selector-body');
  var $mobileCountrySelector = $('.mobile-country-selector-container');
  $countrySelectorModal.find('.country-selector-data').removeClass('flex-column');
  $countrySelectorModal.find('.region-name, .flag-icon, .country-label-name').removeClass('d-none');
  $countrySelectorModal.find('.country-label-name, .country-selector-list').removeClass('filter');
  $countrySelectorModal.find('.search-result-container').addClass('d-none');
  $mobileCountrySelector.find('.country-selector-list').removeClass('d-none');
  $mobileCountrySelector.find('.country-selector-filter').addClass('d-none');
  $mobileCountrySelector.find('.search-result-container').addClass('d-none');
  $mobileCountrySelector.find('.no-search-result-country').addClass('d-none');
  $mobileCountrySelector.find('.country-selector-header').not('.search-label').removeClass('d-none');
  $mobileCountrySelector.find('.search-label').addClass('d-none');
  $mobileCountrySelector.find('.country-selector-body').removeClass('inner-search-util');
}
/**
*Filter for country
*/


function filterCountry() {
  $(document).on('keyup', '.country-search-text-box', function () {
    var $thisVal = $(this);
    var $value = $thisVal.val().toLowerCase().trim();

    if ($thisVal.val().length > 0) {
      var $searchCount;

      if (isDesktop) {
        $('.country-selector-data .country-label-name').each(function () {
          desktopFilterCountry($(this), $value);
        });
        $searchCount = $('.country-selector-dialog .country-label-name').not('.d-none').length;
      } else {
        if ($thisVal.closest('.dropdown-menu').hasClass('regions-dropdown')) {
          $thisVal.closest('.country-selector-body').addClass('inner-search-util');
        }

        mobileFilterCountry($value);
        $searchCount = $('.country-selector-filter >ul').not('.d-none').length;
      }

      if ($searchCount > 0) {
        searchResultCount($searchCount, $value);
      } else {
        noSearchResult();
      }
    } else {
      hideContainerForCountrySearch();
    }
  });
}
/**
*Dropdown for search term of the country
*/


function dropdownSearch() {
  $(document).on('click', '.country-selector-filter .mobile-country-selector', function () {
    var $closeMenu = $('<li class="nav-menu"></li>');
    $closeMenu.append($('.close-menu').first().clone());
    $(this).closest('.dropdown').find('.dropdown-menu').prepend($closeMenu);
    $(this).closest('.dropdown').addClass('show');
    $(this).attr('aria-expanded', 'true');

    if (!isDesktop) {
      var countrySelectorConatiner = $(this).closest('.country-selector-body');
      $(countrySelectorConatiner).find('#confirmationModal').detach();
    }
  });
}
/**
*confirmation modal event
*/


function confirmationModalEvent() {
  $(document).on('show.bs.modal', '#confirmationModal', function (e) {
    var $relatedTarget = e.relatedTarget;
    var $url = $($relatedTarget).attr('href');
    var $localeId = $($relatedTarget).data('locale-id');
    var isShowConfirmationpopup = $($relatedTarget).closest('.country-selector-body').data('isshowconfirmationpopup');

    if (isShowConfirmationpopup) {
      $('#country-selector').modal('hide');
      var countryName = $('.js-country-selector').closest('.country-selector').data('current-country-name');
      $(this).find('.current-country-name').html(countryName);
      $(this).find('.continue-btn').attr('href', $url);

      if (isDesktop) {
        $(this).find('.continue-btn').data('locale-id', $localeId);
      }

      $(this).addClass('d-flex align-items-lg-end justify-content-center');
    }
  });
  $(document).on('shown.bs.modal', '#confirmationModal', function () {
    if ($('.modal-backdrop.show').length > 1) {
      $('.modal-backdrop:first').remove();
    }
  });
  $(document).on('hide.bs.modal', '#confirmationModal', function () {
    $(this).removeClass('d-flex align-items-lg-end justify-content-center');
  });
}
/**
* accessibility for enter event
*/


function keyboardAccessibility() {
  $(document).on('keydown', '.country-selector-list .country-label', function (e) {
    var key = e.which;

    if (key === 13) {
      // enter
      var currentContainer = $(this).closest('.country-label-name');

      if (currentContainer.find('li.multi-language-list-item').length > 1) {
        $(this).addClass('d-none');
        currentContainer.find('.language-container').removeClass('d-none');
        currentContainer.find('li.multi-language-list-item:first a').focus();
      } else {
        window.location.href = currentContainer.find('li.multi-language-list-item a').attr('href');
      }
    }
  });
  $(document).on('keyup', '.country-selector-list .country-label', function (e) {
    var key = e.which;

    if (key === 9) {
      // tab
      $('.country-label').removeClass('d-none');
      $('.language-container').addClass('d-none');
    }
  });
}

$('body').on('keydown', '#country-selector', function (e) {
  var focusParams = {
    event: e,
    containerSelector: '#country-selector',
    firstElementSelector: '.close',
    lastElementSelector: '.region-container:last-child .country-label-name:last-child .country-label'
  };
  focusHelper.setTabNextFocus(focusParams);
});
$(document).on('click', '.multi-language-list button', function (e) {
  var $url = $(this).data('href');
  var $currentSite = $('.country-selector-body').data('hostname');
  var $selectedCountry = $(this).hasClass('selected-country');
  var locale = $(this).data('locale-id');
  var isShowConfirmationpopup = $(this).closest('.country-selector-body').data('isshowconfirmationpopup');

  if (isShowConfirmationpopup) {
    $('.confirmationModal').find('.continue-btn').data('locale-id', locale);
  }

  createCookieLanguage(locale, false);

  if ($url.indexOf($currentSite) > -1 && $selectedCountry) {
    e.preventDefault();
    e.stopPropagation();
    e.stopImmediatePropagation();
  } else {
    window.location.href = $url;
  }
});
$(document).on('click', '.country-redirect', function () {
  var locale = $(this).data('locale-id');
  var isShowConfirmationpopup = $(this).closest('.country-selector-body').data('isshowconfirmationpopup');

  if (isShowConfirmationpopup) {
    $('.confirmationModal').find('.continue-btn').data('locale-id', locale);
  }

  createCookieLanguage(locale, false);
});
$(document).on('click', '.confirmationModal .continue-btn', function () {
  var locale = $(this).data('locale-id');
  createCookieLanguage(locale, true);
});
module.exports = {
  showCountrySelectorPopup: showCountrySelectorPopup,
  showLanguages: showLanguages,
  filterCountry: filterCountry,
  dropdownSearch: dropdownSearch,
  confirmationModalEvent: confirmationModalEvent,
  hideContainerForCountrySearch: hideContainerForCountrySearch,
  keyboardAccessibility: keyboardAccessibility
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js":
/*!*****************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() <= SCREENSIZE.TABLETMAX;
/**
 * Validate whole form. Requires `this` to be set to form object
 * @param {jQuery.data} data - Event to be canceled if form is invalid.
 */

function validateFormOnBlur() {
  $(this).trigger('invalid', this.validity);
}
/**
 * Remove all validation. Should be called every time before revalidating form
 * @param {element} form - Form to be cleared
 * @returns {void}
 */


function clearForm(form) {
  $.each($(form).find('.form-control.is-invalid'), function () {
    $(this).parents('.form-group').find('.invalid-feedback').text('');
  });
  $(form).find('.form-control.is-invalid').removeClass('is-invalid');
}
/**
 * Validate form fields. Requires `this` to be set to form object
 * @param {element}  inputOrSelect -  current form field input/select
 */


function inputValidate(inputOrSelect) {
  if (inputOrSelect) {
    inputOrSelect.setCustomValidity('');

    if (!$(this).hasClass('js-phone')) {
      if (!inputOrSelect.validity.valid) {
        var validationMessage = inputOrSelect.validationMessage;
        $(inputOrSelect).addClass('is-invalid');
        $(inputOrSelect).attr('aria-invalid', 'true');
        $(inputOrSelect).parents('.form-group').addClass('is-invalid');

        if (inputOrSelect.validity.patternMismatch && $(inputOrSelect).data('pattern-mismatch')) {
          validationMessage = $(inputOrSelect).attr('data-pattern-mismatch');
        }

        if ((inputOrSelect.validity.rangeOverflow || inputOrSelect.validity.rangeUnderflow) && $(inputOrSelect).data('range-error')) {
          validationMessage = $(inputOrSelect).attr('data-range-error');
        }

        if ((inputOrSelect.validity.tooLong || inputOrSelect.validity.tooShort) && $(inputOrSelect).data('range-error')) {
          validationMessage = $(inputOrSelect).attr('data-range-error');
        }

        if (inputOrSelect.validity.valueMissing && $(inputOrSelect).data('missing-error')) {
          validationMessage = $(inputOrSelect).attr('data-missing-error');
        }

        if (inputOrSelect.validity.typeMismatch && $(inputOrSelect).data('type-mismatch')) {
          validationMessage = $(inputOrSelect).attr('data-type-mismatch');
        }

        $(inputOrSelect).parents('.form-group').find('.invalid-feedback').text(validationMessage);
      } else {
        $(inputOrSelect).removeClass('is-invalid');
        $(inputOrSelect).parents('.form-group').removeClass('is-invalid');

        if (!$(this).parents('.form-group').find('.invalid-feedback').hasClass('first-and-last-name-error')) {
          $(this).parents('.form-group').find('.first-and-last-name-error').text('');
        }

        if (!$(this).parents('.form-group').find('.invalid-feedback').hasClass('invalid-feedback-custom')) {
          $(this).parents('.form-group').find('.invalid-feedback-custom').text('');
        }
      }
    }
  }
}
/**
 * Validate whole form. Requires `this` to be set to form object
 * @param {jQuery.event} event - Event to be canceled if form is invalid.
 * @returns {boolean} - Flag to indicate if form is valid
 */


function _validateForm(event) {
  var valid = true;

  if (this.checkValidity && !this.checkValidity()) {
    // safari
    valid = false;

    if (event) {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
    }

    $(this).find('input, select, textarea').each(function () {
      if ($(this).parents('#addressFormAccordion').length && isMobile) {
        inputValidate(this);
      }

      if (!this.validity.valid) {
        $(this).trigger('invalid', this.validity);
      }
    });
    $(this).find('.is-invalid:first').focus();
  }

  return valid;
}

module.exports = {
  validateFormOnBlur: validateFormOnBlur,
  inputValidate: inputValidate,
  invalid: function invalid() {
    $('form input, form select, form textarea').on('invalid blur input', function (e) {
      if (e.type === 'blur' && $(this).hasClass('store-pincode')) {
        return true;
      }

      if (e.type === 'blur' && $(this).hasClass('email') && this.validity.valueMissing) {
        return true;
      }

      var userCheck = $(this).closest('form');
      var signInError;

      if (userCheck.attr('id') === 'login-form') {
        signInError = userCheck.find('.alert.alert-danger');
      } else {
        signInError = userCheck.find('.customer-error');
      }

      e.preventDefault();
      this.setCustomValidity('');

      if (!$(this).hasClass('js-phone')) {
        if (!this.validity.valid) {
          var validationMessage = this.validationMessage;

          if (e.type !== 'input') {
            $(this).addClass('is-invalid');
            $(this).parents('.form-group').addClass('is-invalid');
            $(this).attr('aria-invalid', 'true');
          }

          if (userCheck.hasClass('edit-profile-form') && $('.is-invalid').length > 0) {
            var errorField = $('.is-invalid:first').offset().top;
            clientSideUtil.windowScrollToDestination(errorField, 0, 'smooth');
          }

          if (this.validity.patternMismatch && $(this).data('pattern-mismatch')) {
            validationMessage = $(this).attr('data-pattern-mismatch');
          }

          if ((this.validity.rangeOverflow || this.validity.rangeUnderflow) && $(this).data('range-error')) {
            validationMessage = $(this).attr('data-range-error');
          }

          if ((this.validity.tooLong || this.validity.tooShort) && $(this).data('range-error')) {
            validationMessage = $(this).attr('data-range-error');
          }

          if (this.validity.valueMissing && $(this).data('missing-error')) {
            validationMessage = $(this).attr('data-missing-error');
          }

          if (this.validity.typeMismatch && $(this).data('type-mismatch')) {
            validationMessage = $(this).attr('data-type-mismatch');
          }

          if (e.type !== 'input') {
            $(this).parents('.form-group').find('.invalid-feedback').text(validationMessage);
          }

          if ($(this).hasClass('is-invalid') && (userCheck.attr('id') === 'registered-customer' || userCheck.attr('id') === 'guest-customer' || userCheck.attr('id') === 'login-form' || userCheck.attr('id') === 'page-login-form')) {
            signInError.hide();
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
          }

          if (e.type === 'invalid') {
            userCheck.find('.is-invalid:first').focus();
          }

          if (this.closest('form').id === 'newsletter-form' && e.type === 'invalid') {
            $('body').trigger('event:newslettersignupError', validationMessage);
            e.stopPropagation();
            e.stopImmediatePropagation();
            $(this).addClass('is-invalid').attr('aria-invalid', 'true');
            $(this).focus();
          }

          if (userCheck.hasClass('remove-aria-invalid') && e.type === 'invalid') {
            $(this).removeAttr('aria-invalid');
          }
        } else {
          $(this).removeClass('is-invalid');
          $(this).parents('.form-group').removeClass('is-invalid');

          if (!$(this).parents('.form-group').find('.invalid-feedback').hasClass('first-and-last-name-error')) {
            $(this).parents('.form-group').find('.first-and-last-name-error').text('');
          }

          if (!$(this).parents('.form-group').find('.invalid-feedback').hasClass('invalid-feedback-custom')) {
            $(this).parents('.form-group').find('.invalid-feedback-custom').text('');
          }

          $(this).attr('aria-invalid', 'false');

          if (userCheck.attr('id') === 'registered-customer' || userCheck.attr('id') === 'guest-customer' || userCheck.attr('id') === 'login-form' || userCheck.attr('id') === 'page-login-form') {
            if (!signInError.is(':empty')) {
              signInError.show();
            }

            if (userCheck.attr('id') === 'guest-customer' && $('.submit-customer').attr('disabled') === 'disabled') {
              $('.submit-customer').prop('disabled', false);
            }
          }
        }
      }
    });
  },
  submit: function submit() {
    $('form').on('submit', function (e) {
      return _validateForm.call(this, e);
    });
  },
  buttonClick: function buttonClick() {
    $('form button[type="submit"], form input[type="submit"]').on('click', function () {
      // clear all errors when trying to submit the form
      var $selectorEL = $(this);
      var $selectorParents = $selectorEL.parents('form');
      $selectorParents.find('.form-control').attr('aria-invalid', 'false');
      $selectorParents.find('.form-control.is-invalid').attr('aria-invalid', 'true'); // to execute after form validation added a timeout of 0 seconds

      if (!$selectorEL.closest('.registered-form').length > 0 && $selectorEL.parents('.popover').length <= 0 && $selectorEL.parents('.modal').length <= 0) {
        setTimeout(function () {
          if ($('.invalid-feedback:visible').length > 0 && !$('.invalid-feedback:visible').isInViewport()) {
            var scrollValue = $selectorParents.find('.form-control.is-invalid').prev().offset().top;
            clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
          }
        }, 0);
      }
    });
  },
  functions: {
    validateForm: function validateForm(form, event) {
      return _validateForm.call(form, event || null);
    },
    clearForm: clearForm
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/collapsibleItem.js":
/*!************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/collapsibleItem.js ***!
  \************************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function () {
  var sizes = ['xs', 'sm', 'md', 'lg', 'xl', 'xxl'];
  sizes.forEach(function (size) {
    var selector = '.collapsible-' + size + ' .title';
    $('body').on('click', selector, function (e) {
      e.preventDefault();
      var $selectorEL = $(this);
      var $selectorParents = $selectorEL.parents('.collapsible-' + size);
      $selectorParents.toggleClass('active');

      if ($selectorParents.hasClass('active')) {
        $selectorEL.attr('aria-expanded', true);
      } else {
        $selectorEL.attr('aria-expanded', false);
      }

      $(window).trigger('collapsible:toggle', $selectorParents);
    });
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/consentTracking.js":
/*!************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/consentTracking.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");
/**
 * Renders a modal window that will track the users consenting to accepting site tracking policy
 */


function showConsentModal() {
  var $trackingConsentData = $('.tracking-consent');

  if (!$trackingConsentData.data('caonline')) {
    return;
  }

  var urlContent = $trackingConsentData.data('url');
  var urlAccept = $trackingConsentData.data('accept');
  var urlReject = $trackingConsentData.data('reject');
  var textYes = $trackingConsentData.data('accepttext');
  var textNo = $trackingConsentData.data('rejecttext');
  var textHeader = $trackingConsentData.data('heading');
  var tokenName = $trackingConsentData.data('tokenname');
  var token = $trackingConsentData.data('token');
  var htmlString = '<!-- Modal -->' + '<div class="modal show" id="consent-tracking" aria-modal="true" role="dialog" style="display: block;">' + '<div class="modal-dialog">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<div class="modal-header">' + textHeader + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer">' + '<div class="button-wrapper">' + '<button class="affirm btn btn-primary" data-url="' + urlAccept + '" autofocus data-dismiss="modal">' + textYes + '</button>' + '<button class="decline btn btn-primary" data-url="' + urlReject + '" data-dismiss="modal" >' + textNo + '</button>' + '</div>' + '</div>' + '</div>' + '</div>' + '</div>';
  $.spinner().start();
  $('body').append(htmlString);
  $.ajax({
    url: urlContent,
    type: 'get',
    dataType: 'html',
    success: function success(response) {
      $('.modal-body').html(response);
      $('#consent-tracking').modal('show');
    },
    error: function error() {
      $('#consent-tracking').remove();
    }
  });
  $('#consent-tracking .button-wrapper button').click(function (e) {
    e.preventDefault();
    var url = $(this).data('url');
    var data = {};
    data[tokenName] = token;
    $.ajax({
      url: url,
      type: 'post',
      data: data,
      dataType: 'json',
      success: function success(response) {
        // Only hide modal if the operation is successful - don't want to give a false impression
        if (response.success) {
          $('#consent-tracking').remove();
          $.spinner().stop();
        }
      },
      error: function error(err) {
        // Expected error response is for CSRF failure, which will include a redirect to CSRF-Fail
        if (err.responseJSON.redirectUrl) {
          window.location.href = err.responseJSON.redirectUrl;
        }
      }
    });
  });
}

module.exports = function () {
  if ($('.consented').length === 0 && $('.tracking-consent').hasClass('api-true')) {
    showConsentModal();
  }

  if ($('.tracking-consent').hasClass('api-true')) {
    $('.tracking-consent').click(function () {
      showConsentModal();
    });
  }

  $('body').on('shown.bs.modal', '#consent-tracking', function () {
    $('#consent-tracking').siblings().attr('aria-hidden', 'true');
    $('#consent-tracking .affirm').focus();
  });
  $('body').on('hidden.bs.modal', '#consent-tracking', function () {
    $('#consent-tracking').siblings().attr('aria-hidden', 'false');
  });
  $('body').on('keydown', '#consent-tracking', function (e) {
    var focusParams = {
      event: e,
      containerSelector: '#consent-tracking',
      firstElementSelector: '.affirm',
      lastElementSelector: '.decline',
      nextToLastElementSelector: '.affirm'
    };
    focusHelper.setTabNextFocus(focusParams);
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/cookie.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/cookie.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);
/**
 * Get cookie value by cookie name from browser
 * @param {string} cookieName - name of the cookie
 * @returns {string} cookie value of the found cookie name
 */


function getCookie(cookieName) {
  var name = cookieName + '=';
  var decodedCookie = decodeURIComponent(document.cookie);
  var cookieArray = decodedCookie.split(';');

  for (var i = 0; i < cookieArray.length; i++) {
    var cookieItem = cookieArray[i];

    while (cookieItem.charAt(0) === ' ') {
      cookieItem = cookieItem.substring(1);
    }

    if (cookieItem.indexOf(name) === 0) {
      return cookieItem.substring(name.length, cookieItem.length);
    }
  }

  return '';
}
/**
 * Sets cookie value by cookie name from browser
 * @param {string} cookieName - name of the cookie
 * @param {string} cookieValue - value of the cookie
 * @param {integer} seconds - cookie's length of days to be valid
 */


function createCookie(cookieName, cookieValue, seconds) {
  var expires = '0';

  if (seconds) {
    var date = new Date();
    date.setTime(date.getTime() + parseInt(seconds, 10));
    expires = '; expires=' + date.toGMTString();
  }

  document.cookie = cookieName + '=' + cookieValue + expires + '; path=/';
}
/**
 * Sets a cookie to -1 invalidating and erasing the cookie name from browser
 * @param {string} cookieName - name of the cookie
 */


function eraseCookie(cookieName) {
  createCookie(cookieName, '', -1);
}
/**
 *  Updates variable for live-chat container bottom position if cookie consent box is NOT present
 */


function updateLiveChatPosition() {
  $(document).on('click', '#onetrust-accept-btn-handler, #onetrust-reject-all-handler, .onetrust-close-btn-handler', function () {
    var $webchatBtn = $('.webchatStartButtonContainer');
    createCookie('oneTrustValue', 'true', 24 * 60 * 60 * 1000);

    if ($webchatBtn.length) {
      document.documentElement.style.setProperty('--webchat-adjusted-space', '0px');
    }
  });
}
/**
 *  Updates variable of live-chat container bottom position if cookie consent box is present
 */


function checkCookieConsent() {
  var onetrustEnabled = $('#oneTrustCheck').data('onetrustEnabled');
  var onetrustCookieValue = getCookie('oneTrustValue'); // check if onetrust cookie is enabled and if cookie value is present

  if (onetrustEnabled && !onetrustCookieValue) {
    var addedBottomPosition = $(window).outerWidth() > SCREENSIZE.DESKTOPMIN ? '100px' : '340px';
    document.documentElement.style.setProperty('--webchat-adjusted-space', addedBottomPosition);
  }
}

module.exports = {
  getCookie: getCookie,
  createCookie: createCookie,
  eraseCookie: eraseCookie,
  updateLiveChatPosition: updateLiveChatPosition,
  checkCookieConsent: checkCookieConsent
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/countryRedirectModal.js":
/*!*****************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/countryRedirectModal.js ***!
  \*****************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var geoIpCookie = __webpack_require__(/*! ./cookie */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/cookie.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * To Trigger the country redirect modal
 */


function triggerCountryRedirectModal() {
  var currentCountry = $('.country-selector').data('current-country');
  var geoLocation = $('.country-selector').data('geolocation');

  if (currentCountry !== geoLocation) {
    var url = $('.country-redirect-trigger').data('url');
    $.ajax({
      url: url,
      type: 'GET',
      dataType: 'json',
      success: function success(data) {
        if (data.renderedTemplate) {
          $('.countryRedirectModal-wrapper').empty().append(DOMpurify.sanitize(data.renderedTemplate));
          $('.country-redirect-trigger').trigger('click');

          var capriCountrySelector = __webpack_require__(/*! ./capriCountrySelector */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/capriCountrySelector.js");

          capriCountrySelector.showCountrySelectorPopup();
        }
      }
    });
  }
}
/**
 * accept cookies
 * */


function acceptCookies() {
  $(document).on('click', '#onetrust-accept-btn-handler', function () {
    triggerCountryRedirectModal();
  });
}
/**
 * On load trigger country modal when the it is not PD edit mode
 * */


function onLoadModalTrigger() {
  $(window).on('load', function () {
    var oneTrustEnabled = $('.country-redirect-trigger').hasClass('oneTrustEnabled');
    var isInEditMode = $('.country-redirect-trigger').hasClass('isInEditMode');

    if (!oneTrustEnabled && !isInEditMode) {
      if (geoIpCookie.getCookie('geoIP') !== 'true') {
        triggerCountryRedirectModal();
      }
    }
  });
}
/**
 * on hide modal
 * */


function onhideModal() {
  $('body').on('hidden.bs.modal', '#countryRedirectModal', function () {
    geoIpCookie.createCookie('geoIP', true, 30 * 24 * 60 * 60 * 1000);
  });
}

module.exports = {
  acceptCookies: acceptCookies(),
  onLoadModalTrigger: onLoadModalTrigger(),
  onhideModal: onhideModal()
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/countrySelector.js":
/*!************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/countrySelector.js ***!
  \************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keyboardAccessibility = __webpack_require__(/*! ./keyboardAccessibility */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/keyboardAccessibility.js");

module.exports = function () {
  $('.country-selector a').click(function (e) {
    e.preventDefault();
    var action = $('.page').data('action');
    var localeCode = $(this).data('locale');
    var localeCurrencyCode = $(this).data('currencycode');
    var queryString = $('.page').data('querystring');
    var url = $('.country-selector').data('url');
    $.ajax({
      url: url,
      type: 'get',
      dataType: 'json',
      data: {
        code: localeCode,
        queryString: queryString,
        CurrencyCode: localeCurrencyCode,
        action: action
      },
      success: function success(response) {
        $.spinner().stop();

        if (response && response.redirectUrl) {
          window.location.href = response.redirectUrl;
        }
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  });
  keyboardAccessibility('.footer-container .country-selector', {
    40: function _($countryOptions) {
      // down
      if ($(this).is(':focus')) {
        $countryOptions.first().focus();
      } else {
        $(':focus').next().focus();
      }
    },
    38: function _($countryOptions) {
      // up
      if ($countryOptions.first().is(':focus') || $(this).is(':focus')) {
        $(this).focus();
        $(this).removeClass('show');
      } else {
        $(':focus').prev().focus();
      }
    },
    27: function _() {
      // escape
      $(this).focus();
      $(this).removeClass('show').children('.dropdown-menu').removeClass('show');
    },
    9: function _() {
      // tab
      $(this).removeClass('show').children('.dropdown-menu').removeClass('show');
    }
  }, function () {
    if (!$(this).hasClass('show')) {
      $(this).addClass('show');
    }

    return $(this).find('.dropdown-country-selector').children('a');
  });
  $('.footer-container .country-selector').on('focusin', function () {
    $(this).addClass('show').children('.dropdown-menu').addClass('show');
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/customClientSideValidation.js":
/*!***********************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/customClientSideValidation.js ***!
  \***********************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var scrollAnimate = __webpack_require__(/*! ../components/scrollAnimate */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js");

var clientSideValidation = __webpack_require__(/*! ../components/clientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js");
/**
 * firstAndLastName
 * @param {string} firstName - firstName
 * @param {string} lastName - lastName
 * @returns{boolean} false
 */


function firstAndLastName(firstName, lastName) {
  firstName.addClass('is-invalid-custom');
  lastName.addClass('is-invalid-custom');
  var validationMessage = lastName.data('maxlength-error');
  lastName.parents('.form-group').find('.invalid-feedback').addClass('d-block first-and-last-name-error').text(validationMessage);
  var $selectorEL = lastName;
  var $selectorParents = $selectorEL.parents('form');

  if ($selectorParents.hasClass('shipping-form') || $selectorParents.hasClass('billing-information')) {
    scrollAnimate($('.is-invalid-custom'));
  } else {
    var scrollValue = $selectorParents.find('.form-control.is-invalid-custom').prev().offset().top;
    clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
  }

  return false;
}
/**
 * fetchFirstLastName
 * @param {string} form - form
 * @returns{boolean} valid
 */


function fetchFirstLastName(form) {
  var valid = true;
  var firstName = $(form).find('.first-name-validiation-js');
  var lastName = $(form).find('.last-name-validiation-js');

  if (firstName.val().length + lastName.val().length > 30) {
    valid = firstAndLastName(firstName, lastName);
  } else {
    firstName.removeClass('is-invalid-custom');
    lastName.removeClass('is-invalid-custom');

    if (lastName.parents('.form-group').find('.invalid-feedback').hasClass('first-and-last-name-error')) {
      lastName.parents('.form-group').find('.invalid-feedback').text('');
    }

    lastName.parents('.form-group').find('.invalid-feedback').removeClass('d-block first-and-last-name-error');
  }

  return valid;
}
/**
 * checkCurrentPasswordWithNewPassword
 * Function use to check if new password is the same as current password
 * @param {jQuery} form - form changePasswordFrom.isml
 * @returns {boolean} valid
 */


function checkCurrentPasswordWithNewPassword(form) {
  var valid = true;
  var $currentPassword = $(form).find('#currentPassword');
  var $newPassword = $(form).find('#newPassword');
  var validationMessage = $newPassword.data('previous-password');

  if ($currentPassword.val() === $newPassword.val()) {
    $newPassword.parents('.form-group').addClass('is-invalid');
    $newPassword.parents('.form-group').find('.invalid-feedback').text(validationMessage);
    $newPassword.parents('.form-group').find('input').addClass('is-invalid');
    valid = false;
  }

  return valid;
}
/**
 * scrollFunctionForError
 * @param {string} form - form
 */


function scrollFunctionForError(form) {
  $(form).find('input, select').each(function () {
    var formValid;

    if (!this.validity.valid) {
      scrollAnimate($(this));
      return formValid;
    }
  });
}
/**
 * Remove all validation. Should be called every time before revalidating form
 * Targets first and last name input.
 * @param {element} $form - Form to be cleared
 * @returns {void}
 */


function clearFirstLastNameError($form) {
  $form.find('.invalid-feedback').text('');
  $form.find('.form-control.is-invalid-custom').removeClass('is-invalid-custom');
}
/**
 * Show error if address is too long
 * @param {element} $this - addressOne element
 * @returns {void}
 */


function addressTooLong($this) {
  if ($this.val().length > $this.attr('maxlength')) {
    $this.addClass('is-invalid-custom');
    $this.siblings('.invalid-feedback').addClass('d-block invalid-feedback-custom').text($this.data('range-error'));
  } else {
    $this.removeClass('is-invalid-custom');
    $this.siblings('.invalid-feedback').removeClass('d-block invalid-feedback-custom');
  }
}
/**
 * Check Address one or Address two is too long
 * @param {element} addressOne - addressOne element
 * @param {element} addressTwo - addressTwo element
 * @returns {boolean} isValid
 */


function isAddressTooLong(addressOne, addressTwo) {
  var isValid;

  if (addressOne.hasClass('is-invalid-custom') || addressTwo.hasClass('is-invalid-custom')) {
    isValid = false;
  } else {
    isValid = true;
  }

  return isValid;
}
/**
 * Validation for empty fields in fieldset
 * @param {element} fieldSet - fieldSet element
 * @returns {boolean} - Flag to indicate if form is valid
 */


function customFieldSetValidation(fieldSet) {
  var valid = true;
  fieldSet.find('input, select').each(function () {
    if ($(this).prop('required')) {
      clientSideValidation.inputValidate(this);
    }
  });

  if (fieldSet.find('.is-invalid').length) {
    valid = false;
  }

  return valid;
}
/**
 * Validation for empty fields in fieldset
 * @param {element} selector - selector
 * @returns {boolean} - Flag to indicate if form is valid
 */


function stateValidation(selector) {
  var valid = true;
  var stateField = selector.find('#state')[0];
  clientSideValidation.inputValidate(stateField);

  if (selector.find('.is-invalid').length) {
    valid = false;
  }

  return valid;
}

module.exports = {
  fetchFirstLastName: fetchFirstLastName,
  scrollFunctionForError: scrollFunctionForError,
  clearFirstLastNameError: clearFirstLastNameError,
  checkCurrentPasswordWithNewPassword: checkCurrentPasswordWithNewPassword,
  addressTooLong: addressTooLong,
  isAddressTooLong: isAddressTooLong,
  customFieldSetValidation: customFieldSetValidation,
  stateValidation: stateValidation
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js ***!
  \**************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  setTabNextFocus: function setTabNextFocus(focusParams) {
    var KEYCODE_TAB = 9;
    var isTabPressed = focusParams.event.key === 'Tab' || focusParams.event.keyCode === KEYCODE_TAB;

    if (!isTabPressed) {
      return;
    }

    var firstFocusableEl = $(focusParams.containerSelector + ' ' + focusParams.firstElementSelector);
    var lastFocusableEl = $(focusParams.containerSelector + ' ' + focusParams.lastElementSelector);

    if ($(focusParams.containerSelector + ' ' + focusParams.lastElementSelector).is(':disabled')) {
      lastFocusableEl = $(focusParams.containerSelector + ' ' + focusParams.nextToLastElementSelector);

      if ($('.product-quickview.product-set').length > 0) {
        var linkElements = $(focusParams.containerSelector + ' a#fa-link.share-icons');
        lastFocusableEl = linkElements[linkElements.length - 1];
      }
    }

    if (focusParams.event.shiftKey)
      /* shift + tab */
      {
        if ($(':focus').is(firstFocusableEl)) {
          lastFocusableEl.focus();
          focusParams.event.preventDefault();
        }
      } else
      /* tab */
      {
        if ($(':focus').is(lastFocusableEl)) {
          // eslint-disable-line
          firstFocusableEl.focus();
          focusParams.event.preventDefault();
        }
      }
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/footer.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/footer.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var scrollAnimate = __webpack_require__(/*! ./scrollAnimate */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js");

var modalHelper = __webpack_require__(/*! ./modal */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/modal.js");

var observingIconLoad = __webpack_require__(/*! ./iconPlacement */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/iconPlacement.js");
/**
 * appends params to a url
 * @param {string} data - data returned from the server's ajax call
 * @param {Object} button - button that was clicked for email sign-up
 */


function displayMessage(data, button) {
  $.spinner().stop();
  var status;

  if (data.success) {
    status = 'alert-success';
  } else {
    status = 'alert-danger';
  }

  if ($('.email-signup-message').length === 0) {
    $('body').append('<div class="email-signup-message"></div>');
  }

  $('.email-signup-message').append('<div class="email-signup-alert text-center ' + status + '">' + data.msg + '</div>');
  setTimeout(function () {
    $('.email-signup-message').remove();
    button.removeAttr('disabled');
  }, 3000);
}
/**
 * Back to top function
 */


function onBackToTop() {
  $('.back-to-top').on('click', function (e) {
    $('body').trigger('event:scrollToTop');
    scrollAnimate();
    e.stopPropagation();
    e.stopImmediatePropagation();
  });
}
/**
 * Subscribe email form
 */


function onSubscribeEmail() {
  $('.subscribe-email').on('click', function (e) {
    e.preventDefault();
    var url = $(this).data('href');
    var button = $(this);
    var emailId = $('input[name=hpEmailSignUp]').val();
    $.spinner().start();
    $(this).attr('disabled', true);
    $.ajax({
      url: url,
      type: 'post',
      dataType: 'json',
      data: {
        emailId: emailId
      },
      success: function success(data) {
        displayMessage(data, button);
      },
      error: function error(err) {
        displayMessage(err, button);
      }
    });
  });
}
/**
 * Creating modal and filling data on submiting the form
 */


function onNewsLetterScubscription() {
  $('#newsletter-form').on('submit', function (e) {
    e.preventDefault();
    var $this = $(this);
    var newsLetterUrl = $this.attr('action');
    modalHelper.getModalHtmlElement('newsLetterModal', 'news-letter-dialog', false);
    modalHelper.fillModalElement($this, newsLetterUrl, 'newsLetterModal');
  });
}
/**
 * Footer Accordian
 */


function footerAccordion() {
  $('.accordion-item button').on('click', function () {
    $(this).closest('.accordion-item').siblings().removeClass('active');
    $(this).closest('.accordion-item').siblings().find('button').attr('aria-expanded', false);
  });
}
/**
 * Apple Pay Check
 */


function applePayCheck() {
  // add class if Apple pay is present
  if (window.dw && window.dw.applepay && window.ApplePaySession && window.ApplePaySession.canMakePayments()) {
    $('body').addClass('apple-pay-enabled');
  }
}
/**
* Clear Newsletter Value
*/


function clearNewsLetterValue() {
  $(document).on('hide.bs.modal', '#newsLetterModal', function () {
    if ($('.loggedin-user').length > 0) {
      $('#newsletter-form #newletter-form-email').val('');
      $('.email-signup-sub-conatiner .g-recaptcha').html('');
    }
  });
}

module.exports = {
  onBackToTop: onBackToTop,
  onSubscribeEmail: onSubscribeEmail,
  onNewsLetterScubscription: onNewsLetterScubscription,
  footerAccordion: footerAccordion,
  applePayCheck: applePayCheck,
  clearNewsLetterValue: clearNewsLetterValue,
  observingIconLoad: observingIconLoad.observingIconLoad
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/formValidation.js":
/*!***********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/formValidation.js ***!
  \***********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");
/**
 * Remove all validation. Should be called every time before revalidating form
 * @param {element} form - Form to be cleared
 * @returns {void}
 */


function clearFormErrors(form) {
  $(form).find('.form-control.is-invalid').removeClass('is-invalid');
}

module.exports = function (formElement, payload) {
  // clear form validation first
  clearFormErrors(formElement);
  $('.alert', formElement).remove();

  if (_typeof(payload) === 'object' && payload.fields) {
    Object.keys(payload.fields).forEach(function (key) {
      if (payload.fields[key]) {
        var feedbackElement = $(formElement).find('[name="' + key + '"]').parent().children('.invalid-feedback');

        if (feedbackElement.length > 0) {
          if (Array.isArray(payload[key])) {
            feedbackElement.html(payload.fields[key].join('<br/>'));
          } else {
            feedbackElement.html(payload.fields[key]);
          }

          feedbackElement.siblings('.form-control').addClass('is-invalid');
        }
      }
    });
  }

  if (payload && payload.error) {
    var form = $(formElement).prop('tagName') === 'FORM' ? $(formElement) : $(formElement).parents('form');
    form.prepend('<div class="alert alert-danger" role="alert">' + payload.error.join('<br/>') + '</div>');

    if (form.parents('.popover').length <= 0) {
      if (!$(form).find('.alert.alert-danger').isInViewport()) {
        var scrollValue = $(form).find('.alert.alert-danger').offset().top;
        clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
      }
    }
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/header.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/header.js ***!
  \***************************************************************************************/
/***/ (function(module) {

"use strict";
 // Get the header and main Content div

var header = $('header');
var mainContent = $('#maincontent');
var body = $('body');
/**
 * Add the sticky class to the header when you reach its scroll position. Remove "sticky" when you leave the scroll position
 * */

function stickyHeader() {
  if (header.length) {
    var sticky = header.offset().top;
    var $searchMobile = $('.search-mobile');
    window.addEventListener('scroll', function () {
      // Get the offset position of the navbar
      if (window.scrollY > sticky) {
        header.addClass('sticky');
        body.addClass('header-sticky');
        mainContent.css('padding-top', Math.round($('header.sticky').outerHeight() - $('.search-mobile').outerHeight()));
        $searchMobile.removeClass('scroll-up').addClass('scroll-down');
      } else {
        mainContent.css('padding-top', '0');
        header.removeClass('sticky');
        body.removeClass('header-sticky');
        $searchMobile.addClass('scroll-up').removeClass('scroll-down');
      }
    });
  }
}
/**
 * initialise slick carousel
 * */


function promoCarouselInit() {
  $('.header-banner').removeClass('d-none');
  var promoCarousel = $('.js-promo-carousel');
  var promoCarouselDuration = promoCarousel.data('autoplayspeed');

  if (promoCarousel.length) {
    promoCarousel.slick({
      arrows: false,
      fade: true,
      autoplay: true,
      autoplaySpeed: promoCarouselDuration
    });
  }
}
/**
 * Init the Header fucntions
 * */


function initHeaderFunctions() {
  stickyHeader();
  promoCarouselInit();
}
/**
 * remove priceStatusType from local storage for other pages except PDP
 * */


function removeLocalStorage() {
  var pdpPage = $('.product-detail').length === 0;

  if (pdpPage) {
    if (localStorage.getItem('priceStatusType')) {
      localStorage.removeItem('priceStatusType');
    }
  }
}

module.exports = {
  initHeaderFunctions: initHeaderFunctions(),
  removeLocalStorage: removeLocalStorage()
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/iconPlacement.js":
/*!**********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/iconPlacement.js ***!
  \**********************************************************************************************/
/***/ (function(module) {

"use strict";

/**
 * Checks if the webchat button is loaded or not
 * @returns {boolean} true if the webchat button is loaded
 */

function isWebChatActive() {
  var webChatLoaded = false;
  var inConcert = window.inConcert;

  if (typeof inConcert !== 'undefined') {
    var inConcertTokenId = Object.keys(inConcert);

    if (inConcertTokenId !== undefined) {
      inConcertTokenId.forEach(function (tokenId) {
        if (inConcert[tokenId].isActive !== undefined) {
          if (inConcert[tokenId].isActive()) {
            webChatLoaded = true;
          }
        }
      });
    }
  }

  return webChatLoaded;
}
/**
 * Update treatment & placement of
 * Live Chat widget, back to top icon and audio eye icon
 */


function updateIconLoadStatus() {
  var $backToTopButton = $('.back-to-top-icon-loaded');
  var $audioBtn = $('.ae-cta-position-preset-right-lower');
  var $webchatStartButtonContainer = $('.webchatStartButtonContainer');
  var webChatLoaded = isWebChatActive();

  if (webChatLoaded) {
    $backToTopButton.addClass('web-chat-loaded');
    $audioBtn.addClass('web-chat-loaded');
    var hideLiveChatIcon = $('body').data('live-chat-icon');
    $('.webchatStartButtonContainer').addClass(hideLiveChatIcon);
  } else {
    $backToTopButton.removeClass('web-chat-loaded');
    $audioBtn.removeClass('web-chat-loaded');
  }

  if ($backToTopButton.length > 0) {
    $webchatStartButtonContainer.addClass('back-to-top-loaded');
    $audioBtn.addClass('back-to-top-loaded');
  } else {
    $webchatStartButtonContainer.removeClass('back-to-top-loaded');
    $audioBtn.removeClass('back-to-top-loaded');
  }

  if ($audioBtn.length > 0) {
    $webchatStartButtonContainer.addClass('ae-loaded');
    $backToTopButton.addClass('ae-loaded');
  } else {
    $webchatStartButtonContainer.removeClass('ae-loaded');
    $backToTopButton.removeClass('ae-loaded');
  }
}
/**
 * mutations for child elements
 */


function observingIconLoad() {
  var observer = new MutationObserver(function (mutations) {
    mutations.forEach(function (mutation) {
      if (mutation.type === 'childList' || mutation.type === 'attribute') {
        updateIconLoadStatus();
      }
    });
  });
  observer.observe(document.body, {
    childList: true,
    attribute: true,
    subtree: true
  });
}

module.exports = {
  observingIconLoad: observingIconLoad
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/keyboardAccessibility.js":
/*!******************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/keyboardAccessibility.js ***!
  \******************************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function (selector, keyFunctions, preFunction) {
  $(document).on('keydown', selector, function (e) {
    var key = e.which;
    var supportedKeyCodes = [37, 38, 39, 40, 27];

    if (supportedKeyCodes.indexOf(key) >= 0) {
      e.preventDefault();
    }

    var returnedScope = preFunction.call(this);

    if (keyFunctions[key]) {
      keyFunctions[key].call(this, returnedScope);
    }
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/menu.js":
/*!*************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/menu.js ***!
  \*************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keyboardAccessibility = __webpack_require__(/*! ./keyboardAccessibility */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/keyboardAccessibility.js");

var capriCountrySelector = __webpack_require__(/*! ./capriCountrySelector */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/capriCountrySelector.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var locked = false;

var MENUCLOSEDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").MENUCLOSEDELAY);

var MENUHOVERDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").MENUHOVERDELAY);

var SUBMENUHOVERDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SUBMENUHOVERDELAY);

var isMediumSize = function isMediumSize() {
  return $(window).width() <= SCREENSIZE.DESKTOPMIN;
};

var isSmallSize = function isSmallSize() {
  return $(window).width() < SCREENSIZE.TABLETMIN;
};

var isMacDesktop = function isMacDesktop() {
  return /Mac/i.test(navigator.userAgent) && !/iPhone | Android/i.test(navigator.userAgent);
};

var inactiveElementsL1 = [];
var inactiveElementsL2 = [];

var addFocus = function addFocus($inactiveElementsArray) {
  if ($inactiveElementsArray.length) {
    $.each($inactiveElementsArray, function () {
      $(this).removeAttr('aria-hidden');
    });
    $inactiveElementsArray.splice(0, $inactiveElementsArray.length);
  }
};

var clearSelection = function clearSelection(element) {
  $(element).closest('.dropdown').children('.dropdown-menu').children('.top-category').detach();
  $(element).closest('.dropdown.show').children('.nav-link').attr('aria-expanded', 'false');
  $(element).closest('.dropdown.show').find('.js-country-selector:visible').attr('aria-expanded', 'false');
  $(element).closest('.dropdown.show').children('.dropdown-menu').attr('aria-hidden', 'true');
  $(element).closest('.dropdown.show').find('.dropdown-menu').removeClass('active-dropdown');
  $(element).closest('.dropdown.show').removeClass('show');
  $('.dropdown.show').last().find('.dropdown-menu').first().addClass('active-dropdown');
  $('div.menu-group > ul.nav.navbar-nav > li.nav-item > a').attr('aria-hidden', 'false');
  $(element).parent().find('.nav-menu').detach();
  $(element).closest('li').not('.country-selector-header').not('.country-label-name').detach();
  $('.dropdown-main-menu').css('min-height', 'auto');
  $(element).closest('.dropdown').children('.dropdown-menu').children('.back-menu').detach();
  $('.menu-shops-banner').removeClass('d-none');
  $('.country-search-text-box').val('');
  capriCountrySelector.hideContainerForCountrySearch();
  $('.main-menu').siblings().attr('aria-hidden', 'true');
  $('header').siblings().attr('aria-hidden', 'true');

  if (window.outerWidth < SCREENSIZE.DESKTOPMIN) {
    if ($(element).find('.back-prev-click').length) {
      addFocus(inactiveElementsL1);
      addFocus(inactiveElementsL2);
      $('.dropdown-menu').attr('aria-hidden', 'true');
      $('.navbar-toggler').focus();
    } else {
      addFocus(inactiveElementsL2);
    }
  } // main menu item


  if ($(element).find('.back-prev-click').length > 0) {
    $('.dropdown-menu').children('.top-category').detach();
    $('.dropdown-menu').children('.back-menu').detach();
    $('.dropdown-menu').children('.nav-menu').detach();
    $('.dropdown').removeClass('show');
  }
};

var loadNavImages = function loadNavImages($imageSelector) {
  $.each($imageSelector, function () {
    var $this = $(this);
    $this.attr('src', $this.data('src'));
  });
};

var showSubMenuOnDesktop = function showSubMenuOnDesktop(activeElement) {
  $('.navbar-nav > li').each(function () {
    if (!$.contains(this, activeElement)) {
      if ($(this).hasClass('show')) {
        $(this).removeClass('show');
        $(this).children('ul.dropdown-menu:not(.submenu-mobile)').removeClass('show');

        if (!isMacDesktop()) {
          $(this).children('.nav-link').attr('aria-expanded', 'false');
        }
      }
    }
  }); // need to close all the dropdowns that are not direct parent of current dropdown

  var $dropDownMenu = $(activeElement).siblings('.dropdown-menu:not(.submenu-mobile)');
  loadNavImages($(activeElement).parent().find('.shops-banner-image img'));
  $(activeElement).parent().addClass('show');
  $dropDownMenu.addClass('show');
};

var getSubMenuOnDesktop = function getSubMenuOnDesktop(eventElement, $navItem) {
  var url = $navItem.data('action');
  var isSubMenuLoaded = false;
  $.ajax({
    url: url,
    type: 'get',
    beforeSend: function beforeSend() {
      setTimeout(function () {
        if (!isSubMenuLoaded) {
          $.spinner().start();
        }
      }, SUBMENUHOVERDELAY);
    },
    success: function success(data) {
      isSubMenuLoaded = true;
      $.spinner().stop();
      $navItem.append(data);
      showSubMenuOnDesktop(eventElement);
    },
    error: function error() {
      isSubMenuLoaded = true;
      $.spinner().stop();
      $navItem.attr('data-loaded', false);
    }
  });
};

var showSubMenuOnMobile = function showSubMenuOnMobile(activeElement) {
  var isCountrySelector = $(activeElement).hasClass('mobile-country-selector');

  if (!isCountrySelector) {
    // copy parent element into current UL
    var li = $('<li class="dropdown-item top-category" role="link" tabindex="0"></li>');
    var $currentDropDownMenu = $(activeElement).closest('.dropdown').children('.dropdown-menu');
    var link = $(activeElement).clone().removeClass('dropdown-toggle').removeAttr('data-toggle aria-expanded role').attr('aria-haspopup', 'false');
    li.append(link);
    $currentDropDownMenu.prepend(li);
    $(link).focus(); // Back event for mega menu for mobile view

    var itemCloseMenu = $('<li class="nav-menu"></li>');
    var closeMenu = $('.close-menu').first().clone().removeClass('d-none');
    closeMenu.removeAttr('aria-hidden');
    closeMenu.find('.back, button').removeAttr('aria-hidden');
    itemCloseMenu.append(closeMenu);
    var topcategory = $(activeElement).parents('.navbar-main-menu').siblings('.top-category');
    var backMenu = $('<li class="back-menu back d-none m-0"></li>');

    if (topcategory.length) {
      var backMenuLink = $(activeElement).parents('.navbar-main-menu').siblings('.top-category').clone().text();
      backMenu.append(backMenuLink);
      backMenu.removeClass('d-none');
      backMenu.attr('aria-label', backMenuLink.trim());
      $(activeElement).parents('.navbar-main-menu').find('.menu-shops-banner').addClass('d-none');
    }

    $currentDropDownMenu.prepend(backMenu).prepend(itemCloseMenu).attr('aria-hidden', 'false');
  } else {
    $(activeElement).closest('.region-container').find('.country-label-name').first().focus();
    $(activeElement).siblings('.language-container').attr('aria-hidden', 'false'); // copy search and header element into current UL

    var isRegion = $(activeElement).hasClass('region-name');
    var staticEleCheck = $(activeElement).closest('.region-container').find('.country-static-mobile');

    if (isRegion && staticEleCheck.length === 0) {
      var ul = $('<ul class="country-static-mobile list-unstyled p-0"></ul>');
      var countrySelectorConatiner = $(activeElement).closest('.country-selector-body');
      var countrySelectorHeader = $(countrySelectorConatiner).find('.country-selector-header').first().clone();
      var countrySelectorHeaderSearch = $(countrySelectorConatiner).find('.search-label').first().clone();
      var countrySelectorSearch = $(countrySelectorConatiner).find('.searchPanel').first().clone();
      ul.append(countrySelectorHeader).append(countrySelectorHeaderSearch).append(countrySelectorSearch);
      $(activeElement).closest('.region-container').find('.regions-dropdown').prepend(ul);
      var countrySelectorLabel = ul.find('.country-selector-header').not('.search-label').find('.country-selector-header-h1');
      countrySelectorLabel.find('span').html(countrySelectorLabel.data('country-label'));
      var confirmationModal = $(countrySelectorConatiner).find('#confirmationModal').clone();
      $('body').append(confirmationModal);
      $(countrySelectorConatiner).find('#confirmationModal').detach();
    }
  } // copy navigation menu into view


  loadNavImages($(activeElement).closest('.dropdown').find('.shops-banner-image img'));
  $(activeElement).closest('.dropdown').addClass('show');
  $(activeElement).closest('.dropdown').find('.back button').focus();
  $('.dropdown-menu').removeClass('active-dropdown');
  $(activeElement).closest('.dropdown').find('.dropdown-menu').addClass('active-dropdown');

  if ($(activeElement).siblings('.dropdown-menu').find('.stack-vertical-links').val() === '') {
    $('.stack-vertical-links').css('margin', '0');
  }

  var level2 = $(activeElement).parents('.menu-group');
  var level3 = $(activeElement).parents('.level-1-sub-cat').children('.navbar-main-menu').children('.dropdown-main-menu').children('.dropdown-item.show').children('.dropdown-menu');
  var contentAssetOnline = $(activeElement).siblings('.dropdown-menu').find('.mobile-shop-banner .content-asset');

  if ($(activeElement).siblings('.level-1-sub-cat').length > 0 && $(activeElement).siblings('.level-1-sub-cat').children('.navbar-main-menu').children('.dropdown-main-menu').children('li').length <= 5 && contentAssetOnline.length === 0) {
    $(level2).addClass('overflow-hidden');
  } else if ($(level3).children('li').length > 0 && $(level3).children('li').length <= 5) {
    $(level2).addClass('overflow-hidden');
  } else {
    $(level2).removeClass('overflow-hidden');
  }

  if (level3.length > 0 && level3) {
    $(activeElement).parents('.level-1-sub-cat').addClass('overflow-hidden');
    $(level3).addClass('overflow-auto');
    $(activeElement).parents('.menu-group').css('overflow', 'inherit');
  }

  var regionsCount = $(activeElement).siblings('.regions-dropdown').children('.country-selector-regions');

  if ($(regionsCount).children('li').length > 0 && $(regionsCount).children('li').length > 5) {
    $(activeElement).closest('.menu-group').removeClass('overflow-hidden');
    $(activeElement).parents('.menu-group').css('overflow', 'inherit');
    $(activeElement).siblings('.regions-dropdown').addClass('overflow-auto');
  } else {
    $(activeElement).parents('.regions-dropdown').removeClass('overflow-auto');
  }

  if ($(activeElement).siblings('.regions-dropdown').length > 0 && $(activeElement).siblings('.regions-dropdown').children('.country-selector-regions').children('li').length <= 5) {
    $(activeElement).closest('.menu-group').addClass('overflow-hidden');
  }

  if ($(activeElement).siblings('.language-container').length > 0 && $(activeElement).siblings('.language-container').length <= 5) {
    $(activeElement).siblings('.language-container').closest('.menu-group').addClass('overflow-hidden');
  }

  $('.navbar.navbar-expand-lg').scrollTop(0);

  if (!isMacDesktop()) {
    $(activeElement).attr('aria-expanded', 'true');
  }

  $('div.menu-group > ul.nav.navbar-nav > li.nav-item > a').attr('aria-hidden', 'true');
  $('header').siblings().attr('aria-hidden', 'true');
  var $submenu = $(activeElement).parent().hasClass('category-link') ? $(activeElement).parent().siblings('ul.dropdown-menu') : $(activeElement).siblings('ul.dropdown-menu');
  var submenuClassName = $submenu.attr('class');
  var $menuSelected = $(activeElement);
  var submenuSelector = '.' + submenuClassName.replace(/\s/g, '.');
  $('.navigation-bar.navbar').find('a, button, div, li').each(function () {
    if (!$(this).hasClass(submenuClassName) && !$(this).parents().hasClass(submenuClassName) && !$(this).find(submenuSelector).length && $(this).attr('aria-hidden') !== 'true') {
      if ($menuSelected.parent().hasClass('nav-item')) {
        inactiveElementsL1.push($(this));
      } else {
        inactiveElementsL2.push($(this));
      }

      $(this).attr('aria-hidden', 'true');
    }
  });
};

var getSubMenuOnMobile = function getSubMenuOnMobile(eventElement, $navItem) {
  var url = $navItem.data('action');
  var isSubMenuLoaded = false;
  $.ajax({
    url: url,
    type: 'get',
    beforeSend: function beforeSend() {
      setTimeout(function () {
        if (!isSubMenuLoaded) {
          $.spinner().start();
        }
      }, SUBMENUHOVERDELAY);
    },
    success: function success(data) {
      isSubMenuLoaded = true;
      $.spinner().stop();
      $navItem.append(data);
      showSubMenuOnMobile(eventElement);
    },
    error: function error() {
      isSubMenuLoaded = true;
      $.spinner().stop();
      $navItem.attr('data-loaded', false);
    }
  });
};

module.exports = function () {
  var isDesktop = function isDesktop() {
    return window.outerWidth > SCREENSIZE.DESKTOPMIN;
  }; // check device to update navidation role


  if (isMacDesktop()) {
    var $subCategory = $('.menu-group').find('.sub-category');
    $subCategory.find('a').removeAttr('aria-expanded aria-haspopup');
    $('.menu-group').find('.category-link').attr('role', 'link');
  } // Resize device


  $(window).on('resize', function () {
    $('#country-selector').modal('hide');
    isMediumSize();

    if (isDesktop() && !locked && $('.navbar-toggler').hasClass('open')) {
      $('.scroll-height').height('auto');
      $('.main-menu').removeClass('in');
      $('.navigation-bar .header').removeAttr('aria-hidden');
      $('.dropdown').removeClass('show');
      $('.modal-background').removeClass('d-block');
      $('.page-overlay').removeClass('active');
      $('.nav-menu, .top-category, .back-menu').detach();
      $('.navbar-toggler').removeClass('mouseFocusUnActive open');
      $('body').removeClass('overflow-hidden');

      if ($('.navigation-bar').hasClass('active-search')) {
        $('.search-mobile').toggleClass('d-none');
      }

      locked = true;
    }

    var mainMenu = $('.main-menu');

    if (isDesktop()) {
      mainMenu.removeAttr('aria-hidden');
      mainMenu.removeAttr('tabindex');
    } else {
      mainMenu.attr('aria-hidden', 'true');
      mainMenu.attr('tabindex', '-1');
    }
  });
  $(window).on('load', function () {
    if (!isDesktop()) {
      var mainMenu = $('.main-menu');
      mainMenu.attr('aria-hidden', 'true');
      mainMenu.attr('tabindex', '-1');
    }
  });
  var headerBannerStatus = window.sessionStorage.getItem('hide_header_banner');
  $('.header-banner .close').on('click', function () {
    $('.header-banner').addClass('d-none');
    window.sessionStorage.setItem('hide_header_banner', '1');
  });

  if (!headerBannerStatus || headerBannerStatus < 0) {
    $('.header-banner').css('visibility', 'visible');
  }

  keyboardAccessibility('.main-menu .nav-link, .main-menu .dropdown-link', {
    40: function _(menuItem) {
      // down
      if (menuItem.hasClass('nav-item')) {
        // top level
        var $navItem = $(menuItem);
        var isHasSubcatogy = $navItem.data('sub');
        var isSubcatogyLoaded = $navItem.data('loaded');

        if (isHasSubcatogy && !isSubcatogyLoaded) {
          $navItem.attr('data-loaded', true);

          if (isDesktop()) {
            getSubMenuOnDesktop($(menuItem).children('.nav-link'), $navItem);
          } else {
            getSubMenuOnMobile($(menuItem).children('.nav-link'), $navItem);
          }
        } else {
          $('.navbar-nav .show').removeClass('show').children('.dropdown-menu').removeClass('show');
          loadNavImages(menuItem.find('.shops-banner-image img'));
          menuItem.addClass('show').children('.dropdown-menu').addClass('show');
          menuItem.focus();
        }
      } else {
        menuItem.removeClass('show').children('.dropdown-menu').removeClass('show');

        if (!(menuItem.next().length > 0)) {
          // if this is the last menuItem
          menuItem.parent().parent().find('li > a') // set focus to the first menuitem
          .first().focus();
        } else {
          menuItem.next().children().first().focus();
        }
      }
    },
    39: function _(menuItem) {
      // right
      if (menuItem.hasClass('nav-item')) {
        // top level
        menuItem.removeClass('show').children('.dropdown-menu').removeClass('show');

        if (!isMacDesktop()) {
          $(this).attr('aria-expanded', 'false');
        }

        menuItem.next().children().first().focus();
      } else if (menuItem.hasClass('dropdown')) {
        menuItem.addClass('show').children('.dropdown-menu').addClass('show');

        if (!isMacDesktop()) {
          $(this).attr('aria-expanded', 'true');
        }

        menuItem.find('ul > li > a').first().focus();
      }
    },
    38: function _(menuItem) {
      // up
      if (menuItem.hasClass('nav-item')) {
        // top level
        menuItem.removeClass('show').children('.dropdown-menu').removeClass('show');
      } else if (menuItem.prev().length === 0) {
        // first menuItem
        menuItem.parent().parent().removeClass('show');

        if (!isMacDesktop()) {
          menuItem.parent().parent().children('.nav-link').attr('aria-expanded', 'false');
        }

        menuItem.parent().children().last().children() // set the focus to the last menuItem
        .first().focus();
      } else {
        menuItem.prev().children().first().focus();
      }
    },
    37: function _(menuItem) {
      // left
      if (menuItem.hasClass('nav-item')) {
        // top level
        menuItem.removeClass('show').children('.dropdown-menu').removeClass('show');

        if (!isMacDesktop()) {
          $(this).attr('aria-expanded', 'false');
        }

        menuItem.prev().children().first().focus();
      } else {
        menuItem.closest('.show').removeClass('show').closest('li.show').removeClass('show').children().first().focus();

        if (!isMacDesktop()) {
          menuItem.closest('.show').attr('aria-expanded', 'false');
        }
      }
    },
    27: function _(menuItem) {
      // escape
      var parentMenu = menuItem.hasClass('show') ? menuItem : menuItem.closest('li.show');
      parentMenu.children('.show').removeClass('show');
      parentMenu.removeClass('show');

      if (!isMacDesktop()) {
        parentMenu.children('.nav-link').attr('aria-expanded', 'false');
      }

      parentMenu.children().first().focus();
    }
  }, function () {
    return $(this).parent();
  });
  $(document).on('keyup', '.nav-item', function (e) {
    if (e.keyCode === 9) {
      if (!$(this).find('.dropdown-menu.level-1-sub-cat.show').length) {
        $('.dropdown-menu.level-1-sub-cat.show').removeClass('show');
      }
    }
  }); // mega menu focus close

  $(document).on('click', '.nav-item.dropdown:not(.disabled) [data-toggle="dropdown"]', function (e) {
    if (!isDesktop()) {
      e.preventDefault();
      $('.modal-background').show();
      var hasNoL3s = $(this).parents('.no-L3').length > 0;

      if (hasNoL3s) {
        window.location = this.href;
        return false;
      }

      var eventElement = this;
      var $navItem = $(this).parent('.nav-item');
      var isHasSubcatogy = $navItem.data('sub');
      var isSubcatogyLoaded = $navItem.data('loaded');

      if (isHasSubcatogy && !isSubcatogyLoaded) {
        $navItem.attr('data-loaded', true);
        getSubMenuOnMobile(eventElement, $navItem);
      } else {
        showSubMenuOnMobile(eventElement);
      }
    }
  });
  $('.nav-item.dropdown:not(.disabled) [data-toggle="dropdown"]').on('mouseenter', function () {
    if (isDesktop()) {
      var eventElement = this;
      var $navItem = $(this).parent('.nav-item');
      var isHasSubcatogy = $navItem.data('sub');
      var isSubcatogyLoaded = $navItem.data('loaded');

      if (isHasSubcatogy && !isSubcatogyLoaded) {
        $navItem.attr('data-loaded', true);
        getSubMenuOnDesktop(this, $navItem);
      } else {
        showSubMenuOnDesktop(eventElement);
      }
    }
  }).parent().on('mouseleave', function () {
    if (isDesktop()) {
      $(this).removeClass('show');
      $(this).children('.dropdown-menu').removeClass('show');
    }
  });
  $('.navbar-nav').on('click', '.back, .align-back-btn', function (e) {
    e.preventDefault();
    var contentAssetOnline = $(this).parents('.level-1-sub-cat').find('.content-asset');
    var targetLi;
    var target;

    if ($(this).hasClass('back-menu')) {
      targetLi = $(this).closest('.dropdown-main-menu').children('li');
      target = $(this).closest('.dropdown-main-menu');
    } else {
      targetLi = $(this).parents('.menu-group').children('.navbar-nav').children('li');
      target = $(this).parents('.menu-group').children('.navbar-nav');
    }

    if ($(this).closest('.country-scroll').length > 0 && $(this).closest('.country-scroll').children('li').length <= 5) {
      $(this).parents('.menu-group').addClass('overflow-hidden');
    } else if (target.length > 0 && targetLi.length <= 5 && contentAssetOnline.length === 0) {
      $(this).parents('.menu-group').addClass('overflow-hidden');
    } else {
      $(this).parents('.menu-group').removeClass('overflow-hidden');
      var backTargetCountry = $(this).parents('.country-selector-regions').length > 0 ? $(this).parents('.country-selector-regions') : $(this).parents('.menu-group');

      if (backTargetCountry.length > 0 && backTargetCountry.children('li').length <= 5) {
        $(this).parents('.menu-group').css('overflow', '');
      } else {
        $(this).parents('.menu-group').css('overflow', 'inherit');
      }
    }

    var level3 = $(this).parents('.level-1-sub-cat').children('.navbar-main-menu').children('.dropdown-main-menu').children('.dropdown-item.show').children('.dropdown-menu');

    if (level3.length > 0 && level3) {
      $(this).parents('.level-1-sub-cat').removeClass('overflow-hidden');
      $(this).parents('.menu-group').css('overflow', 'scroll');
    } else {
      $(this).parents('.regions-dropdown').addClass('overflow-auto');
    }

    clearSelection(this);
  });
  $('.nav-item.dropdown').on('mouseenter', function () {
    var $overlay = $('.page-overlay');

    if (!$overlay.length) {
      $overlay = $('<div class="page-overlay"></div>').appendTo('body');
    }

    $overlay.addClass('active');
  }).on('mouseleave', function () {
    $('.page-overlay').removeClass('active');
  });

  var closeHeaderSearch = function closeHeaderSearch() {
    if (isMediumSize() && !$('.search-mobile').hasClass('d-none')) {
      $('.search-icon').closest('.navigation-bar').toggleClass('active-search');
      var mobileSearchIcon = $('.search-icon i');
      var iconSearch = 'mk-search';
      var iconSearchClose = 'mk-close';

      if (mobileSearchIcon.hasClass(iconSearch)) {
        mobileSearchIcon.removeClass(iconSearch).addClass(iconSearchClose);
      } else {
        mobileSearchIcon.removeClass(iconSearchClose).addClass(iconSearch);
      }
    }
  };

  var scrollTop;
  $(document).on('click', '.navbar-toggler', function (e) {
    e.preventDefault();

    if (!$(this).hasClass('open')) {
      scrollTop = $(window).scrollTop();
    }

    $('.webchatStartButtonContainer').css('z-index', 100);
    closeHeaderSearch();
    $('.main-menu').attr('aria-hidden', 'true');
    $('.main-menu').attr('tabindex', '-1');
    var isOpened = $(this).hasClass('open');

    if (isMediumSize()) {
      $('.main-menu').toggleClass('in');
    }

    $('#site-search-mobile').trigger('focusout');

    if (isOpened) {
      $(this).attr('aria-expanded', false);
      $('.navbar-toggler').removeClass('navbar-toggler-menu');
      $('.search-mobile').css('z-index', '1');
      $('.navigation-bar .header').removeAttr('aria-hidden');
      $('.dropdown').removeClass('show');
      $('.modal-background').removeClass('d-block');
      $('.menu-group .nav-item a').attr('aria-hidden', 'true');
      $('.nav-menu, .top-category, .back-menu').detach();
      $(this).removeClass('mouseFocusUnActive open');
      capriCountrySelector.hideContainerForCountrySearch();
      $('.country-search-text-box').val('');
      $('html, body').removeClass('modal-open');
      $(window).scrollTop(scrollTop);

      if ($('.navigation-bar').hasClass('active-search')) {
        $('.search-mobile').toggleClass('d-none');
        $('.menu-group').removeClass('overflow-hidden');
        $('.menu-group').css('overflow', '');
      }

      $('#maincontent').removeAttr('aria-hidden');
      $('#footercontent').removeAttr('aria-hidden');
      $('.search-mobile').removeClass('d-none');
      $('iframe').removeAttr('aria-hidden');
      $('.skip').removeAttr('aria-hidden');
    } else {
      $(this).attr('aria-expanded', true);
      $('.navbar-toggler').addClass('navbar-toggler-menu');
      $('.search-mobile').css('z-index', '1');
      $('.hamburger .navbar-toggler').addClass('open');
      $('.menu-group').removeClass('overflow-hidden');
      $('.menu-group').css('overflow', '');
      $('.modal-background').addClass('d-block');
      $('.menu-group .nav-item a').attr('aria-hidden', 'false');
      $('.search-mobile').addClass('d-none');
      locked = false;
      $('iframe').attr('aria-hidden', 'true');
      $('.skip').attr('aria-hidden', 'true');
      $('.main-menu').removeClass('d-none');
      $('.main-menu').attr('aria-hidden', 'false');
      $('.main-menu').attr('tabindex', '0');
      $('.main-menu').siblings().attr('aria-hidden', 'true');
      $('header').siblings().attr('aria-hidden', 'true');
      $('.main-menu .nav.navbar-nav .nav-link').first().focus();
      $('.shops-banner-image .image-link').attr('aria-hidden', 'false');

      if (isSmallSize()) {
        $('.shops-banner-image .image-link').attr('aria-hidden', 'true');
      }

      $('html, body').addClass('modal-open');
    }
  });
  $('body').on('click', '.modal-background', function () {
    if (isMediumSize()) {
      $('.navbar-header [aria-controls="sg-navbar-collapse"]').trigger('click');
    }
  });
  var headerUser = $('.navbar-header .user');
  keyboardAccessibility(headerUser, {
    40: function _($popover) {
      // down
      $popover.removeClass('active');
      $popover.children('a:focus').closest('li').addClass('active');
      $('.authenticated-user li.active').next().find('a').focus();
    },
    38: function _($popover) {
      // up
      $popover.removeClass('active');
      $popover.children('a:focus').closest('li').addClass('active');
      $('.authenticated-user li.active').prev().find('a').focus();
    },
    27: function _() {
      // escape
      headerUser.find('.popover').removeClass('show');
      $('.user').attr('aria-expanded', 'false');
    }
  }, function () {
    var $popover = $('.user .popover li.nav-item');
    return $popover;
  });
  headerUser.on('mouseenter', function () {
    if (headerUser.find('.popover').length > 0) {
      setTimeout(function () {
        headerUser.find('.popover').addClass('show');
      }, MENUHOVERDELAY);
    }
  });
  $('body').on('mouseover', function (e) {
    if (!headerUser.is(e.target) && headerUser.has(e.target).length === 0) {
      if (headerUser.find('.popover').hasClass('show')) {
        setTimeout(function () {
          headerUser.find('.popover').removeClass('show');
        }, MENUCLOSEDELAY);
      }
    }
  });
  headerUser.on('keydown', function (e) {
    if (e.keyCode === 13) {
      // Enter
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      headerUser.find('.popover').addClass('show');
      $('.user').attr('aria-expanded', 'true');
      headerUser.find('.popover input:first').focus();
    }
  });
  var clickableLinks = ['.authenticated-user a', '.forgot-password-link #password-reset', '.checkout-submit', '.container-checkbox', '.create-btn', '.forgot-password-link #login-forget-password-link', '.loginForm-checkbox'];
  $.each(clickableLinks, function (i, val) {
    headerUser.find(val).on('keydown', function (e) {
      if (e.keyCode === 13) {
        // Enter
        $(this)[0].click();
      }
    });
  });
  $('.navbar-header .right-nav').on('keyup', function (e) {
    var key = e.which;

    if (key === 9) {
      // tab
      if (!headerUser.is(e.target) && headerUser.has(e.target).length === 0) {
        if (headerUser.find('.popover').hasClass('show')) {
          headerUser.find('.popover').removeClass('show');
          $('.user').attr('aria-expanded', 'false');
        }
      }
    }
  });
  $('body').on('click', '#myaccount', function () {
    event.preventDefault();
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/miniCart.js":
/*!*****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/miniCart.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var cartHelper = __webpack_require__(/*! ../cart/cartHelpers */ "./cartridges/app_mk_storefront/cartridge/client/default/js/cart/cartHelpers.js");

var updateMiniCart = true;

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isDesktop = $(window).width() >= SCREENSIZE.DESKTOPMIN;

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var keyboardAccessibility = __webpack_require__(/*! ./keyboardAccessibility */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/keyboardAccessibility.js");

var isCartPage = $('.cart-page, .cart-empty').length > 0;
var isCheckoutPage = $('.checkout-header').length > 0;
var $miniCart = $('.navbar-header .minicart');

var MENUCLOSEDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").MENUCLOSEDELAY);

var MENUHOVERDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").MENUHOVERDELAY);

module.exports = function () {
  cartHelper();
  $('.minicart').on('count:update', function (event, count) {
    if (count && $.isNumeric(count.quantityTotal)) {
      $('.minicart .minicart-quantity').text(count.quantityTotal).removeClass('invisible');
      $('.minicart .minicart-link').attr({
        'aria-label': count.cart.resources.minicartCountOfItems,
        title: count.cart.resources.minicartCountOfItems
      });
    }
  });
  $('.minicart').on('minicart:remove', function (event, isProductRemoved, timeout, minicartCountOfItems) {
    var currentEventListenerRemove = isProductRemoved !== null && isProductRemoved !== undefined ? isProductRemoved : false;
    var timeOutInMilliSec = timeout !== null && timeout !== undefined ? timeout : 4000; // Default value should be 4000

    var url = $('.minicart').data('action-url');

    if (!updateMiniCart) {
      $('.minicart .popover').addClass('show');
      return;
    }

    if (minicartCountOfItems) {
      $('.minicart .minicart-link').attr({
        'aria-label': minicartCountOfItems,
        title: minicartCountOfItems
      });
    }

    $('.popover .minicart-products').spinner().start();
    $.get(url, function (data) {
      $('.minicart .popover').empty();
      $('.minicart .popover').append(data);
      var isPaypalEnabled = !!($('#paypal_enabled').length > 0 && document.getElementById('paypal_enabled').value === 'true');

      if (isPaypalEnabled) {
        // eslint-disable-next-line no-undef
        paypalhelper.paypalMini();
      }

      if (currentEventListenerRemove) {
        $('.toast-remove').removeClass('d-none');
        $('.toast-success').addClass('d-none');
        clientSideUtil.clearAndSetTime('.toast-basket-alert.toast-remove', timeOutInMilliSec);
      }

      $('.popover .popover-overlay').on('touchstart click', function () {
        $(this).closest('.minicart .popover').removeClass('show');
      });
      updateMiniCart = false;
      $('.popover .minicart-products').spinner().stop();
    });
  });
  $('.minicart').on('minicart:update', function (event, isProductAdded, timeout, updated) {
    var currentEventListener = isProductAdded !== null && isProductAdded !== undefined && (updated === null || updated === undefined || !updated) ? isProductAdded : false;
    var updatedEvent = updated !== null && updated !== undefined ? updated : false;
    var timeOutInMilliSec = timeout !== null && timeout !== undefined ? timeout : 4000; // Default value should be 4000

    var url = $('.minicart').data('action-url');

    if (!updateMiniCart) {
      setTimeout(function () {
        $('.minicart .popover').addClass('show');
      }, MENUHOVERDELAY);
      return;
    }

    $('.minicart .popover').addClass('show');
    $('.popover .minicart-products').spinner().start();
    $.get(url, function (data) {
      $('.minicart .popover').empty();
      $('.minicart .popover').append(data);
      $('#mkCloseMinicart').focus();
      var isPaypalEnabled = !!($('#paypal_enabled').length > 0 && document.getElementById('paypal_enabled').value === 'true');

      if (isPaypalEnabled) {
        // eslint-disable-next-line no-undef
        paypalhelper.paypalMini();
      }

      if (currentEventListener) {
        $('.toast-remove').addClass('d-none');
        $('.toast-success').removeClass('d-none');
        clientSideUtil.clearAndSetTime('.toast-basket-alert.toast-success', timeOutInMilliSec);
      }

      if (updatedEvent) {
        $('.toast-success').addClass('d-none');
        $('.toast-edit').removeClass('d-none');
        clientSideUtil.clearAndSetTime('.toast-basket-alert.toast-edit', timeOutInMilliSec);
      }

      $('.popover .popover-overlay').on('touchstart click', function () {
        $(this).closest('.minicart .popover').removeClass('show');
      });
      updateMiniCart = false;
      $('.popover .minicart-products').spinner().stop();
    });
  });
  $('.minicart-total').on('mouseenter touchstart', function () {
    var $activeLink = $(this).find('.minicart-link');

    if (!isDesktop && isCheckoutPage) {
      $activeLink[0].click();
    } else if (isDesktop && isCheckoutPage) {
      $('.minicart-link .mk-shopping-bag').addClass('disable');
    } else if (isDesktop && !isCartPage) {
      $('.minicart').trigger('minicart:update');
    } else if (!isDesktop && !isCartPage) {
      $activeLink[0].click();
    } else {
      $('.minicart-link .mk-shopping-bag').addClass('disable');
      $('.minicart-link').addClass('disable');
    }
  });
  $('.minicart-link').on('keydown', function (e) {
    if (e.keyCode === 13) {
      // Enter
      if (isCartPage) {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
      } else if (isDesktop && isCheckoutPage) {
        var $activeLink = $(this).find('.minicart-link');
        $activeLink[0].click();
      } else {
        e.preventDefault();
        e.stopPropagation();
        e.stopImmediatePropagation();
        $('.minicart').trigger('minicart:update', [false, 0]);
        $miniCart.attr('aria-expanded', 'true');
        $('.minicart').find('.popover a').first().addClass('active-selector').focus();
      }
    }
  });
  var $currentElm;
  var activeIndex;
  var nextIndex;
  keyboardAccessibility($miniCart, {
    40: function _($popover) {
      // down
      $currentElm = $popover.find('a.active-selector');
      activeIndex = $popover.find('a').index($currentElm);

      if ($popover.find('a').length - 1 >= activeIndex + 1) {
        nextIndex = $popover.find('a')[activeIndex + 1];
        $popover.find('a').removeClass('active-selector');
        $(nextIndex).addClass('active-selector').focus();
      } else {
        $popover.removeClass('show');
      }
    },
    38: function _($popover) {
      // up
      $currentElm = $popover.find('a.active-selector');
      activeIndex = $popover.find('a').index($currentElm);

      if (activeIndex - 1 >= 0) {
        nextIndex = $popover.find('a')[activeIndex - 1];
        $popover.find('a').removeClass('active-selector');
        $(nextIndex).addClass('active-selector').focus();
      } else {
        $popover.removeClass('show');
      }
    },
    27: function _($popover) {
      // escape
      $popover.removeClass('show');
      $miniCart.attr('aria-expanded', 'false');
    }
  }, function () {
    var $popover = $('.minicart .popover');
    return $popover;
  });
  $('.header').on('keyup', function (e) {
    var key = e.which;

    if (key === 9) {
      // tab
      if (!$miniCart.is(e.target) && $miniCart.has(e.target).length === 0) {
        if ($miniCart.find('.popover').hasClass('show')) {
          $miniCart.find('.popover').removeClass('show');
          $miniCart.attr('aria-expanded', 'false');
        }
      }
    }
  });
  $('body').on('touchstart click', function (e) {
    if ($('.minicart').has(e.target).length <= 0) {
      setTimeout(function () {
        $('.minicart .popover').removeClass('show');
      }, MENUCLOSEDELAY);
    }
  });
  $('.minicart').on('mouseleave', function (event) {
    if (event.type === 'focusout' && $('.minicart .popover').has(event.target).length > 0 || event.type === 'mouseleave' && $(event.target).is('.minicart .quantity') || $('body').hasClass('modal-open')) {
      event.stopPropagation();
      return;
    }

    setTimeout(function () {
      $('.minicart .popover').removeClass('show');
    }, MENUCLOSEDELAY);
  });
  $('body').on('change', '.minicart .quantity', function () {
    if ($(this).parents('.bonus-product-line-item').length && $('.cart-page').length) {
      location.reload();
    }
  });
  $('body').on('product:afterAddToCart', function () {
    updateMiniCart = true;
    $('.attributes').on('keydown', function (e) {
      if (e.which === 9) {
        if ($('.minicart .popover').hasClass('show')) {
          $('.minicart .popover').removeClass('show');
        }
      }
    });
  });
  $('body').on('cart:update', function () {
    updateMiniCart = true;
  });
};

$(document).on('click', '.mk-close-minicart', function () {
  $('.minicart .popover-bottom').removeClass('show');
});

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/modal.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/modal.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * Generates the modal window on the first call.
 * @param {string} selector - Modal id and ada label
 * @param {string} containerClass - Modal conatiner class
 * @param {boolean} modalFooter - Display modal footer
 */


function getModalHtmlElement(selector, containerClass, modalFooter) {
  if ($('#' + selector).length !== 0) {
    $('#' + selector).remove();
  }

  var footerClass = modalFooter ? '' : 'd-none';
  var htmlString = '<!-- Modal -->' + '<div class="modal fade" id="' + selector + '" tabindex="-1" role="dialog" aria-labelledby="' + selector + '">' + '<div class="modal-dialog ' + containerClass + '">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<div class="modal-header border-0">' + '    <button type="button" class="close pull-right m-0 p-0" data-dismiss="modal" aria-label="Close">' + '        <span class="sr-only">close</span>' + '    </button>' + '</div>' + '<div class="modal-body text-center"></div>' + '<div class="modal-footer ' + footerClass + '"></div>' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
 * @param {selector} form current form
 * @param {string} selectedValueUrl passing an route url
 * @param {string} modalSelector - Modal id and ada label
 * Ajax call for post method
 * serialize the form data
 * Filling the responce after preparing the modal
 */


function fillModalElement(form, selectedValueUrl, modalSelector) {
  var $elementID = $('#' + modalSelector);
  $elementID.find('.modal-body').spinner().start();
  $.ajax({
    url: selectedValueUrl,
    type: 'post',
    dataType: 'json',
    data: form.serialize(),
    success: function success(data) {
      if (data.success) {
        $elementID.find('.modal-body').empty().html(DOMpurify.sanitize(data.renderedTemplate));
        $elementID.modal('show');

        if (modalSelector === 'newsLetterModal') {
          $('body').trigger('event:newslettersignup', data.eventData);
        }
      } else {
        $elementID.modal('hide');

        if (data.message) {
          var validationMessage = data.message;
          $(form).find('.form-group').addClass('is-invalid').find('.invalid-feedback').text(validationMessage);
        }
      }

      $.spinner().stop();
    },
    error: function error() {
      $.spinner().stop();
    }
  });
}

module.exports = {
  getModalHtmlElement: getModalHtmlElement,
  fillModalElement: fillModalElement
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/notifyMe.js":
/*!*****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/notifyMe.js ***!
  \*****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


module.exports = {
  submitRecaptchaNotifyMe: function submitRecaptchaNotifyMe() {
    $('body').off('click', '#notifyme-btn');
    $('body').off('submit', '#notifyme-form');
    $('body').on('click', '#notifyme-btn', function (e) {
      e.preventDefault();
      $('#notifyme-btn').addClass('disabled');
      var form = $('#notifyme-form');
      var formData = form.serialize();
      var url = form.attr('action');
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: formData,
        success: function success(data) {
          var formHelpers = __webpack_require__(/*! ../checkout/formErrors */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js");

          if (data.fields && data.fields.length) {
            data.fields.forEach(function (error) {
              if (Object.keys(error).length) {
                formHelpers.loadFormErrors('#notifyme-form', error);
              }
            });
            $('#notifyme-btn').removeClass('disabled');
            return;
          }

          if (!$('.notifyme-content').find('.g-recaptcha').length > 0) {
            form.submit();
          }
        },
        error: function error() {
          $('#notifyme-btn').removeClass('disabled');
        }
      });
    }).on('submit', '#notifyme-form', function (e) {
      e.preventDefault();
      $('#notifyme-btn').addClass('disabled');
      var formSubmittedMessage = $('.done-content');
      var form = $('#notifyme-form');
      var formData = form.serialize();
      var url = form.attr('action');
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: formData,
        success: function success(data) {
          form.find('.invalid-feedback').html('');
          formSubmittedMessage.removeClass('d-none');
          form.replaceWith(formSubmittedMessage.val());
          $('body').trigger('event:notifyMeEventOnSuccess', data);
          $('#notifyme-btn').removeClass('disabled');
        },
        error: function error() {
          $('#notifyme-btn').removeClass('disabled');
        }
      });
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js":
/*!**********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/scrollAnimate.js ***!
  \**********************************************************************************************/
/***/ (function(module) {

"use strict";

/**
 * @param  {object} target element to scroll into view
 * @param  {Boolean} ignoreInView Flag that ignores if element is already in view
 * @param  {Boolean} scrollToBottom Flag that scrolls to the bottom of the element instead of top
 */

module.exports = function (target, ignoreInView, scrollToBottom) {
  var position = target && target.length ? target.offset().top : 0;
  var isScrollable = true;

  if (target && target.length && target.isInViewport()) {
    isScrollable = false;
  }

  if (ignoreInView) {
    isScrollable = true;
  }

  if (scrollToBottom) {
    position = target && target.length ? target.outerHeight() + target.offset().top - window.innerHeight : 0;
  }

  if (isScrollable) {
    $('html, body').animate({
      scrollTop: position
    }, 500);

    if (!target) {
      $('a.logo-home').focus();
    }
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/search.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/search.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var debounce = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isDesktop = $(window).width() > SCREENSIZE.DESKTOPMIN;
var endpoint = $('.suggestions-wrapper').data('url');
var bodyOverlay = $('.modal-background');
var minChars = 1;
var UP_KEY = 38;
var DOWN_KEY = 40;
var DIRECTION_DOWN = 1;
var DIRECTION_UP = -1;
var $searchInput = $('input.search-field');
var $searchButton = $('button.mk-search');
/**
 * Retrieves Suggestions element relative to scope
 *
 * @param {Object} scope - Search input field DOM element
 * @return {JQuery} - .suggestions-wrapper element
 */

function getSuggestionsWrapper() {
  return $('.suggestions-wrapper');
}
/**
 * Rto make Search Bar sticky on mobile on scroll
 */


function stickyMobileSearchBar() {
  var $searchMobile = $('.search-mobile');
  var lastScrollTop = 0;
  $(window).scroll(function () {
    var currentScroll = $(this).scrollTop();

    if (!(currentScroll > lastScrollTop && currentScroll !== 0 || window.scrollY + window.innerHeight >= document.body.scrollHeight)) {
      $searchMobile.removeClass('scroll-down').addClass('scroll-up');
    }

    lastScrollTop = currentScroll;
  });
}
/**
 * Determines whether DOM element is inside the .search-mobile class
 *
 * @param {Object} scope - DOM element, usually the input.search-field element
 * @return {boolean} - Whether DOM element is inside  div.search-mobile
 */


function isMobileSearch(scope) {
  return !!$(scope).closest('.search-mobile').length;
}
/**
 * Remove modal classes needed for mobile suggestions
 *
 */


function clearModals() {
  $('.suggestions').removeClass('modal');
  $('.popular-suggestions-wrapper').removeClass('d-none');
}
/**
 * Apply modal classes needed for mobile suggestions
 *
 * @param {Object} scope - Search input field DOM element
 */


function applyModals(scope) {
  if (isMobileSearch(scope)) {
    $('header').siblings().attr('aria-hidden', 'true');
    getSuggestionsWrapper(scope).find('.suggestions').addClass('modal');
  }
}
/**
 * Tear down Suggestions panel
 */


function tearDownSuggestions() {
  $searchInput.val('');

  if (isDesktop) {
    clearModals();
  }

  $('.search-mobile .suggestions').unbind('scroll');
  $('.suggestions-wrapper').empty();
  $('.site-search .clear-button').addClass('d-none');
  bodyOverlay.hide();
}
/*
 * Toggle search field icon from search to close and vice-versa
 *
 * @param {string} action - Action to toggle to
 */

/**
 * Determines whether the "More Content Below" icon should be displayed
 *
 * @param {Object} scope - DOM element, usually the input.search-field element
 */


function handleMoreContentBelowIcon(scope) {
  if ($(scope).scrollTop() + $(scope).innerHeight() >= $(scope)[0].scrollHeight) {
    $('.more-below').fadeOut();
  } else {
    $('.more-below').fadeIn();
  }
}
/**
 * Positions Suggestions panel on page
 *
 * @param {Object} scope - DOM element, usually the input.search-field element
 */


function positionSuggestions(scope) {
  var outerHeight;
  var $scope;
  var $suggestions;
  var top;

  if (isMobileSearch(scope)) {
    $scope = $(scope);
    top = $scope.offset().top;
    outerHeight = $scope.outerHeight();
    $suggestions = getSuggestionsWrapper(scope).find('.suggestions');
    $suggestions.css('top', top + outerHeight);
    handleMoreContentBelowIcon(scope); // Unfortunately, we have to bind this dynamically, as the live scroll event was not
    // properly detecting dynamic suggestions element's scroll event

    $suggestions.scroll(function () {
      handleMoreContentBelowIcon(this);
    });
  }
}
/**
 * Process Ajax response for SearchServices-GetSuggestions
 *
 * @param {Object|string} response - Empty object literal if null response or string with rendered
 *                                   suggestions template contents
 */


function processResponse(response) {
  $('.popular-suggestions-wrapper').addClass('d-none');
  var $suggestionsWrapper = getSuggestionsWrapper(this).empty();

  if (_typeof(response) !== 'object') {
    $suggestionsWrapper.append(response).show();
    bodyOverlay.show();
    positionSuggestions(this);

    if (isMobileSearch(this)) {
      applyModals(this);
    } // Trigger screen reader by setting aria-describedby with the new suggestion message.


    var suggestionsList = $('.suggestions .item, .suggestions-wrapper_content .item');

    if ($(suggestionsList).length) {
      $searchInput.attr('aria-describedby', 'search-result-count');
    } else {
      $searchInput.removeAttr('aria-describedby');
    }
  } else {
    $suggestionsWrapper.hide();
    $('.popular-suggestions-wrapper').removeClass('d-none');
    bodyOverlay.hide();
  }
}
/**
 * Retrieve suggestions
 *
 * @param {Object} scope - Search field DOM element
 */


function getSuggestions(scope) {
  if ($(scope).val().length >= minChars) {
    $.ajax({
      context: scope,
      url: endpoint + encodeURIComponent($(scope).val()),
      method: 'GET',
      success: processResponse
    });
  } else {
    clearModals();
    getSuggestionsWrapper(scope).empty();
    $('.popular-suggestions-wrapper').removeClass('d-none');
  }
}
/**
 * Handle Search Suggestion Keyboard Arrow Keys
 *
 * @param {Integer} direction takes positive or negative number constant, DIRECTION_UP (-1) or DIRECTION_DOWN (+1)
 */


function handleArrow(direction) {
  // get all li elements in the suggestions list
  var suggestionsList = $('.suggestions .item, .suggestions-wrapper_content .item');

  if (suggestionsList.filter('.selected').length === 0) {
    suggestionsList.first().addClass('selected');
    $searchInput.each(function () {
      $(this).attr('aria-activedescendant', suggestionsList.first()[0].id);
    });
  } else {
    suggestionsList.each(function (index) {
      var idx = index + direction;

      if ($(this).hasClass('selected')) {
        $(this).removeClass('selected');
        $(this).removeAttr('aria-selected');

        if (suggestionsList.eq(idx).length !== 0) {
          suggestionsList.eq(idx).addClass('selected');
          suggestionsList.eq(idx).attr('aria-selected', true);
          $(this).removeProp('aria-selected');
          $searchInput.each(function () {
            $(this).attr('aria-activedescendant', suggestionsList.eq(idx)[0].id);
          });
        } else {
          suggestionsList.first().addClass('selected');
          suggestionsList.first().attr('aria-selected', true);
          $searchInput.each(function () {
            $(this).attr('aria-activedescendant', suggestionsList.first()[0].id);
          });
        }

        return false;
      }

      return true;
    });
  }
}
/**
 *
 * @description Disables search if search field is empty
**/


function handleSearchSubmitState() {
  $searchInput.on('keyup', function () {
    $searchButton.attr('aria-disabled', $(this).val().length === 0);
  });
}
/**
 * Clears the value in the search input field
**/


function clearSearchField() {
  $('.site-search .clear-button').on('click touchstart', function (e) {
    e.preventDefault();
    $searchInput.val('');
    clearModals();
    $('.search-mobile .suggestions').unbind('scroll');
    $('.suggestions-wrapper').empty();
    $('.site-search .clear-button').addClass('d-none');
  });
  $('.site-search .research-clear-button').on('click', function () {
    $('.nosearch-page-search-field').val('');
    $('.site-search .research-clear-button').addClass('d-none');
    $('.research-field-placeholder').show();
  });
  $('.site-search .mk-close').on('click', function () {
    $('.popular-suggestions-wrapper').removeClass('d-none');
    $(this).attr('placeholder', 'Search');
    $('.modal-background').addClass('d-none');
    tearDownSuggestions();
  });
  $('.search-field').on('input', function () {
    if ($(this).val().length > 0) {
      $('.site-search .clear-button').removeClass('d-none');
    } else {
      $('.site-search .clear-button').addClass('d-none');
    }
  });
  $('.nosearch-page-search-field').on('input', function () {
    if ($(this).val().length > 0) {
      $('.site-search .research-clear-button').removeClass('d-none');
    } else {
      $('.site-search .research-clear-button').addClass('d-none');
    }
  });
}

module.exports = function () {
  var toggleSuggestionIcon = function toggleSuggestionIcon() {
    var mobileSearchIcon = $('.search-icon i');
    var iconSearch = 'mk-search';
    var iconSearchClose = 'mk-close';

    if (mobileSearchIcon.hasClass(iconSearch)) {
      mobileSearchIcon.removeClass(iconSearch).addClass(iconSearchClose);
    } else {
      mobileSearchIcon.removeClass(iconSearchClose).addClass(iconSearch);
    }
  };

  clearSearchField();
  handleSearchSubmitState();
  stickyMobileSearchBar();
  $($('#research-field').parents('#maincontent')[0]).removeAttr('role');
  $(document).on('click', '.search-icon', function (e) {
    e.stopPropagation();
    var $this = $(this);
    $this.siblings('.header-syte-search').addClass('d-none');
    var placeholder = $this.siblings('.search-field-container').find('#site-search-desktop').attr('placeholder-focusin');
    $this.siblings('.search-field-container').find('#site-search-desktop').attr('placeholder', placeholder);
    $this.parent('.right-nav').find('.header-syte-search').addClass('d-none');

    if (isDesktop) {
      $this.addClass('d-none');

      if (isDesktop) {
        $this.closest('.right-nav').find('.site-search .mk-search').addClass('d-none');
      }

      $('.search-field-container').removeClass('d-none');
      $('.syte-intro-popup').addClass('d-none');
      $('.search-field').removeClass('fade-out');
      $('.search-field').addClass('fade-in').focus();
    } else {
      var $body = $('body');

      if ($('.navbar-toggler').hasClass('open')) {
        $('.navbar-header [aria-controls="sg-navbar-collapse"]').trigger('click');
      }

      $('.search-mobile').find('.search-field').focus();
      $('.search-mobile').find('.search-field').attr('aria-expanded', function (_, attr) {
        return attr !== 'true';
      });
      $this.closest('.navigation-bar').toggleClass('active-search');
      toggleSuggestionIcon();

      if ($('.navigation-bar').hasClass('active-search')) {
        $('header').siblings().attr('aria-hidden', 'true');
        $body.addClass('overflow-hidden body-fixed');
      } else {
        $('header').siblings().removeAttr('aria-hidden');
        $body.removeClass('overflow-hidden body-fixed');
      }
    }

    sessionStorage.setItem('productFromSearch', true);
  });
  $('form[name="simpleSearch"]').submit(function (e) {
    $('body').trigger('event:keywordSearch');
    var suggestionsList = $('.suggestions .item, .suggestions-wrapper_content .item');

    if (suggestionsList.filter('.selected').length !== 0) {
      e.preventDefault();
      suggestionsList.filter('.selected').find('a')[0].click();
    }
  });
  $(document).off('click', '#site-search-mobile').on('click', '#site-search-mobile', function () {
    var $this = $(this);
    var placeholder = $this.attr('placeholder-focusin');
    $this.attr('placeholder', placeholder);
    $this.closest('.site-search').find('.syte-intro-popup').addClass('d-none');
    $this.closest('.site-search').siblings('.popular-suggestions-wrapper').removeClass('d-none');
    $this.closest('.site-search').siblings('.suggestions-wrapper').removeClass('d-none');
    $('.mk-search').addClass('d-none');
    $this.siblings('.mk-close').removeClass('d-none');
    $('body').addClass('overflow-hidden');
    $('.modal-background').addClass('d-none');
    $this.closest('.site-search').siblings('.popular-suggestions-wrapper').css('height', '100vh');
    $this.closest('.site-search').siblings('.suggestions-wrapper').css('height', '100vh');
  });
  $searchInput.each(function () {
    /**
         * Use debounce to avoid making an Ajax call on every single key press by waiting a few
         * hundred milliseconds before making the request. Without debounce, the user sees the
         * browser blink with every key press.
         */
    var debounceSuggestions = debounce(getSuggestions, 300);
    $(this).on('keyup focus', function (e) {
      // Capture Down/Up Arrow Key Events
      switch (e.which) {
        case DOWN_KEY:
          handleArrow(DIRECTION_DOWN);
          e.preventDefault(); // prevent moving the cursor

          break;

        case UP_KEY:
          handleArrow(DIRECTION_UP);
          e.preventDefault(); // prevent moving the cursor

          break;

        default:
          debounceSuggestions(this, e);
      }

      if ($(this).val() === '') {
        bodyOverlay.hide();
      }
    });
  });
  /**
   * Close Search Field Flyout
  **/

  function hideSearchField() {
    $('.search-icon').removeClass('d-none');
    $('.search-field').addClass('fade-out');
    $('.search-field').removeClass('fade-in');
    $('.search-field-container').addClass('d-none');
    $('.header-syte-search').removeClass('d-none');
    bodyOverlay.hide();
    sessionStorage.removeItem('productFromSearch');
  }

  $(document).off('click', '.site-search .reset-button').on('click', '.site-search .reset-button', function () {
    $(this).removeClass('d-sm-block');
    $(this).closest('.right-nav').find('.header-syte-search').removeClass('d-none');
    $(this).closest('.right-nav').find('.header-syte-search').find('.syte-camera-icon').removeClass('d-none');
    tearDownSuggestions();
    hideSearchField();
    $('.syte-camera-icon').removeClass('d-none');
    var placeholder = $('#site-search-mobile').attr('placeholder-focusout');
    $('#site-search-mobile').attr('placeholder', placeholder);
    $(this).closest('.site-search').siblings('.suggestions-wrapper').css('height', 'auto');
    $('body').removeClass('overflow-hidden');
    $('#site-search-mobile').siblings('.mk-close').addClass('d-none');
    $('.mk-search').removeClass('d-none');
    $('.popular-suggestions-wrapper').addClass('d-none');
  });
  $(document).mouseup(function (e) {
    var searchWrapper = getSuggestionsWrapper();
    var searchField = $('.search-field-section'); // if the target of the click isn't the container nor a descendant of the container

    if (!searchWrapper.is(e.target) && searchWrapper.has(e.target).length === 0 && !searchField.is(e.target) && searchField.has(e.target).length === 0) {
      tearDownSuggestions();

      if (!$('.search-field-container.search-field-section').hasClass('d-none')) {
        hideSearchField();
      }
    }
  });
  $(document).on('click', '.product-detail-breadcrumb-check a, .header .search-icon', function () {
    localStorage.removeItem('isNavigatedFromSearchresults');
  });
  $(document).on('keypress, keyup', '.search-field-container .search-field', function (e) {
    var searchValue = $searchInput.val();

    if (searchValue) {
      localStorage.setItem('isSearchfieldValue', searchValue);
    } else {
      localStorage.setItem('isSearchfieldValue', '');
    }

    if (e.which === 13) {
      localStorage.removeItem('isNavigatedFromSearchresults');
    }
  });
  $(document).on('click', '.suggestions-wrapper_cat .product .product-tile a', function () {
    localStorage.setItem('isSearchResult', true);

    if (localStorage.getItem('isSearchfieldValue')) {
      localStorage.removeItem('isSearchfieldValue');
    }
  });
  $(document).on('click', '.suggestions-wrapper_cat .product .search-product-tile a', function () {
    localStorage.setItem('isSearchResult', true);
  });
  $(document).on('click', '.suggestions-wrapper_cat .default-suggestions a', function () {
    if (localStorage.getItem('isSearchfieldValue')) {
      localStorage.removeItem('isSearchfieldValue');
    }
  }); // Hide search popup if traversed out of menu

  var $searchBlock = $('.navbar-header .search-field-container');
  $('.header').on('keyup', function (e) {
    var key = e.which;

    if (key === 9) {
      // tab
      if (!$searchBlock.is(e.target) && $searchBlock.has(e.target).length === 0) {
        if (!$searchBlock.hasClass('d-none')) {
          $searchBlock.addClass('d-none');
          $('.search-icon').removeClass('d-none');
        }
      }
    }
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/spinner.js":
/*!****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/spinner.js ***!
  \****************************************************************************************/
/***/ (function() {

"use strict";

/**
 * Show a spinner inside a given element
 * @param {element} $target - Element to block by the veil and spinner.
 *                            Pass body to block the whole page.
 */

function addSpinner($target) {
  var $veil = $('<div class="veil"><div class="underlay" aria-label="Page loading"></div></div>');
  $veil.append('<div class="spinner d-flex align-items-center justify-content-center"><i class="brandLogo-MK"></i></div>');

  if ($target.get(0).tagName === 'IMG') {
    $target.after($veil);
    $veil.css({
      width: $target.width(),
      height: $target.height()
    });

    if ($target.parent().css('position') === 'static') {
      $target.parent().css('position', 'relative');
    }
  } else {
    $target.append($veil);

    if ($target.css('position') === 'static') {
      $target.parent().css('position', 'relative');
      $target.parent().addClass('veiled');
    }

    if ($target.get(0).tagName === 'BODY') {
      $veil.find('.spinner').css('position', 'fixed');
    }
  }

  $('.underlay').attr('role', 'alert');
  $veil.click(function (e) {
    setTimeout(function () {
      $('.underlay').removeAttr('role');
    }, 2000);
    e.stopPropagation();
  });
}
/**
 * Remove existing spinner
 * @param  {element} $veil - jQuery pointer to the veil element
 */


function removeSpinner($veil) {
  if ($veil.parent().hasClass('veiled')) {
    $veil.parent().css('position', '');
    $veil.parent().removeClass('veiled');
  }

  $veil.off('click');
  $veil.remove();
} // element level spinner:


$.fn.spinner = function () {
  var $element = $(this);

  var Fn = function Fn() {
    this.start = function () {
      if ($element.length) {
        addSpinner($element);
      }
    };

    this.stop = function () {
      if ($element.length) {
        var $veil = $('.veil');
        removeSpinner($veil);
      }
    };
  };

  return new Fn();
}; // page-level spinner:


$.spinner = function () {
  var Fn = function Fn() {
    this.start = function () {
      addSpinner($('body'));
    };

    this.stop = function () {
      removeSpinner($('.veil'));
    };
  };

  return new Fn();
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/toolTip.js":
/*!****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/components/toolTip.js ***!
  \****************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = function () {
  $(document).on('mouseenter focusin', '.info-icon', function () {
    $(this).find('.tooltip').removeClass('d-none');
  });
  $(document).on('mouseleave focusout blur', '.info-icon', function () {
    $(this).find('.tooltip').addClass('d-none');
  });
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/csrfHelper.js":
/*!********************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/csrfHelper.js ***!
  \********************************************************************************/
/***/ (function() {

"use strict";

/**
* Inserting CSRF tokken value to Form
* @param {json} csrfJson this holds json value for CSRF
* @param {Object} form Form
*/

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function insertCSRFForm(csrfJson, form) {
  var csrfName = csrfJson.csrf.tokenName;
  var csrfValue = csrfJson.csrf.token;
  var inputfield = '<input type="hidden" name="' + csrfName + '" value="' + csrfValue + '"/>';
  $(form).find('input[name="csrf_token"]').detach();
  $(form).append(inputfield);
}
/**
* Ajax call to generate CSRF token
* @param {string} targetUrl ajax url
* @param {Object} form Form
*/


function generateCSRFForm(targetUrl, form) {
  $.ajax({
    url: targetUrl,
    type: 'post',
    context: document.body,
    dataType: 'json',
    success: function success(data) {
      insertCSRFForm(data, form);
    }
  });
}

var csrfTokenDiv = $('.client-csrf-token-generation-js');
var targetUrl = csrfTokenDiv.data('ajax-url');
var forms = $('.client-csrf-token-generation-js').find('form');

var _iterator = _createForOfIteratorHelper(forms),
    _step;

try {
  for (_iterator.s(); !(_step = _iterator.n()).done;) {
    var form = _step.value;
    $('body').on('focus', '#' + form.id, function () {
      generateCSRFForm(targetUrl, $(this));
    });
  }
} catch (err) {
  _iterator.e(err);
} finally {
  _iterator.f();
}

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/login/accountLogin.js":
/*!****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/login/accountLogin.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var formValidation = __webpack_require__(/*! ../components/formValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/formValidation.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js"); // Hide Previous Form error when field level error messages displayed after Sign In is clicked


$('.js-user-sign-in').on('click', function () {
  if ($('.popover').find('.form-control.is-invalid')) {
    $('.alert-danger').addClass('d-none');
  }
});
module.exports = {
  login: function login() {
    $('form.login').submit(function (e) {
      var form = $(this);
      e.preventDefault();
      var url = form.attr('action');
      var popover = form.parents('.popover');
      popover.spinner().start();
      $('form.login').trigger('login:submit', e);
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: form.serialize(),
        success: function success(data) {
          popover.spinner().stop();

          if (!data.success) {
            formValidation(form, data);
            $('form.login').trigger('login:error', data);
          } else {
            $('form.login').trigger('login:success', data);
            $('body').trigger('event:dyUserTypeItemSave', data.userTypeForDY);

            if ($('#homePageRedirectOnLogin').length > 0) {
              location.href = $('#homePageRedirectOnLogin').data('action-url');
            } else {
              location.href = DOMpurify.sanitize(window.location.href);
            }

            $('body').trigger('event:signInSuccess', data);
          }
        },
        error: function error(data) {
          if (data.responseJSON.redirectUrl) {
            window.location.href = data.responseJSON.redirectUrl;
          } else {
            $('form.login').trigger('login:error', data);
            popover.spinner().stop();
          }
        }
      });
      return false;
    });
  },
  syncCheckboxes: function syncCheckboxes() {
    var rememberMeCheckboxes = $('input[name="loginRememberMe"]');
    rememberMeCheckboxes.on('change', function (event) {
      rememberMeCheckboxes.prop('checked', event.target.checked);
    });
  },
  enterLoginForm: function enterLoginForm() {
    $(document).on('keypress, keyup', '#login-form input.form-control', function (e) {
      if (e.which === 13) {
        $('form.login').submit();
      }
    });
  },
  togglePassword: function togglePassword() {
    $(document).on('click', '.toggle-password', function () {
      var $this = $(this);
      var loginPassword = $this.siblings('.login-password');

      if (loginPassword.attr('type') === 'password') {
        loginPassword.attr('type', 'text');
        $this.addClass('d-none');
        $this.siblings('.toggle-password-show').removeClass('d-none');
      } else {
        loginPassword.attr('type', 'password');
        $this.addClass('d-none');
        $this.siblings('.toggle-password-hide').removeClass('d-none');
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js":
/*!**********************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js ***!
  \**********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var productImages = __webpack_require__(/*! ../product/productImages */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/productImages.js");

var productSetImages = __webpack_require__(/*! ../product/productSet */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/productSet.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var updateFavorites = (__webpack_require__(/*! ./favorites */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/favorites.js").updateFavorites);

var bvHelper = __webpack_require__(/*! int_bazaarvoice_sfra_custom/product/bvHelper */ "../../capri-core-sfcc/src/integrations/link_bazaarvoice-release-20.1.0/cartridges/int_bazaarvoice_sfra_custom/cartridge/client/default/js/product/bvHelper.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");

var sizeGuideTabs = __webpack_require__(/*! ../product/localizeSizeLabels */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/localizeSizeLabels.js");
/**
 * Retrieves the relevant pid value
 * @param {jquery} $el - DOM container for a given add to cart button
 * @return {string} - value to be used when adding product to cart
 */


function getPidValue($el) {
  var pid;

  if ($('#quickViewModal').hasClass('show') && !$('.product-set').length) {
    pid = $($el).closest('.modal-content').find('.product-quickview').data('pid');
  } else if ($('#inStoreInventoryModal').hasClass('show')) {
    pid = $($el).data('pid');
  } else if ($('.product-set-detail').length || $('.product-set').length) {
    pid = $($el).closest('.product-detail').find('.product-id').text();
  } else {
    pid = $($el).closest('.product-detail:not(".bundle-item")').data('pid');
  }

  return pid;
}
/**
 * Retrieve contextual quantity selector
 * @param {jquery} $el - DOM container for the relevant quantity
 * @return {jquery} - quantity selector DOM container
 */

/**
* Retrieve contextual quantity selector
* @param {jquery} $el - DOM container for the relevant quantity
* @return {jquery} - quantity selector DOM container
*/


function getQuantitySelector($el) {
  var quantitySelected;

  if ($($el && $('.set-item').length) && $('.instore-pickup-modal').hasClass('show')) {
    var pid = $el.attr('data-pid');
    quantitySelected = $(".product-detail[data-pid=".concat(pid, "]")).find('.quantity-select').val();
  } else if ($el && $('.set-item').length) {
    quantitySelected = $($el).closest('.product-detail').find('.quantity-select');
  } else if ($el && $('.product-bundle').length) {
    var quantitySelectedModal = $($el).closest('.modal-footer').find('.quantity-select');
    var quantitySelectedPDP = $($el).closest('.bundle-footer').find('.quantity-select');

    if (quantitySelectedModal.val() === undefined) {
      quantitySelected = quantitySelectedPDP;
    } else {
      quantitySelected = quantitySelectedModal;
    }
  } else {
    quantitySelected = $('.quantity-select');
  }

  return quantitySelected;
}
/**
 * Retrieves the value associated with the Quantity pull-down menu
 * @param {jquery} $el - DOM container for the relevant quantity
 * @return {string} - value found in the quantity input
 */


function getQuantitySelected($el) {
  if ($('.instore-pickup-modal').hasClass('show')) {
    return getQuantitySelector($el);
  }

  return getQuantitySelector($el).val();
}
/**
 * Process the attribute values for an attribute that has image swatches
 *
 * @param {Object} attr - Attribute
 * @param {string} attr.id - Attribute ID
 * @param {Object[]} attr.values - Array of attribute value objects
 * @param {string} attr.values.value - Attribute coded value
 * @param {string} attr.values.url - URL to de/select an attribute value of the product
 * @param {boolean} attr.values.isSelectable - Flag as to whether an attribute value can be
 *     selected.  If there is no variant that corresponds to a specific combination of attribute
 *     values, an attribute may be disabled in the Product Detail Page
 * @param {jQuery} $productContainer - DOM container for a given product
 * @param {Object} msgs - object containing resource messages
 */


function processSwatchValues(attr, $productContainer, msgs) {
  attr.values.forEach(function (attrValue) {
    var $attrValue = $productContainer.find('[data-attr="' + attr.id + '"] [data-attr-value="' + attrValue.value + '"]');
    var $swatchButton = $attrValue.parent();

    if (attrValue.selected) {
      $attrValue.addClass('selected');
      $attrValue.siblings('.selected-assistive-text').text(msgs.assistiveSelectedText);
    } else {
      $attrValue.removeClass('selected');
      $attrValue.siblings('.selected-assistive-text').empty();
    }

    if (attrValue.url) {
      $swatchButton.attr('data-url', DOMpurify.sanitize(attrValue.url));
    } else {
      $swatchButton.removeAttr('data-url');
    } // Disable if not selectable


    $attrValue.removeClass('selectable unselectable');
    $attrValue.addClass(attrValue.selectable ? 'selectable' : 'unselectable');
  });
}
/**
 * Process attribute values associated with an attribute that does not have image swatches
 *
 * @param {Object} attr - Attribute
 * @param {string} attr.id - Attribute ID
 * @param {Object[]} attr.values - Array of attribute value objects
 * @param {string} attr.values.value - Attribute coded value
 * @param {string} attr.values.url - URL to de/select an attribute value of the product
 * @param {boolean} attr.values.isSelectable - Flag as to whether an attribute value can be
 *     selected.  If there is no variant that corresponds to a specific combination of attribute
 *     values, an attribute may be disabled in the Product Detail Page
 * @param {jQuery} $productContainer - DOM container for a given product
 */


function processNonSwatchValues(attr, $productContainer) {
  var $attr = '[data-attr="' + attr.id + '"]';
  var $defaultOption = $productContainer.find($attr + ' .select-' + attr.id + ' option:first');
  DOMpurify.sanitize($defaultOption.attr('value', attr.resetUrl));
  attr.values.forEach(function (attrValue) {
    var $attrValue = $productContainer.find($attr + ' [data-attr-value="' + attrValue.value + '"]');
    DOMpurify.sanitize($attrValue.attr('value', attrValue.url).removeAttr('disabled'));

    if (!attrValue.selectable) {
      $attrValue.attr('disabled', true);
    }
  });
}
/**
 * Routes the handling of attribute processing depending on whether the attribute has image
 *     swatches or not
 *
 * @param {Object} attrs - Attribute
 * @param {string} attr.id - Attribute ID
 * @param {jQuery} $productContainer - DOM element for a given product
 * @param {Object} msgs - object containing resource messages
 */


function updateAttrs(attrs, $productContainer, msgs) {
  // Currently, the only attribute type that has image swatches is Color.
  var attrsWithSwatches = ['color'];
  attrs.forEach(function (attr) {
    if (attrsWithSwatches.indexOf(attr.id) > -1) {
      processSwatchValues(attr, $productContainer, msgs);
    } else {
      processNonSwatchValues(attr, $productContainer);
    }
  });
}
/**
 * Updates the availability status in the Product Detail Page
 *
 * @param {Object} response - Ajax response object after an
 *                            attribute value has been [de]selected
 * @param {jQuery} $productContainer - DOM element for a given product
 */


function updateAvailability(response, $productContainer) {
  var availabilityValue = '';
  var availabilityMessages = response.product.availability.messages;
  var isColorSelected = false;
  var isSizeSelected = false;
  var countOutOfStockSizes = 0;

  if (response.variationAttributes) {
    var attributes = response.variationAttributes;
    attributes.forEach(function (attribute) {
      var attr = attribute;

      if (attr && attr.attributeId === 'color') {
        isColorSelected = !!attr.values.find(function (value) {
          return value.selected === true;
        });
      }

      if (isColorSelected && attr && attr.attributeId === 'size') {
        isSizeSelected = !!attr.values.find(function (value) {
          return value.selected === true;
        });

        if (!isSizeSelected) {
          var product = response.product;
          product.available = true;
        }

        var variantSizesArray = attr.values;
        variantSizesArray.forEach(function (value) {
          var variantSize = value;

          if (variantSize && variantSize.inStock === false) {
            countOutOfStockSizes++;
          }
        });

        if (countOutOfStockSizes === variantSizesArray.length) {
          availabilityValue = '';
        }
      }
    });
  } else if (!response.product.readyToOrder) {
    availabilityValue = '<li><div>' + response.resources.info_selectforstock + '</div></li>';
  } else {
    availabilityMessages.forEach(function (message) {
      availabilityValue += '<li><div class="availability">' + message + '</div></li>';
    });
  }

  $($productContainer).trigger('product:updateAvailability', {
    product: response.product,
    $productContainer: $productContainer,
    message: availabilityValue,
    resources: response.resources
  });
}
/**
 * calculates width of the size options and updates the styling accordingly
 */


function updateSizeOptionWidth() {
  var length = $('.size-option').length;
  var arr = [];

  for (var i = 0; i < length; i++) {
    arr[i] = $('.size-option:eq(' + i + ')').width();
  }

  var highestWidth = Math.max.apply(Math, arr); // to find max value

  $('.size-option').css('min-width', highestWidth + 'px');
}
/**
 * Generates html for product attributes section
 *
 * @param {array} attributes - list of attributes
 * @return {string} - Compiled HTML
 */


function getAttributesHtml(attributes) {
  if (!attributes) {
    return '';
  }

  var html = '';
  attributes.forEach(function (attributeGroup) {
    if (attributeGroup.ID === 'mainAttributes') {
      attributeGroup.attributes.forEach(function (attribute) {
        html += '<div class="attribute-values">' + attribute.label + ': ' + attribute.value + '</div>';
      });
    }
  });
  return html;
}
/**
 * @typedef UpdatedOptionValue
 * @type Object
 * @property {string} id - Option value ID for look up
 * @property {string} url - Updated option value selection URL
 */

/**
 * @typedef OptionSelectionResponse
 * @type Object
 * @property {string} priceHtml - Updated price HTML code
 * @property {Object} options - Updated Options
 * @property {string} options.id - Option ID
 * @property {UpdatedOptionValue[]} options.values - Option values
 */

/**
 * Updates DOM using post-option selection Ajax response
 *
 * @param {OptionSelectionResponse} optionsHtml - Ajax response optionsHtml from selecting a product option
 * @param {jQuery} $productContainer - DOM element for current product
 */


function updateOptions(optionsHtml, $productContainer) {
  // Update options
  $productContainer.find('.product-options').empty().html(DOMpurify.sanitize(optionsHtml));
}
/**
 * Updating product main image from response containing images
 * @param {Object[]} primaryImageUrls - Array of large product images,along with related information
 * @param {jQuery} $productContainer - DOM element for a given product
 */


function updateMainImage(primaryImageUrls, $productContainer) {
  var isQuickview = $productContainer.hasClass('product-quickview');
  var isProductSetFlyout = $productContainer.parents('#editProductSetModal').length > 0;
  var isEditCartFlyout = isQuickview && $productContainer.parents('.edit-product-modal').length > 0;
  var imageSetArray = primaryImageUrls;

  if (imageSetArray.zoom.length === 0) {
    imageSetArray.zoom = imageSetArray.large;
  }

  if ($('.syte-discovery').length > 0) {
    $productContainer.find('.syte-discovery').attr('data-image-src', DOMpurify.sanitize(imageSetArray.base[0].url));
  }

  if ($('#syte-similar-items-container').length > 0) {
    $('#syte-similar-items-container').attr('data-image-src', DOMpurify.sanitize(imageSetArray.base[0].url));
  }

  if (isEditCartFlyout) {
    $productContainer.find('.primary-images').html('<img src="' + DOMpurify.sanitize(imageSetArray.base[0].url) + '" class="d-block img-fluid" alt="' + DOMpurify.sanitize(imageSetArray.base[0].alt) + ' image number ' + parseInt(DOMpurify.sanitize(imageSetArray.base[0].index), 10) + '" data-zoom-img="" itemprop="image"/>');
  } else if (isProductSetFlyout) {
    $productContainer.find('.product-set-flyout-image .zoom').html('<img src="' + DOMpurify.sanitize(imageSetArray.base[0].url) + '" class="d-block img-fluid" alt="' + DOMpurify.sanitize(imageSetArray.base[0].alt) + ' image number ' + parseInt(DOMpurify.sanitize(imageSetArray.base[0].index), 10) + '" data-zoom-img="" itemprop="image"/>');
  } else {
    var wishListIconsBtns = $productContainer.find('.large-images').html().substring(0, $productContainer.find('.large-images').html().indexOf('<div class="zoom">'));
    $productContainer.find('.js-large-images-list').empty();

    if ($(window).width() <= SCREENSIZE.DESKTOPMIN) {
      $productContainer.find('.js-large-images-list').removeClass('slick-initialized');
      $productContainer.find('.js-large-images-list').removeClass('slick-slider');
    }

    for (var i = 0; i < imageSetArray.large.length; i++) {
      if ($(window).width() > SCREENSIZE.DESKTOPMIN && i > 0) {
        $productContainer.find('.js-large-images-list').append('<li data-large="large-thumbnail-' + DOMpurify.sanitize(imageSetArray.large[i].index) + '" class="large-thumbnail-' + DOMpurify.sanitize(imageSetArray.large[i].index) + '  large-images">' + DOMpurify.sanitize(wishListIconsBtns) + '<div class="zoom"><img data-src="' + DOMpurify.sanitize(imageSetArray.large[i].url) + '" class="zoom-image lazyload d-block img-fluid" loading="lazy" alt="' + DOMpurify.sanitize(imageSetArray.large[i].alt) + ' image number ' + parseInt(DOMpurify.sanitize(imageSetArray.zoom[i].index), 10) + '" data-zoom-img="" data-zoom-image="' + DOMpurify.sanitize(imageSetArray.zoom[i].url) + '" itemprop="image"></div></li>');
      } else {
        $productContainer.find('.js-large-images-list').append('<li data-large="large-thumbnail-' + DOMpurify.sanitize(imageSetArray.large[i].index) + '" class="large-thumbnail-' + DOMpurify.sanitize(imageSetArray.large[i].index) + '  large-images">' + DOMpurify.sanitize(wishListIconsBtns) + '<div class="zoom"><img src="' + DOMpurify.sanitize(imageSetArray.large[i].url) + '" class="zoom-image d-block img-fluid" alt="' + DOMpurify.sanitize(imageSetArray.large[i].alt) + ' image number ' + parseInt(DOMpurify.sanitize(imageSetArray.zoom[i].index), 10) + '" data-zoom-img="" data-zoom-image="' + DOMpurify.sanitize(imageSetArray.zoom[i].url) + '" itemprop="image"></div></li>');
      }
    }

    $('.large-images').first().addClass('first-image');

    if (isQuickview) {
      $productContainer.find('.large-images-list .large-images').not(':first-child').addClass('d-none');
    }
  }
}
/**
 * Updating product thumnail image from response containing images
 * @param {Object[]} imgs - Array of small product images,along with related information
 * @param {jQuery} $productContainer - DOM element for a given product
 */


function updateThumbnailImage(imgs, $productContainer) {
  var count = 0;
  $productContainer.find('.thumbnail-btn.js-thumbnail-btn').remove();

  for (var i = 0; i < imgs.length; i++) {
    var thumbnailControlBtn = '<button type="button" aria-label="thumbnail" data-thumbnail="thumbnail-' + imgs[i].index + '" class="thumbnail-' + imgs[i].index + ' thumbnail-btn js-thumbnail-btn"><img src="' + imgs[i].url + '" class="d-block img-fluid mouseFocusUnActive" alt="' + imgs[i].alt + ' image number ' + parseInt(imgs[i].index, 10) + '" itemprop="image"></button>';

    if (count === 0) {
      if ($(window).width() <= SCREENSIZE.DESKTOPMIN) {
        $productContainer.find('.js-thumbnail-images').append(DOMpurify.sanitize(thumbnailControlBtn));
      } else if ($('.thumbnail-prev').length) {
        $productContainer.find('.thumbnail-prev').after(DOMpurify.sanitize(thumbnailControlBtn));
      } else {
        $productContainer.find('.thumbnail-images').append(DOMpurify.sanitize(thumbnailControlBtn));
      }

      $productContainer.find('.thumbnail-0').addClass('active');
      count++;
    } else {
      $productContainer.find('.thumbnail-' + (imgs[i].index - 1) + '').after(DOMpurify.sanitize(thumbnailControlBtn));
    }

    $productContainer.find('.thumbnail-' + imgs[i].index + ' img').attr('onerror', 'this.parentNode.classList.remove("d-block");this.parentNode.classList.add("d-none");');
  }
}
/**
 * @typespec UpdatedQuantity
 * @type Object
 * @property {boolean} selected - Whether the quantity has been selected
 * @property {string} value - The number of products to purchase
 * @property {string} url - Compiled URL that specifies variation attributes, product ID, options,
 *     etc.
 */

/**
 * Updates the quantity DOM elements post Ajax call
 * @param {UpdatedQuantity[]} quantities -
 * @param {jQuery} $productContainer - DOM container for a given product
 */


function updateQuantities(quantities, $productContainer) {
  if ($productContainer.parent('.bonus-product-item').length <= 0) {
    var optionsHtml = quantities.map(function (quantity) {
      var selected = quantity.selected ? ' selected ' : '';
      return '<option value="' + quantity.value + '"  data-url="' + quantity.url + '"' + selected + '>' + quantity.value + '</option>';
    }).join('');
    getQuantitySelector($productContainer).empty().html(DOMpurify.sanitize(optionsHtml));
  }
}
/**
 * Parses JSON from Ajax call made whenever an attribute value is [de]selected
 * @param {Object} response - response from Ajax call
 * @param {Object} response.product - Product object
 * @param {string} response.product.id - Product ID
 * @param {Object[]} response.product.variationAttributes - Product attributes
 * @param {Object[]} response.product.images - Product images
 * @param {boolean} response.product.hasRequiredAttrsSelected - Flag as to whether all required
 *     attributes have been selected.  Used partially to
 *     determine whether the Add to Cart button can be enabled
 * @param {jQuery} $productContainer - DOM element for a given product.
 * @param {jQuery} selectedElement - DOM element for selected variation attribute.
 */


function handleVariantResponse(response, $productContainer, selectedElement) {
  var productSetPage = $('.product-set-detail').length > 0;
  var cartPage = $('.cart-page').length > 0;
  var klarnaWidget = $('.pdp-klarna-widget');
  var isQuickView = $('body').find('#quickViewModal').length > 0;
  var isChoiceOfBonusProducts = $productContainer.parents('.choose-bonus-product-dialog').length > 0;
  var isVariant;
  var isColorVariant = false;
  var isActionVariant = response.action === 'Product-Variation';

  if (response.product.variationAttributes) {
    updateAttrs(response.product.variationAttributes, $productContainer, response.resources);
    isVariant = response.product.productType === 'variant';

    if (isChoiceOfBonusProducts && isVariant) {
      $productContainer.parent('.bonus-product-item').data('pid', response.product.id);
      $productContainer.parent('.bonus-product-item').data('ready-to-order', response.product.readyToOrder);
    }
  }

  if (selectedElement && selectedElement.hasClass('color-attribute')) {
    isColorVariant = true; // Update primary images

    var primaryImageUrls = response.product.images;
    updateMainImage(primaryImageUrls, $productContainer); // Update thumbnail images

    var thumbnailImageUrls = response.product.images.base;
    updateThumbnailImage(thumbnailImageUrls, $productContainer);
  }

  if (klarnaWidget.length > 0 && isActionVariant) {
    var thresholdValue = klarnaWidget.data('threshold');
    var nowPrice = response.product.price.sales.value;

    if (nowPrice >= thresholdValue) {
      klarnaWidget.addClass('d-none');
    } else {
      klarnaWidget.removeClass('d-none');
    }
  }

  if (!productSetPage && !cartPage && !isQuickView && isColorVariant) {
    clientSideUtil.windowScrollToDestination(0, 0, 'smooth');
    productImages.setupPDPImages();
    productImages.setupMediaZoom();
    $('.zoomContainer').remove();
  } else if (productSetPage && !cartPage && isColorVariant) {
    var productSetFlyout = $productContainer.closest('.product-set-flyout-wrapper').length;

    if (productSetFlyout === 0 && $(window).width() <= SCREENSIZE.DESKTOPMIN) {
      var $mobileImagesList = $productContainer.closest('.product-set-detail').find('.js-product-carousel');
      $mobileImagesList.not('.slick-initialized').slick();
    } else if (productSetFlyout === 0 && $(window).width() > SCREENSIZE.DESKTOPMIN) {
      productSetImages.productSetImages();
      productSetImages.setupMediaZoom();
    }
  } // Update pricing


  if (!isChoiceOfBonusProducts) {
    var $priceSelector = $('.prices .price', $productContainer).length ? $('.prices .price', $productContainer) : $('.prices .price');
    $priceSelector.replaceWith(DOMpurify.sanitize(response.product.price.html));
  } // Update promotions


  $productContainer.find('.promotions').empty().html(DOMpurify.sanitize(response.product.promotionsHtml)); // Update variations

  var selectedSizeTabID = $('.size-locale-tabs').find('button.selected').attr('id') || '';
  $productContainer.find('.variationAttributes').empty().html(DOMpurify.sanitize(response.product.variationsHtml));

  if (productSetPage) {
    var $productSetFlyout = $productContainer.closest('.product-set-flyout-wrapper').closest('.modal-body').length;

    if ($productSetFlyout > 0) {
      $productContainer.find('.variationAttributes .color-attribute-value').find("span[data-isinstock='false']").parent().remove();
      $productContainer.find('.variationAttributes').find("div.size-option[data-isinstock='false']").remove();
    }
  }

  var mainkorsVIPSection = $productContainer.find('.mainkorsVIPSection');

  if (mainkorsVIPSection.data('is-loyalty')) {
    mainkorsVIPSection.removeClass('d-none');
  }

  setTimeout(function () {
    selectedElement.focus();
  }, 100);
  sizeGuideTabs.localizeSizeLabels();

  if (selectedSizeTabID.length) {
    $('.size-locale-tabs').find("button#".concat(selectedSizeTabID)).trigger('click');
  }

  updateSizeOptionWidth();
  updateAvailability(response, $productContainer);

  if (isChoiceOfBonusProducts) {
    var $selectButton = $productContainer.find('.select-bonus-product');
    $selectButton.trigger('bonusproduct:updateSelectButton', {
      product: response.product,
      $productContainer: $productContainer
    });
  } else {
    // Enable "Add to Cart" button if all required attributes have been selected
    $('button.add-to-cart, button.add-to-cart-global, button.update-cart-product-global, button.move-to-cart-wishlist').trigger('product:updateAddToCart', {
      product: response.product,
      $productContainer: $productContainer
    }).trigger('product:statusUpdate', response.product);
  } // Update quantities


  var editWishlist = $productContainer.closest('#editWishlistProductModal').length > 0;

  if (response.quantitySelectorEnabled && !editWishlist) {
    $('.quantity-quick-view').removeClass('d-none');
    updateQuantities(response.product.quantities, $productContainer);
  } else {
    $('.quantity-quick-view').addClass('d-none');
  } // Update attributes


  $productContainer.find('.main-attributes').empty().html(getAttributesHtml(DOMpurify.sanitize(response.product.attributes)));
  var $siteDiscovery = $('.syte-discovery');

  if ($siteDiscovery.length > 0) {
    $siteDiscovery.attr('data-sku', response.product.syteProductId);
    $siteDiscovery.attr('data-image-src', response.product.syteProductImage);
  }

  var $syteCarousel = $('.syte-carousel-js');

  if ($syteCarousel.length > 0) {
    $syteCarousel.attr('data-sku', response.product.syteProductId);
    $syteCarousel.attr('data-image-src', response.product.syteProductImage);
  }

  var sizeInStock = $productContainer.closest('.modal-content').find('.product-quickview .size-option.selected').data('isinstock');
  var colorInStock = $productContainer.closest('.modal-content').find('.product-quickview .color-attribute-value .swatch-circle.selected').data('isinstock');

  if (sizeInStock === false || colorInStock === false) {
    $productContainer.closest('.modal-content').find('.product-quickview .edit-product-title').addClass('d-none');
    $productContainer.closest('.modal-content').find('.product-quickview .notify-product-title.d-none').removeClass('d-none');
  } else {
    $productContainer.closest('.modal-content').find('.product-quickview .edit-product-title.d-none').removeClass('d-none');
    $productContainer.closest('.modal-content').find('.product-quickview .notify-product-title').addClass('d-none');
  }
}
/**
 * updates the product view when a product attribute is selected or deselected or when
 *         changing quantity
 * @param {string} selectedValueUrl - the Url for the selected variation value
 * @param {jQuery} $productContainer - DOM element for current product
 * @param {boolean} selectedElement - current attribute is selected
 * @param {boolean} updateSizeBox - update the size box
*/


function attributeSelect(selectedValueUrl, $productContainer) {
  var selectedElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var updateSizeBox = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var productSetPage = $('.product-set-detail').length > 0;
  var cartPage = $('.cart-page').length > 0;
  var wishlistPage = $('.main-wishlist');

  if (selectedValueUrl) {
    $('body').trigger('product:beforeAttributeSelect', {
      url: selectedValueUrl,
      container: $productContainer
    });
    $.ajax({
      url: selectedValueUrl,
      method: 'GET',
      success: function success(data) {
        if (updateSizeBox) {
          $productContainer.find('.size-option.selected').removeClass('selected');
          selectedElement.parents('.size-option').addClass('selected');
        }

        handleVariantResponse(data, $productContainer, selectedElement);
        updateOptions(data.product.optionsHtml, $productContainer);
        updateQuantities(data.product.quantities, $productContainer);
        updateFavorites(data.isFavoriteProduct, $productContainer);

        if ($('.afterpay-messaging afterpay-placement').length > 0) {
          if (data.product.price && data.product.price.sales) {
            if (!data.product.isProductAfterpayEligible || data.product.isProductAfterpayEligible.isApplicable === false) {
              $productContainer.find('.afterpay-messaging').addClass('d-none');
            } else {
              $productContainer.find('.afterpay-messaging').removeClass('d-none');
              $productContainer.find('.afterpay-messaging afterpay-placement').attr('data-amount', DOMpurify.sanitize(data.product.price.sales.decimalPrice));
            }
          }
        }

        if (!productSetPage && !cartPage && !wishlistPage) {
          productImages.setupPDPImages();
        }

        if (data.product.comingSoon.isComingSoonAvaiable) {
          $('.comming-soon-msg').removeClass('d-none').empty().append(DOMpurify.sanitize(data.product.comingSoon.message));
        } else {
          $('.comming-soon-msg').addClass('d-none');
        }

        $('body').trigger('product:afterAttributeSelect', {
          data: data,
          container: $productContainer,
          target: selectedElement
        });

        if (selectedElement) {
          if (selectedElement.hasClass('color-attribute')) {
            $('body').trigger('event:productColorSelection', data);
          }

          if (selectedElement.attr('name') === 'Size') {
            $('body').trigger('event:productSizeSelection', data);
          }

          if (selectedElement.hasClass('quantity-select')) {
            $('body').trigger('event:quantityDropdown', data);
          }
        }

        if (data.product.isNotifyMeActive === true) {
          $productContainer.find('.add-to-cart-container button').attr('disabled', false).addClass('notify-me-btn').attr('href', data.product.notifyURL);
          $productContainer.find('.update-cart-product-global').attr('disabled', false).addClass('notify-me-btn').attr('href', data.product.notifyURL);
          $productContainer.find('.move-to-cart-wishlist').attr('disabled', false).addClass('notify-me-btn').attr('href', data.product.notifyURL);

          if (wishlistPage) {
            $productContainer.find('.add-to-cart-url').addClass('notify-me-enabled');
          }
        } else {
          $productContainer.find('.add-to-cart-container button').removeClass('notify-me-btn').attr('href', '');
          $productContainer.find('.update-cart-product-global').removeClass('notify-me-btn').attr('href', '');
          $productContainer.find('.move-to-cart-wishlist').removeClass('notify-me-btn').attr('href', '');

          if (wishlistPage) {
            $productContainer.find('.add-to-cart-url').removeClass('notify-me-enabled');
          }

          if (data.product.availability !== undefined && data.product.availability.dcQuantityAvailable !== undefined) {
            if (!data.product.availability.dcQuantityAvailable) {
              $productContainer.find('.add-to-cart-container button').attr('disabled', true);
              $productContainer.find('.dcquantity-notavailable-msg').removeClass('d-none').empty().append(DOMpurify.sanitize(data.product.availability.dcQuantityNotAvailableMsg));
            } else {
              $productContainer.find('.add-to-cart-container button').attr('disabled', false);
              $productContainer.find('.dcquantity-notavailable-msg').addClass('d-none');
            }
          }
        }
      },
      error: function error() {}
    });
  }
}
/**
 * Retrieves url to use when adding a product to the cart
 * @param {jQuery} elem - Add to Cart button
 * @param {string} uuid - Unique ID for Product Cart Line Item
 * @return {string} - The provided URL to use when adding a product to the cart
 */


function getAddToCartUrl(elem, uuid) {
  var url;

  if (uuid) {
    url = $(elem).parent().find('.switch-to-pickupin-store').val();
  } else {
    url = $(elem).parent().find('.add-to-cart-url').val();
  }

  return url;
}
/**
 * Parses the html for a modal window
 * @param {string} html - representing the body and footer of the modal window
 *
 * @return {Object} - Object with properties body and footer.
 */


function parseHtml(html) {
  var $html = $('<div>').append($.parseHTML(html));
  var body = $html.find('.choice-of-bonus-product');
  var footer = $html.find('.modal-footer').children();
  return {
    body: body,
    footer: footer
  };
}
/**
 * Retrieves url to use when adding a product to the cart
 *
 * @param {Object} data - data object used to fill in dynamic portions of the html
 */


function chooseBonusProducts(data) {
  $('.modal-body').spinner().start();

  if ($('#chooseBonusProductModal').length !== 0) {
    $('#chooseBonusProductModal').remove();
  }

  var bonusUrl;

  if (data.bonusChoiceRuleBased) {
    bonusUrl = data.showProductsUrlRuleBased;
  } else {
    bonusUrl = data.showProductsUrlListBased;
  }

  var htmlString = '<!-- Modal -->' + '<div class="modal fade" id="chooseBonusProductModal" tabindex="-1" role="dialog">' + '<span class="enter-message sr-only" ></span>' + '<div class="modal-dialog choose-bonus-product-dialog" ' + 'data-total-qty="' + data.maxBonusItems + '"' + 'data-UUID="' + data.uuid + '"' + 'data-pliUUID="' + data.pliUUID + '"' + 'data-addToCartUrl="' + data.addToCartUrl + '"' + 'data-pageStart="0"' + 'data-pageSize="' + data.pageSize + '"' + 'data-moreURL="' + data.showProductsUrlRuleBased + '"' + 'data-bonusChoiceRuleBased="' + data.bonusChoiceRuleBased + '">' + '<!-- Modal content-->' + '<div class="modal-content">' + '<div class="modal-header">' + '    <span class="">' + data.labels.selectprods + '</span>' + '    <button type="button" class="close pull-right" data-dismiss="modal">' + '        <span aria-hidden="true">&times;</span>' + '        <span class="sr-only"> </span>' + '    </button>' + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer"></div>' + '</div>' + '</div>' + '</div>';
  DOMpurify.sanitize($('body').append(htmlString));
  $('.modal-body').spinner().start();
  $.ajax({
    url: bonusUrl,
    method: 'GET',
    dataType: 'json',
    success: function success(response) {
      var parsedHtml = parseHtml(response.renderedTemplate);
      $('#chooseBonusProductModal .modal-body').empty();
      $('#chooseBonusProductModal .enter-message').text(response.enterDialogMessage);
      $('#chooseBonusProductModal .modal-header .close .sr-only').text(response.closeButtonText);
      $('#chooseBonusProductModal .modal-body').html(parsedHtml.body);
      $('#chooseBonusProductModal .modal-footer').html(parsedHtml.footer);
      $('#chooseBonusProductModal').modal('show');
      $.spinner().stop();
    },
    error: function error() {
      $.spinner().stop();
    }
  });
}
/**
 * Retrieves the bundle product item ID's for the Controller to replace bundle master product
 * items with their selected variants
 *
 * @return {string[]} - List of selected bundle product item ID's
 */


function getChildProducts() {
  var childProducts = [];
  $('.bundle-item').each(function () {
    childProducts.push({
      pid: $(this).find('.product-id').text(),
      quantity: parseInt($(this).find('label.quantity').data('quantity'), 10)
    });
  });
  return childProducts.length ? JSON.stringify(childProducts) : [];
}
/**
 * Retrieve product options
 *
 * @param {jQuery} $productContainer - DOM element for current product
 * @return {string} - Product options and their selected values
 */


function getOptions($productContainer) {
  var options = $productContainer.find('.product-option').map(function () {
    var $elOption = $(this).find('.options-select');
    var urlValue = $elOption.val();
    var selectedValueId = $elOption.find('option[value="' + urlValue + '"]').data('value-id');
    return {
      optionId: $(this).data('option-id'),
      selectedValueId: selectedValueId
    };
  }).toArray();
  return JSON.stringify(options);
}
/**
 * Makes a call to the server to report the event of adding an item to the cart
 *
 * @param {string | boolean} url - a string representing the end point to hit so that the event can be recorded, or false
 */


function miniCartReportingUrl(url) {
  if (url) {
    $.ajax({
      url: url,
      method: 'GET',
      success: function success() {// reporting urls hit on the server
      },
      error: function error() {// no reporting urls hit on the server
      }
    });
  }
}
/**
 * cleartimout and setting the timer for minicart after add a product to cart
 * @param {string} selector - current selector
 * @param {number} millisec - duration after which this event will trigger
 */


function clearAndSetTime(selector, millisec) {
  var timer;
  window.clearTimeout(timer);
  timer = window.setTimeout(function () {
    $(selector).removeClass('show');
  }, millisec);
}
/* Fluid Customization - CUSTOM METHOD FOR FLUID */

/**
 * Add Fluid Configure product to cart from the PDP
 * @param {json} details - JSON configuration of the configurations made within Fluid
 */


function addCustomProductToCart() {
  $(document).on('product:addCustomProductToCart', function (e, details) {
    var apiKey;
    var addToCartUrl;
    var pid;
    var pidsObj;
    var childProducts = [];
    var fluidConfigureQuantity;
    var fluidConfigurePrice;
    var fluidConfigureImageURL;
    var fluidConfigureRecipeID;
    var fluidConfigureOldRecipeID;
    var fluidConfigureUUID;
    var fluidConfigureResourceURL;
    var fluidConfigureValues = {}; // eslint-disable-next-line no-underscore-dangle

    var quantity = details.recipe.product_quantities.product;
    pid = details.itemDetails.itemDetails[0].skuId;

    if (window.configureParams) {
      apiKey = window.configureParams.demandwareConfigureAPIKey;
      addToCartUrl = window.configureParams.addToCartUrl;
      fluidConfigureQuantity = quantity;
      fluidConfigurePrice = details.recipe.custom.price;
      fluidConfigureImageURL = details.recipe.images.front;
      fluidConfigureRecipeID = details.recipe.id;
      fluidConfigureResourceURL = details.recipe.uri + '?api-key=' + apiKey;
      fluidConfigureOldRecipeID = window.configureParams.oldRecipeId ? window.configureParams.oldRecipeId : ''; // This line is used for cart edit functionality

      fluidConfigureUUID = window.configureParams.lineId ? window.configureParams.lineId : ''; // This line is used for cart edit functionality

      if (typeof details.recipe !== 'undefined' && details.recipe !== '' && typeof details.recipe.extended_attributes !== 'undefined') {
        var recipeObject = details.recipe.extended_attributes;
        fluidConfigureValues = {};
        fluidConfigureValues.monogram = '';

        if (typeof recipeObject.monogram !== 'undefined' && typeof recipeObject.monogram.value.extendedId !== 'undefined') {
          fluidConfigureValues.monogram = recipeObject.monogram.value.extendedId;
        }

        fluidConfigureValues.monogram_color = '';

        if (typeof recipeObject.monogram_color !== 'undefined') {
          fluidConfigureValues.monogram_color = recipeObject.monogram_color.value.name;
        }

        fluidConfigureValues.placement = '';

        if (typeof recipeObject.select_a_placement !== 'undefined' && typeof recipeObject.select_a_placement.value !== 'undefined' && typeof recipeObject.select_a_placement.value.info !== 'undefined' && typeof recipeObject.select_a_placement.value.info.vendorId !== 'undefined') {
          fluidConfigureValues.placement = recipeObject.select_a_placement.value.info.vendorId;
        } else if (typeof recipeObject.jewelry !== 'undefined' || typeof recipeObject.watch !== 'undefined') {
          fluidConfigureValues.placement = 'Back';
        }

        fluidConfigureValues.font = '';
        fluidConfigureValues.font_size = '';

        if (typeof recipeObject.font_size !== 'undefined') {
          var monogramFontandFontSize = recipeObject.font_size.value.name;
          var result = monogramFontandFontSize.split('-');

          if (typeof result !== 'undefined' && result !== '') {
            fluidConfigureValues.font = result[1] ? result[1].trim() : '';
            fluidConfigureValues.font_size = result[2] ? result[2].trim() : '';
          }
        }
        /*
        These are all configurations that will eventually be referenced. Leaving this in place for documentation purposes.
         fluidConfigureValues.font = details.recipe.localized_configuration.font ? details.recipe.localized_configuration.font : '';
        fluidConfigureValues.font_position = details.recipe.localized_configuration.font_position ? details.recipe.localized_configuration.font_position : '';
        fluidConfigureValues.font_size = details.recipe.localized_configuration.font_size ? details.recipe.localized_configuration.font_size : '';
        fluidConfigureValues.text = details.recipe.localized_configuration.monogram ? details.recipe.localized_configuration.monogram : '';
        fluidConfigureValues.monogram_color = details.recipe.localized_configuration.monogram_color ? details.recipe.localized_configuration.monogram_color : '';
        fluidConfigureValues.monogram_back_render = details.recipe.localized_configuration.monogram_back_render ? details.recipe.localized_configuration.monogram_back_render : '';
        fluidConfigureValues.monogram_front_render = details.recipe.localized_configuration.monogram_front_render ? details.recipe.localized_configuration.monogram_front_render : '';
        fluidConfigureValues.jewelry_size = details.recipe.localized_configuration.jewelry_size ? details.recipe.localized_configuration.jewelry_size : '';
        fluidConfigureValues.type = details.recipe.localized_configuration.watch ? details.recipe.localized_configuration.watch : (details.recipe.localized_configuration.jewelry ? details.recipe.localized_configuration.jewelry : '');
        fluidConfigureValues.placement = details.recipe.localized_configuration.select_a_placement ? details.recipe.localized_configuration.select_a_placement : '';
        */

      }
    }

    var form = {
      pid: pid,
      pidsObj: pidsObj,
      childProducts: childProducts,
      quantity: quantity,
      fluidConfigureQuantity: fluidConfigureQuantity,
      fluidConfigurePrice: fluidConfigurePrice,
      fluidConfigureImageURL: fluidConfigureImageURL,
      fluidConfigureRecipeID: fluidConfigureRecipeID,
      fluidConfigureOldRecipeID: fluidConfigureOldRecipeID,
      fluidConfigureUUID: fluidConfigureUUID,
      fluidConfigureResourceURL: fluidConfigureResourceURL,
      fluidConfigureValues: JSON.stringify(fluidConfigureValues)
    };
    $('body').spinner().start();
    $(this).trigger('updateAddToCartFormData', form);

    if (addToCartUrl) {
      $.ajax({
        url: addToCartUrl,
        method: 'POST',
        data: form,
        success: function success(data) {
          $('.minicart').trigger('count:update', data);
          $('body').trigger('product:afterAddToCart', data);
          $('#fluidConfigure').spinner().stop();
          miniCartReportingUrl(data.reportingURL);
          var isProductAdded = true;
          var updateProduct = data.updatedLine;
          $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime, updateProduct]);
          var selector = '.minicart .popover';
          var timer = setTimeout(function () {
            $(selector).removeClass('show');
          }, data.miniBagFlyOutTimeinMilliSec);
          $('.minicart .popover').on('mouseenter', function () {
            clearTimeout(timer);
          });
          $('body').trigger('event:addToCart', data);
        },
        error: function error() {
          $('#fluidConfigure').spinner().stop();
        }
      });
    }
  });
}
/**
 * @param {jQuery} $productContainer - Add to Cart / PIS CTA
 * @return {string} - Hide/Show Error
 */


function showNoAttributeSelectedError($productContainer) {
  // Need to use this for size selector instead of color attribute
  var $selectedSizeAttr = $productContainer.find('.select-size .size-option');
  var inStock = $productContainer.find('.size-option.selected').length ? $productContainer.find('.size-option.selected').data('isinstock') : true;
  var $selectedColorAttr = $productContainer.find('.color-attribute-value .swatch-circle');
  var sizeNotSelected = $selectedSizeAttr && $selectedSizeAttr.length && !$selectedSizeAttr.hasClass('selected');
  var colorNotSelected = $selectedColorAttr && $selectedColorAttr.length && !$selectedColorAttr.hasClass('selected');

  if (sizeNotSelected || colorNotSelected) {
    $('body').trigger('event:productError', $selectedSizeAttr);
    var $targetAttribute = colorNotSelected ? $selectedColorAttr : $selectedSizeAttr;
    var $attributeSelector = $targetAttribute.closest('.attribute');
    var variationsScrollValue = $('.variationAttributes').offset().top;
    $attributeSelector.find('.attribute-error:first').removeClass('d-none');
    $($('.size-option input')[0]).focus();

    if (!$targetAttribute.isInViewport()) {
      clientSideUtil.windowScrollToDestination(variationsScrollValue, 0, 'smooth');
    }

    $.spinner().stop();
    return false;
  } else if (!inStock && $('.set-item').length && $(this).hasClass('add-to-cart-global')) {
    var $target = colorNotSelected ? $selectedColorAttr : $selectedSizeAttr;
    var $attr = $target.closest('.attribute');
    $attr.find('.productset-attribute-error').removeClass('d-none').focus();
    return false;
  }
}
/**
 * Updating product images from response containing images
 * @param {Object[]} responseImage - Array of large product images,along with related information
 * @param {jQuery} $productContainer - DOM element for a given product
 */


function updateImage(responseImage, $productContainer) {
  // Update primary images
  var primaryImageUrls = responseImage;
  updateMainImage(primaryImageUrls, $productContainer); // Update thumbnail images

  var thumbnailImageUrls = responseImage.base;
  updateThumbnailImage(thumbnailImageUrls, $productContainer);
  productImages.setupMediaZoom();
  productImages.setupPDPImages();
}
/**
 * Hides quickview modal when SizeChart modal is open
 */


function hideQuickView() {
  if ($('#quickViewModal').hasClass('show')) {
    $('#quickViewModal').addClass('d-none');
    $('#sizeChartModal').attr('quickview', true);
  }
}

var base = {
  attributeSelect: attributeSelect,
  clearAndSetTime: clearAndSetTime,
  methods: {
    editBonusProducts: function editBonusProducts(data) {
      chooseBonusProducts(data);
    }
  },
  focusChooseBonusProductModal: function focusChooseBonusProductModal() {
    $('body').on('shown.bs.modal', '#chooseBonusProductModal', function () {
      $('#chooseBonusProductModal').siblings().attr('aria-hidden', 'true');
      $('#chooseBonusProductModal .close').focus();
    });
  },
  onClosingChooseBonusProductModal: function onClosingChooseBonusProductModal() {
    $('body').on('hidden.bs.modal', '#chooseBonusProductModal', function () {
      $('#chooseBonusProductModal').siblings().attr('aria-hidden', 'false');
    });
  },
  trapChooseBonusProductModalFocus: function trapChooseBonusProductModalFocus() {
    $('body').on('keydown', '#chooseBonusProductModal', function (e) {
      var focusParams = {
        event: e,
        containerSelector: '#chooseBonusProductModal',
        firstElementSelector: '.close',
        lastElementSelector: '.add-bonus-products'
      };
      focusHelper.setTabNextFocus(focusParams);
    });
  },
  colorAttribute: function colorAttribute() {
    $(document).on('click', '[data-attr="color"] button', function (e) {
      e.preventDefault();

      if ($(this).attr('disabled')) {
        return;
      }

      var $productContainer = $(this).closest('.set-item');

      if (!$productContainer.length) {
        $productContainer = $(this).closest('.product-detail');
      }

      if (!$(this).find('span').hasClass('selected')) {
        attributeSelect($(this).attr('data-url'), $productContainer, $(this));
      }

      $(this).siblings('button').attr('aria-label').replace($(this).parent().attr('data-attr-selected'), $(this).parent().attr('data-attr-select'));
      $(this).attr('aria-label', $(this).parents('.color-section').attr('data-attr') + $(this).find('span').attr('title') + $(this).parents().find('span.selected-assistive-text').text().trim());
      $('.add-to-favorites, .add-fav-heart').attr('aria-label', $('.add-fav-aria').val() + ' ' + $(this).find('span').attr('title'));
    });
  },
  selectAttribute: function selectAttribute() {
    $(document).on('change keypress', '.variationAttributes input[type="checkbox"], .attributes input[type="checkbox"]', function (e) {
      e.preventDefault(); // keypress handler

      if (e.which === 13) {
        this.checked = !this.checked;
      } // handle if checkbox already checked


      if ($(this).is(':checked') === false) {
        $(this).prop('checked', true);
        return;
      } // allow only 1 checkbox to be checked


      var group = 'input:checkbox[name="' + $(this).attr('name') + '"]';
      $(group).prop('checked', false);
      $(this).prop('checked', true); // get the product container

      var $productContainer = $(this).closest('.set-item');

      if (!$productContainer.length) {
        $productContainer = $(this).closest('.product-detail');
      } // handle attribute change


      attributeSelect(e.currentTarget.value, $productContainer, $(this), true);
    });
  },
  sizeChart: function sizeChart() {
    $(document).on('click', '.size-chart a', function (e) {
      e.preventDefault();
      var url = $(this).attr('href');

      if (!$('#sizeChartModal').length) {
        $.ajax({
          url: DOMpurify.sanitize(url),
          type: 'get',
          dataType: 'json',
          success: function success(data) {
            $('body').append(DOMpurify.sanitize(data.content));
            hideQuickView();
            $('#sizeChartModal').modal('show');

            if (!data.initialDisplayInches) {
              $('.nav a[href="#table-cm"]').tab('show');
            }
          }
        });
      } else {
        hideQuickView();
        $('#sizeChartModal').modal('show');
      }
    });
  },
  availability: function availability() {
    $(document).on('change', '.quantity-select', function (e) {
      e.preventDefault();
      var $productContainer = $(this).closest('.product-detail');

      if (!$productContainer.length) {
        $productContainer = $(this).closest('.modal-content').find('.product-quickview');
      }

      if ($('.bundle-items', $productContainer).length === 0) {
        attributeSelect($(e.currentTarget).find('option:selected').data('url'), $productContainer, $(this));
      }
    });
  },
  addToCart: function addToCart() {
    $(document).off('click', 'button.add-to-cart, button.add-to-cart-global').on('click', 'button.add-to-cart, button.add-to-cart-global', function () {
      if ($(this).hasClass('notify-me-btn')) {
        return;
      }

      var $this = $(this);
      var addToCartUrl;
      var pid;
      var pidsObj;
      var storeId;
      var setPids;
      var $productContainer = $(this).closest('.product-detail');
      var dialog = $(this).closest('.instore-pickup-modal');
      var uuid = dialog.data('uuid');
      var inStockColor = $productContainer.find('.color-attribute-value .swatch-circle.selected') ? $productContainer.find('.color-attribute-value .swatch-circle.selected').data('isinstock') : true;
      var inStockSize = $productContainer.find('.size-option.selected').length ? $productContainer.find('.size-option.selected').data('isinstock') : true;
      var inStock = inStockSize && inStockColor;
      var $selectedSizeAttr = $productContainer.find('.select-size .size-option');
      var $selectedColorAttr = $productContainer.find('.color-attribute-value .swatch-circle');
      var isProductSetFlyout = false;
      var isInStorePickUp = false;
      var error;
      var addtobagsets = $(this);

      if (!inStock && $('.set-item').length && $(this).hasClass('add-to-cart-global')) {
        var $target;

        if (!inStockSize) {
          $target = $selectedSizeAttr;
          error = '.productset-attribute-error-valid-size';
        } else {
          $target = $selectedColorAttr;
          error = '.productset-attribute-error';
        }

        var $attr = $target.closest('.attribute');
        $attr.find(error).removeClass('d-none').focus();
        return false;
      }

      if (showNoAttributeSelectedError($productContainer) === false) {
        return;
      }

      $('body').trigger('product:beforeAddToCart', this);

      if ($('.set-item').length && $(this).hasClass('add-to-cart-global')) {
        $('.product-flyout-close').trigger('click');
        setPids = [];
        $('.product-detail').each(function () {
          if (!$(this).hasClass('product-set-detail')) {
            setPids.push({
              pid: $(this).find('.product-id').text(),
              qty: $(this).find('.quantity-select').val(),
              options: getOptions($(this))
            });
          }
        });
        pidsObj = JSON.stringify(setPids);
        isProductSetFlyout = true;
      }

      pid = getPidValue($(this));

      if (!$productContainer.length) {
        $productContainer = $(this).closest('.quick-view-dialog').find('.product-detail');
      }

      addToCartUrl = getAddToCartUrl($(this), uuid);
      storeId = $(this).data('store-id');
      var form = {
        pid: pid,
        pidsObj: pidsObj,
        storeId: storeId,
        childProducts: getChildProducts(),
        quantity: getQuantitySelected($(this)),
        uuid: uuid,
        option: $(this).data('option'),
        isProductSetFlyout: isProductSetFlyout
      };

      if (!$('.bundle-item').length) {
        form.options = getOptions($productContainer);
      }

      if (uuid) {
        $('.modal-content').spinner().start();
      }

      $(this).trigger('updateAddToCartFormData', form);

      if ($(this).parent().hasClass('add-to-cart-and-pickup-button')) {
        isInStorePickUp = true;
      }

      if (addToCartUrl) {
        $.ajax({
          url: addToCartUrl,
          method: 'POST',
          data: form,
          success: function success(data) {
            // If added from Quickview in cart, reload the page to get the new cart items
            // TODO: create method to re-render the cart template
            if ($('.cart.cart-page, .cart.cart-empty').length) {
              location.reload();
            }

            if (data.productIsGated && data.korsvipModal !== '') {
              if ($('.set-item').length === 0) {
                $('#korsvipModal').remove();
                $('.product-detail').append(DOMpurify.sanitize(data.korsvipModal));
                $('#korsvipModal').insertAfter('#quickViewModal');
                $('#quickViewModal').modal('hide');
                $('#korsvipModal').modal('show');
                return false;
              }

              $('#korsvipModal').remove();

              if (addtobagsets.closest('.product-detail').hasClass('product-set-flyout-wrapper')) {
                $('.product-set-detail').append(DOMpurify.sanitize(data.korsvipModal));
                $('#korsvipModal').insertAfter('#quickViewModal');
                $('#quickViewModal').modal('hide');
                $('#korsvipModal').modal('show');
              } else {
                addtobagsets.closest('.product-detail').append(DOMpurify.sanitize(data.korsvipModal));
                $('#korsvipModal').insertAfter('#quickViewModal');
                $('#quickViewModal').modal('hide');
                $('#korsvipModal').modal('show');
                return false;
              }
            }

            if (data.error) {
              $.spinner().stop();
              clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, false);
              return false;
            }

            if (isInStorePickUp) {
              $('body').trigger('event:buyOnlinePickupInStore', data);
            }

            if (uuid) {
              var dataTosend = {
                data: data,
                shipmentType: 'storePickup'
              };
              $('.count-shipping-item-cart').empty().append('(' + DOMpurify.sanitize(data.cartModel.noOfEcomItems) + ')');
              $('body').trigger('shipmentChanged', dataTosend);
              $('body').trigger('event:productShipmentChange', data);
              return false;
            }

            $('.minicart').trigger('count:update', data);
            $('body').trigger('product:afterAddToCart', data.message);
            $('#inStoreInventoryModal').modal('hide').attr('showQuickView', false);
            $('body').trigger('event:addToCart', data);
            $.spinner().stop();
            miniCartReportingUrl(data.reportingURL);
            var isProductAdded = true;
            $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime]);
            var selector = '.minicart .popover';
            var timer = setTimeout(function () {
              $(selector).removeClass('show');
              $this.attr('tabindex', 0);
              $this.focus();
            }, data.miniBagFlyOutTimeinMilliSec);
            $('.minicart .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
            $(document).on('touchstart click', '#mkCloseMinicart', function () {
              setTimeout(function () {
                $this.attr('tabindex', 0);
                $this.focus();
              }, 100);
            });
          },
          error: function error(err) {
            $.spinner().stop();

            if (uuid) {
              clientSideUtil.floatToastMessage(err.responseJSON.errorMessage, err.responseJSON.toastMsgAndTimeOutSec.toastMessageDisplayTime, false);
            }
          }
        });
      }
    });
  },
  selectBonusProduct: function selectBonusProduct() {
    $(document).on('click', '.select-bonus-product', function () {
      var $choiceOfBonusProduct = $(this).parents('.choice-of-bonus-product');
      var pid = $(this).data('pid');
      var maxPids = $('.choose-bonus-product-dialog').data('total-qty');
      var submittedQty = parseInt($choiceOfBonusProduct.find('.bonus-quantity-select').val(), 10);
      var totalQty = 0;
      $.each($('#chooseBonusProductModal .selected-bonus-products .selected-pid'), function () {
        totalQty += $(this).data('qty');
      });
      totalQty += submittedQty;
      var optionID = $choiceOfBonusProduct.find('.product-option').data('option-id');
      var valueId = $choiceOfBonusProduct.find('.options-select option:selected').data('valueId');

      if (totalQty <= maxPids) {
        var selectedBonusProductHtml = '' + '<div class="selected-pid row" ' + 'data-pid="' + pid + '"' + 'data-qty="' + submittedQty + '"' + 'data-optionID="' + (optionID || '') + '"' + 'data-option-selected-value="' + (valueId || '') + '"' + '>' + '<div class="col-sm-11 col-9 bonus-product-name" >' + $choiceOfBonusProduct.find('.product-name').html() + '</div>' + '<div class="col-1"><i class="fa fa-times" aria-hidden="true"></i></div>' + '</div>';
        $('#chooseBonusProductModal .selected-bonus-products').append(selectedBonusProductHtml);
        $('.pre-cart-products').html(totalQty);
        $('.selected-bonus-products .bonus-summary').removeClass('alert-danger');
      } else {
        $('.selected-bonus-products .bonus-summary').addClass('alert-danger');
      }
    });
  },
  removeBonusProduct: function removeBonusProduct() {
    $(document).on('click', '.selected-pid', function () {
      $(this).remove();
      var $selected = $('#chooseBonusProductModal .selected-bonus-products .selected-pid');
      var count = 0;

      if ($selected.length) {
        $selected.each(function () {
          count += parseInt($(this).data('qty'), 10);
        });
      }

      $('.pre-cart-products').html(count);
      $('.selected-bonus-products .bonus-summary').removeClass('alert-danger');
    });
  },
  enableBonusProductSelection: function enableBonusProductSelection() {
    $('body').on('bonusproduct:updateSelectButton', function (e, response) {
      $('button.select-bonus-product', response.$productContainer).attr('disabled', !response.product.readyToOrder || !response.product.available);
      var pid = response.product.id;
      $('button.select-bonus-product', response.$productContainer).data('pid', pid);
    });
  },
  showMoreBonusProducts: function showMoreBonusProducts() {
    $(document).on('click', '.show-more-bonus-products', function () {
      var url = $(this).data('url');
      $('.modal-content').spinner().start();
      $.ajax({
        url: url,
        method: 'GET',
        success: function success(html) {
          var parsedHtml = parseHtml(html);
          $('.modal-body').append(parsedHtml.body);
          $('.show-more-bonus-products:first').remove();
          $('.modal-content').spinner().stop();
        },
        error: function error() {
          $('.modal-content').spinner().stop();
        }
      });
    });
  },
  addBonusProductsToCart: function addBonusProductsToCart() {
    $(document).on('click', '.add-bonus-products', function () {
      var $readyToOrderBonusProducts = $('.choose-bonus-product-dialog .selected-pid');
      var queryString = '?pids=';
      var url = $('.choose-bonus-product-dialog').data('addtocarturl');
      var pidsObject = {
        bonusProducts: []
      };
      $.each($readyToOrderBonusProducts, function () {
        var qtyOption = parseInt($(this).data('qty'), 10);
        var option = null;

        if (qtyOption > 0) {
          if ($(this).data('optionid') && $(this).data('option-selected-value')) {
            option = {};
            option.optionId = $(this).data('optionid');
            option.productId = $(this).data('pid');
            option.selectedValueId = $(this).data('option-selected-value');
          }

          pidsObject.bonusProducts.push({
            pid: $(this).data('pid'),
            qty: qtyOption,
            options: [option]
          });
          pidsObject.totalQty = parseInt($('.pre-cart-products').html(), 10);
        }
      });
      queryString += JSON.stringify(pidsObject);
      queryString = queryString + '&uuid=' + $('.choose-bonus-product-dialog').data('uuid');
      queryString = queryString + '&pliuuid=' + $('.choose-bonus-product-dialog').data('pliuuid');
      $.spinner().start();
      $.ajax({
        url: url + queryString,
        method: 'POST',
        success: function success(data) {
          $.spinner().stop();

          if (data.error) {
            $('#chooseBonusProductModal').modal('hide');

            if ($('.add-to-cart-messages').length === 0) {
              $('body').append('<div class="add-to-cart-messages"></div>');
            }

            $('.add-to-cart-messages').append(DOMpurify.sanitize('<div class="alert alert-danger add-to-basket-alert text-center">' + DOMpurify.sanitize(data.errorMessage) + '</div>'));
            setTimeout(function () {
              $('.add-to-basket-alert').remove();
            }, 20000);
          } else {
            $('.configure-bonus-product-attributes').html(DOMpurify.sanitize(data));
            $('.bonus-products-step2').removeClass('hidden-xl-down');
            $('#chooseBonusProductModal').modal('hide');

            if ($('.add-to-cart-messages').length === 0) {
              $('body').append('<div class="add-to-cart-messages"></div>');
            }

            $('.minicart-quantity').html(DOMpurify.sanitize(data.totalQty));
            $('.add-to-cart-messages').append(DOMpurify.sanitize('<div class="alert alert-success add-to-basket-alert text-center">' + DOMpurify.sanitize(data.msgSuccess) + '</div>'));
            setTimeout(function () {
              $('.add-to-basket-alert').remove();

              if ($('.cart-page').length) {
                location.reload();
              }
            }, 20000);
          }
        },
        error: function error() {
          $.spinner().stop();
        }
      });
    });
  },
  updateAddToCartCommon: function updateAddToCartCommon(response) {
    // update local add to cart (for sets)
    $('.quantity-select', response.$productContainer).attr('disabled', !response.product.readyToOrder);
    var inStock = response.product.variationAttributes.find(function (attribute) {
      if (attribute.attributeId === 'size') {
        return attribute.attributeId === 'size';
      }

      return attribute.attributeId === 'color';
    }).values.find(function (value) {
      return value.selected === true;
    }).inStock;

    if (inStock) {
      $('.quantity-select').attr('disabled', false);
    } else {
      $('.quantity-select').attr('disabled', true);
    }
  },
  getPidValue: getPidValue,
  observingBV: bvHelper.observingBV,
  getQuantitySelected: getQuantitySelected,
  miniCartReportingUrl: miniCartReportingUrl,
  sizeBoxCalc: updateSizeOptionWidth,
  updateImage: updateImage,

  /* Fluid Customization */
  addCustomProductToCart: addCustomProductToCart,
  showNoAttributeSelectedError: showNoAttributeSelectedError
};
module.exports = Object.assign(module.exports, base);

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/detail.js":
/*!************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/detail.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base = __webpack_require__(/*! ./base */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var reviewsPresent = false;
var scrollTwentyFiveTriggered = false;
var scrollFiftyTriggered = false;
/**
 * Enable/disable UI elements
 * @param {boolean} enableOrDisable - true or false
 */

function updateAddToCartEnableDisableOtherElements(enableOrDisable) {
  $('button.add-to-cart-global').attr('disabled', enableOrDisable);
}
/**
 * update loyalty points based on quantity
 */


function updateLoyaltyPoint() {
  var points = $('.loyal-point-js').attr('data-loyalty-point');
  var currentLocal = $('.loyal-point-js').data('locale').replace('_', '-');
  points = new Intl.NumberFormat(currentLocal).format(points);
  $('.loyal-point-message-js span').html(points);
}
/**
 * update reviews content styling
 * @param {*} matchedElement - matched element
 */


var updateReviewsContent = function updateReviewsContent(matchedElement) {
  var windowWidth = $(window).width();
  var maxContentWidth = 651;
  var reviewContent = $('.bv-rnr__sc-10ra6n1-0');
  var reviews = matchedElement ? $(matchedElement).length : null;

  if (reviews === null && !reviewsPresent && windowWidth >= SCREENSIZE.TABLETMIN) {
    reviewContent.css('text-align', 'center');
  } else {
    reviewContent.css('text-align', 'left');
  }

  if (reviews > 0 && windowWidth >= SCREENSIZE.DESKTOPMIN) {
    var contentWidth = windowWidth < 1224 ? maxContentWidth : reviewContent.width() / 3;
    $('.WwxUI').css('justify-content', 'flex-start');
    $('.eHQNnv').css({
      width: contentWidth,
      textAlign: 'center'
    });
  }

  if (reviews > 0 && windowWidth < 1224) {
    reviewContent.css('flex-direction', 'column');
  }
}; // Function to trigger scroll events


window.addEventListener('scroll', function () {
  var scrollPosition = Math.floor(window.scrollY);
  var pageHeight = document.documentElement.scrollHeight;
  var pageTwentyFiveHeight = Math.floor(pageHeight * 0.25);
  var pageFiftyHeight = Math.floor(pageHeight * 0.5);

  if (scrollPosition >= pageTwentyFiveHeight && !scrollTwentyFiveTriggered) {
    $('body').trigger('event:scroll25');
    scrollTwentyFiveTriggered = true;
  } else if (scrollPosition >= pageFiftyHeight && !scrollFiftyTriggered) {
    $('body').trigger('event:scroll50');
    scrollFiftyTriggered = true;
  }
});
module.exports = {
  methods: {
    updateAddToCartEnableDisableOtherElements: updateAddToCartEnableDisableOtherElements,
    updateLoyaltyPoint: updateLoyaltyPoint
  },
  availability: base.availability,
  addToCart: base.addToCart,

  /* Fluid Customization */
  addCustomProductToCart: base.addCustomProductToCart,
  updateIDForSelector: function updateIDForSelector() {
    $('.image-detail-container #quantity-1').parents('.product-set-detail.product-detail').not('.container').each(function (ind, ele) {
      $(ele).find('#quantity-1').attr('id', $(ele).attr('data-pid') + '-' + $(ele).find('#quantity-1').attr('id'));
      $(ele).find('.select-size').attr('id', $(ele).attr('data-pid') + '-' + $(ele).find('.select-size').attr('id'));
      $(ele).find('.select-size input').each(function (i, elem) {
        var currentElementId = $(elem).attr('id');
        $(elem).attr('id', $(ele).attr('data-pid') + '-' + currentElementId);
        $(elem).siblings().attr('for', $(ele).attr('data-pid') + '-' + currentElementId);
      });
      $(ele).find('[data-bv-show="rating_summary"]').attr('id', $(ele).attr('data-pid') + '-' + $(ele).find('[data-bv-show="rating_summary"]').attr('id'));
      $(ele).find('[data-bv-show="rating_summary"] ul').removeAttr('id');
    });
  },
  updateAttributesAndDetails: function updateAttributesAndDetails() {
    $('body').on('product:statusUpdate', function (e, data) {
      var $productContainer = $('.product-detail[data-pid="' + data.id + '"]');
      $productContainer.find('.description-and-detail .product-attributes').empty().html(data.attributesHtml);

      if (data.shortDescription) {
        $productContainer.find('.description-and-detail .description').removeClass('hidden-xl-down');
        $productContainer.find('.description-and-detail .description .content').empty().html(data.shortDescription);
      } else {
        $productContainer.find('.description-and-detail .description').addClass('hidden-xl-down');
      }

      if (data.longDescription) {
        $productContainer.find('.description-and-detail .details').removeClass('hidden-xl-down');
        $productContainer.find('.description-and-detail .details .content').empty().html(data.longDescription);
      } else {
        $productContainer.find('.description-and-detail .details').addClass('hidden-xl-down');
      }
    });
  },
  showSpinner: function showSpinner() {
    $('body').on('click', '.add-to-cart', function () {
      if ($(this).hasClass('add-to-cart-label-js')) {
        $.spinner().start();
      } else {
        $(this).closest('.modal-content').spinner().start();
      }
    });
  },
  updateColorAttributeName: function updateColorAttributeName() {
    $('.color-swatch .swatch-circle').on('mouseover', function () {
      $(this).closest('.color-swatch').find('.display-color-name').html(this.title);
    }).on('mouseleave', function () {
      var colorName = $(this).closest('.color-attribute-value').find('.swatch-circle.selected').attr('title');
      $(this).closest('.attribute.color-swatch').find('.display-color-name').html(colorName);
    });
    $(document).on('focus', '.color-attribute', function () {
      var colorTitle = $(this).find('.swatch-circle').attr('title');
      $(this).closest('.color-swatch').find('.display-color-name').html(colorTitle);
    });
  },
  updateAttribute: function updateAttribute() {
    $('body').on('product:afterAttributeSelect', function (e, response) {
      $('.attribute.size .attribute-error').addClass('d-none');

      if ($('.product-detail>.bundle-items').length) {
        response.container.data('pid', response.data.product.id);
        response.container.find('.product-id').text(response.data.product.id);
      } else if ($('.product-set-detail').eq(0)) {
        response.container.data('pid', response.data.product.id);
        response.container.find('.product-id').text(response.data.product.id);
      } else {
        $('.product-id').text(response.data.product.id);
        $('.product-detail:not(".bundle-item")').data('pid', response.data.product.id);
      }

      if ($('.loyal-details-container').length > 0) {
        updateLoyaltyPoint();
      }

      var currentSize = $('.size-option input:checked');

      if (currentSize) {
        currentSize.focus();
      }
    });
  },
  updateAddToCart: function updateAddToCart() {
    $('body').on('product:updateAddToCart', function (e, response) {
      base.updateAddToCartCommon(response);

      if (!response.product.available || !response.product.readyToOrder) {
        $('button.add-to-cart', response.$productContainer).text(response.product.soldOutLabel.pdp);
        $('button.add-to-cart', response.$productContainer).attr('disabled', true);
        $('.quantity.selector', response.$productContainer).addClass('d-none');
      } else {
        var addToCartLabel = $('button.add-to-cart', response.$productContainer).data('primary-label');
        $('button.add-to-cart', response.$productContainer).html(addToCartLabel);
        $('button.add-to-cart', response.$productContainer).attr('disabled', !response.product.available);
        $('.quantity.selector', response.$productContainer).removeClass('d-none');
      }

      module.exports.methods.updateAddToCartEnableDisableOtherElements(false);
    });
  },
  updateAvailability: function updateAvailability() {
    $('body').on('product:updateAvailability', function (e, response) {
      $('div.availability', response.$productContainer).data('ready-to-order', response.product.readyToOrder).data('available', response.product.available);
      $('.availability-msg li', response.$productContainer).empty().html(response.product.availability.messages[0] ? '<div class="availability text-uppercase">' + response.product.availability.messages[0] + '</div>' : '');

      if ($('.global-availability').length) {
        var allAvailable = $('.product-availability').toArray().every(function (item) {
          return $(item).data('available');
        });
        var allReady = $('.product-availability').toArray().every(function (item) {
          return $(item).data('ready-to-order');
        });
        $('.global-availability').data('ready-to-order', allReady).data('available', allAvailable);
        $('.global-availability .availability-msg li').empty().html(allReady ? response.product.availability.messages[0] : response.resources.info_selectforstock);
      }

      if (response.product.loyaltyPoints > 0) {
        $('.loyal-point-js').attr('data-loyalty-point', response.product.loyaltyPoints);
      }
    });
  },
  copyProductLink: function copyProductLink() {
    $('body').on('click', '#fa-link', function () {
      event.preventDefault();
      var $temp = $('<input>');
      $('body').append($temp);
      $temp.val($('#shareUrl').val()).select();
      document.execCommand('copy');
      $temp.remove();
      $('.copy-link-message').attr('role', 'alert');
      $('.copy-link-message').removeClass('d-none');
      setTimeout(function () {
        $('.copy-link-message').addClass('d-none');
      }, 3000);
    });
  },
  checkForSRPorPLP: function checkForSRPorPLP() {
    if (localStorage.isNavigatedFromSearchresults === 'true') {
      $('.srp-breadcrumb').removeClass('d-none');
      $('.backtoSRP').attr('href', localStorage.Url);
    } else {
      $('.plp-breadcrumb').removeClass('d-none');
    }
  },
  localStorageClearPDP: function localStorageClearPDP() {
    $(document).on('click', '.backtoSRP', function () {
      localStorage.removeItem('isNavigatedFromSearchresults');
    });
  },
  stickyAddToCart: function stickyAddToCart() {
    if (window.outerWidth <= SCREENSIZE.DESKTOPMIN) {
      var $paymentCTA = $('.quantity-addtocart-grid-pdp .add-to-cart-container');
      var addToBagCTAHeight = $paymentCTA.find('.add-to-cart').outerHeight();
      var headerHeight = $('header').outerHeight();
      $(window).scroll(function () {
        var addToCartTop = $('.prices-add-to-cart-actions').offset().top + addToBagCTAHeight;
        var currentTopPos = $(window).scrollTop() + headerHeight - addToBagCTAHeight;

        if (currentTopPos > addToCartTop) {
          $paymentCTA.addClass('sticky-btn');
          $('body').addClass('stick-add-to-cart');
        } else {
          $paymentCTA.removeClass('sticky-btn');
          $('body').removeClass('stick-add-to-cart');
        }
      });
    }
  },
  bazaarVoice: function bazaarVoice() {
    if ($('#data-bv-show').length) {
      $('.product-ratings').each(base.observingBV);
    }
  },
  observingReviewContent: function observingReviewContent() {
    var target = $('.reviews');

    if (target.length) {
      var callback = function callback(mutationsList, observer) {
        // eslint-disable-next-line array-callback-return
        var matchedElement = mutationsList.find(function (m) {
          if (m.attributeName === 'class' && $(m.target).hasClass('bv-rnr__sc-11r39gb-1')) {
            reviewsPresent = true;
            observer.disconnect();
            return m.target;
          }
        });
        updateReviewsContent(matchedElement);
      };

      var observerIns = new MutationObserver(callback);
      observerIns.observe(target.get(0), {
        childList: true,
        subtree: true,
        attributeFilter: ['class']
      });
    }
  },
  shopThisLook: function shopThisLook() {
    $('.js-shop-this-look').not('.slick-initialized').slick({
      slidesToShow: 1,
      slidesToScroll: 1,
      accessibility: true
    });
  },
  monogramEngraveContainer: function monogramEngraveContainer() {
    var fluidPage = $('body').find('.container-fluid.product-detail');

    if (fluidPage.length > 0) {
      $('div#maincontent div.container').first().addClass('fluidMEContainer');
    } else {
      $('div#maincontent div.container').removeClass('fluidMEContainer');
    }
  },
  updateKorsVIP: function updateKorsVIP() {
    var loyaltyCustomer = $('body').find('.js-loyalty-customer');
    var authenticatedCustomer = $('.authenticated-user');
    var loyaltyContainer = $('.loyal-details-container');

    if (authenticatedCustomer.length === 0) {
      loyaltyContainer.find('.loyal-account-container').removeClass('d-none');
    } else if (authenticatedCustomer.length > 0 && loyaltyCustomer.length === 0) {
      var korsvipurl = $('.js-join-korsvip')[0].dataset.korsvipUrl;
      loyaltyContainer.find('.loyal-account-container').removeClass('d-none');
      loyaltyContainer.find('a.account-link').attr('href', korsvipurl);
    }
  },
  initialLoadPDP: function initialLoadPDP() {
    $(window).on('load', function () {
      // ToDo: Add trigger event for wishlist functionality
      var productDetails = $('.product-detail');
      var wishlistedProducts = $('.wishlistedItems').length > 0 ? $('.wishlistedItems').val().split(',') : [];

      if (productDetails.length === 1) {
        if (wishlistedProducts && wishlistedProducts.includes(productDetails.data('pid').toString())) {
          productDetails.find('.add-fav-heart').addClass('d-none');
          productDetails.find('.add-to-favorites').addClass('d-none');
          productDetails.find('.remove-fav-heart').removeClass('d-none');
          productDetails.find('.remove-from-favorites').removeClass('d-none');
        } else {
          productDetails.find('.add-fav-heart').removeClass('d-none');
          productDetails.find('.add-to-favorites').removeClass('d-none');
          productDetails.find('.remove-fav-heart').addClass('d-none');
          productDetails.find('.remove-from-favorites').addClass('d-none');
        }

        $('body').trigger('event:pdpVisit');
      }
    });
  },
  sizeBoxCalc: base.sizeBoxCalc,
  sizeChart: base.sizeChart(),
  focusChooseBonusProductModal: base.focusChooseBonusProductModal()
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/favorites.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/favorites.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var wishlisthelper = __webpack_require__(/*! ./wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js");

var isWishlistMobileEnabled = $('.right-nav').find('.wishlist-icon').hasClass('wishlist-icon-js');

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() <= SCREENSIZE.TABLETMAX;
/**
 * appends params to a url
 * @param {string} data - data returned from the server's ajax call
 * @param {Object} button - button that was clicked to add a product to the favorites
 */

function displayMessage(data) {
  $.spinner().stop();
  var status;
  var message = data.msg ? data.msg : data.productRemovedMsg;

  if (data.success) {
    status = 'alert-success';
  } else {
    status = 'alert-danger';
  }

  if ($('.add-to-wishlist-messages').length === 0) {
    $('body').append('<div class="add-to-wishlist-messages "></div>');
  }

  $('.add-to-wishlist-messages').empty().append('<div class="add-to-wishlist-alert text-center ' + status + '">' + message + '</div>');
}
/**
 * Show/hide favorite icons and buttons
 * @param {Object} productDetail - product detail container element
 * @param {Object} element - current fav button
 */


function toggleFavorites(productDetail, element) {
  if (productDetail) {
    var detailContainer = productDetail; // Check if set product

    var productSet = detailContainer.find('.product-set-detail.product-wrapper');

    if (productSet.length > 0) {
      detailContainer = productSet;
    }

    detailContainer.find('.btn-favorite').toggleClass('d-none');

    if ($(element).length && $(element).hasClass('btn-favorite')) {
      $(element).siblings('.btn-favorite').focus();
    }
  }
}
/**
 * Show/hide add to favorite buttons
 * @param {Object} isFavoriteProduct - is in favorites list
 * @param {element } productDetail - response object
 */


function updateFavorites(isFavoriteProduct, productDetail) {
  if (isFavoriteProduct !== undefined && productDetail) {
    productDetail.find('.btn-favorite').addClass('d-none');

    if (isFavoriteProduct) {
      productDetail.find('.remove-fav-heart').removeClass('d-none');
      productDetail.find('.remove-from-favorites').removeClass('d-none');
    } else {
      productDetail.find('.add-to-favorites').removeClass('d-none');
      productDetail.find('.add-fav-heart').removeClass('d-none');
    }
  }
}

module.exports = {
  addToFavorites: function addToFavorites() {
    $(document).on('click', '.add-to-favorites, .add-fav-heart', function (e) {
      e.preventDefault();
      var element = $(this);
      var pid = element.closest('.product-detail').attr('data-pid');
      var url = element.data('href');
      var optionId = element.closest('.product-detail').find('.product-option').attr('data-option-id');
      var optionVal = element.closest('.product-detail').find('.options-select option:selected').attr('data-value-id');
      var $targetPLPTile = $('.product-tile-show[data-pid=' + pid + ']');
      $('div').removeClass('active-favorites-ada-btn');
      $(this).closest('div').addClass('active-favorites-ada-btn');
      optionId = optionId || null;
      optionVal = optionVal || null;

      if (!url || !pid) {
        return;
      }

      $.spinner().start();
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: {
          pid: pid,
          optionId: optionId,
          optionVal: optionVal
        },
        success: function success(data) {
          var isSuccess = true;

          if ($('.product-quickview.product-detail').length > 0) {
            clientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          } // If favorited from te quickview on cart page, reload the page
          // TODO: create method to re-render the cart template


          if ($('.cart.cart-page').length) {
            location.reload();
          }

          $.spinner().stop();
          toggleFavorites(element.closest('.product-detail'), element);
          $('body').trigger('event:addProductToFavourites', data);
          $targetPLPTile.find('.wishlistTile.add-wish-list').addClass('d-none');
          $targetPLPTile.find('.wishlistTile.remove-from-wishlist').removeClass('d-none');
          wishlisthelper.updateHeaderHeartIcon(data.wishlistedItems);

          if (isWishlistMobileEnabled || !isMobile) {
            wishlisthelper.popupdisplay(true, {
              addWishlist: true,
              removeWishlist: false,
              toastTime: data.toastMessageDisplayTime
            });
            var timer = setTimeout(function () {
              $('.miniwishlist .popover').removeClass('show');
            }, data.miniFavouriteFlyOutTimeinMilliSec);
            $('.miniwishlist .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
          } else {
            clientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }
        },
        error: function error(err) {
          displayMessage(err, element);
        }
      });
      return false;
    });
  },
  removeFromFavorites: function removeFromFavorites() {
    $(document).on('click', '.remove-from-favorites, .remove-fav-heart', function (e) {
      e.preventDefault();
      var element = $(this);
      var pid = element.closest('.product-detail').data('pid');
      var url = element.data('href');
      var $targetPLPTile = $('.product-tile-show[data-pid=' + pid + ']');
      url = url + '?pid=' + pid;

      if (!url || !pid) {
        return;
      }

      $.spinner().start();
      $.ajax({
        url: url,
        type: 'get',
        dataType: 'json',
        data: {},
        success: function success(data) {
          var isSuccess = true;

          if ($('.product-quickview.product-detail').length > 0) {
            clientSideUtil.floatToastMessage(data.productRemovedMsg, data.toastMessageDisplayTime, isSuccess);
          }

          $.spinner().stop();
          toggleFavorites(element.closest('.product-detail'), element);
          $('body').trigger('event:removeProductFromFavourites', data);
          $targetPLPTile.find('.wishlistTile.remove-from-wishlist').addClass('d-none');
          $targetPLPTile.find('.wishlistTile.add-wish-list').removeClass('d-none');
          wishlisthelper.updateHeaderHeartIcon(data.wishlistedItems);

          if (isWishlistMobileEnabled || !isMobile) {
            wishlisthelper.popupdisplay(true, {
              addWishlist: false,
              removeWishlist: true,
              toastTime: data.toastMessageDisplayTime
            });
            var timer = setTimeout(function () {
              $('.miniwishlist .popover').removeClass('show');
            }, data.miniFavouriteFlyOutTimeinMilliSec);
            $('.miniwishlist .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
          } else {
            clientSideUtil.floatToastMessage(data.productRemovedMsg, data.toastMessageDisplayTime, isSuccess);
          }
        },
        error: function error(err) {
          displayMessage(err, element);
        }
      });
      return false;
    });
  },
  toggleFavorites: toggleFavorites,
  updateFavorites: updateFavorites
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/localizeSizeLabels.js":
/*!************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/localizeSizeLabels.js ***!
  \************************************************************************************************/
/***/ (function(module) {

"use strict";


module.exports = {
  localizeSizeLabels: function localizeSizeLabels() {
    var $inputWrappers = $('[data-sizecountry]');
    $inputWrappers.each(function (index, element) {
      var locale = $(element).parents('[role="tabpanel"]').data('locale');
      var sizeData = $(element).data('sizecountry');

      if (sizeData && locale && sizeData[locale]) {
        var localizedLabel = sizeData[locale]; // Update visible label

        var $label = $(element).find('label');
        $label.text(localizedLabel); // Update aria label
        // Note: this updates the aria label with the localized size label but does NOT localize the rest of the aria label.
        // (For example: in "Size S in stock", only the "S" will change.)

        var isInStock = $(element).data('isinstock');
        var ariaLabelBase = isInStock ? $(element).data('ariaLabelInStock') : $(element).data('ariaLabelOutOfStock');
        var localizedAriaLabel = ariaLabelBase.replace('{0}', localizedLabel);
        var $input = $(element).find('input');
        $input.attr('aria-label', localizedAriaLabel);
      }
    }); // Find tabs and tabPanels

    var $tabList = $('.size-locale-tabs');
    var $tabs = $tabList.find("[role='tab']");
    var tabs = [];
    var tabPanels = [];
    $tabs.each(function (index, tab) {
      tabs.push($(tab));
      var tabPanelId = $(tab).attr('aria-controls');
      tabPanels.push($("#".concat(tabPanelId)));
    }); // Add click handler

    $tabs.each(function (index, tab) {
      $(tab).on('click', function (event) {
        var $selectedTab = $(event.target);
        var $selectedTabPanel = $("#".concat($selectedTab.attr('aria-controls'))); // "Unselect" all tabs

        $tabs.attr('aria-selected', false).removeClass('selected'); // Set this tab as selected

        $selectedTab.attr('aria-selected', true).addClass('selected'); // Hide all tab panels

        tabPanels.forEach(function (tabPanel) {
          $(tabPanel).attr('hidden', true);
          $(tabPanel).attr('aria-expanded', false);
        }); // Show the selected panel

        $selectedTabPanel.attr('aria-expanded', true);
        $selectedTabPanel.removeAttr('hidden');
      });
    }); // Add arrow navigation

    var tabFocus = 0;
    $tabList.on('keydown', function (event) {
      if (event.key === 'ArrowRight' || event.key === 'ArrowLeft') {
        // "Unselect" selected tab
        tabs[tabFocus].attr('tabindex', -1);

        if (event.key === 'ArrowRight') {
          // Move right
          tabFocus++; // If we're at the end, go to the start

          if (tabFocus >= tabs.length) {
            tabFocus = 0;
          }
        } else if (event.key === 'ArrowLeft') {
          // Move left
          tabFocus--; // If we're at the start, move to the end

          if (tabFocus < 0) {
            tabFocus = tabs.length - 1;
          }
        } // Select new tab


        tabs[tabFocus].attr('tabindex', 0);
        tabs[tabFocus].focus();
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/productImages.js":
/*!*******************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/productImages.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isDesktop = $(window).width() > SCREENSIZE.DESKTOPMIN;
var isFluid = window.configureParams ? 'true' : 'false';

var imageZoom = __webpack_require__(/*! ../thirdParty/zoom */ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/zoom.js");

var mediaZoom = __webpack_require__(/*! ../thirdParty/mediaZoom */ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/mediaZoom.js");

var debounce = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");

var isQuickView = function isQuickView() {
  return $('body').find('#quickViewModal').length > 0;
};

var isEditModal = function isEditModal() {
  return $('body').find('#editWishlistProductModal').length > 0;
};

var isMobile = $(window).width() <= SCREENSIZE.DESKTOPMIN;
var arr = [];
var productDetailsPosTop;
var imageListPosTop;
var initialImageWidth = false; // const $pdpContainer = $('.image-detail-container');

var $imageListContainer = $('.js-large-images');
var $imageList = $('.js-large-images-list');
var $thumbnail = $('.js-thumbnail-images');
var $productContent = $('.js-product-detail');
var $pdpStickyStopper = $('.pdp-sticky-stopper'); // const imageListCount = $imageList.children('li').length;

var $thumbnailNextBtn = $('.js-next-btn');
var $thumbnailPrevBtn = $('.js-prev-btn');
/**
 * Smooth scroll to product images on clicking thumbnail
 * @param {$thumbnailID} tid - passing thumnail ID
 *
 */

function productSmoothScroll(tid) {
  var $largeImageID = $('.large-' + tid);
  var $headerHeight = $('header').height();
  var $position = $largeImageID.offset().top - $headerHeight;
  $('html, body').animate({
    scrollTop: $position
  }, 500);
}
/**
 * Get image ID on click
 *
 */


function getImageID() {
  $('.js-thumbnail-btn').on('click.desktop', function () {
    var $thumbnailID = $(this).data('thumbnail');

    if (!$(this).hasClass('active')) {
      productSmoothScroll($thumbnailID);
    }
  });
}
/**
 * Navigate to previous image when clicking prev thumbnail
 *
 */


function previousThumbnail() {
  $('.js-prev-btn').on('click.desktop', function () {
    var $currentThumb = $('.js-thumbnail-btn.active');
    var $previousThumb = $currentThumb.prev('.js-thumbnail-btn');
    var $thumbID = $previousThumb.data('thumbnail');

    if ($previousThumb.length !== 0) {
      productSmoothScroll($thumbID);
    }
  });
}
/**
 * Navigate to next image when clicking prev thumbnail
 *
 */


function nextThumbnail() {
  $('.js-next-btn').on('click.desktop', function () {
    var $currentThumb = $('.js-thumbnail-btn.active');
    var $nextThumb = $currentThumb.next('.js-thumbnail-btn');
    var $thumbID = $nextThumb.data('thumbnail');

    if ($nextThumb.length !== 0) {
      productSmoothScroll($thumbID);
    }
  });
}
/**
 * Adding class active to first thumbnail on default
 *
 */


function defaultActive() {
  $('.js-thumbnail-btn:eq(0)').addClass('active');
}
/**
 * Resets zoom to 0%
 *
 */


function resetImgZoom() {
  var $zoomedContainers = $('.zoom');

  if ($zoomedContainers.length) {
    $zoomedContainers.each(function () {
      var $zoomedImg = $(this).children('img');
      $zoomedImg.attr({
        'data-scale': 1,
        'data-translate-x': 0,
        'data-translate-y': 0
      }).removeAttr('style');
      $zoomedContainers.removeClass('zoom-active');
    });
  }
}
/**
 * Sets Thumbnail to match active slide
 *  @param {string} nextSlide - Slider Slider next slide index
 *
 */


function setActiveThumbnail(nextSlide) {
  var deviceWidth = window.outerWidth;
  var $thumbnailContainer = $('.thumbnail-images');
  var $targetThumbnail = $(".thumbnail-".concat(nextSlide));
  var targetThumbnailPos = $targetThumbnail.offset().left;
  $('.js-thumbnail-btn').removeClass('active');
  $targetThumbnail.addClass('active');

  if (targetThumbnailPos < 0) {
    $thumbnailContainer.scrollLeft(0);
  } else if (targetThumbnailPos + $targetThumbnail.outerWidth() > deviceWidth) {
    $thumbnailContainer.scrollLeft(targetThumbnailPos);
  }
}
/**
 * When clicking on a mobile thumbnail, navigate slider
 *
 */


function mobileThumbnailClick() {
  $('.js-thumbnail-btn').on('click.mobile', function () {
    var targetSlide = $(this).index();
    $('.js-large-images-list').slick('slickGoTo', targetSlide);
  });
}
/**
 * Setup for image zoom functionality on mobile
 */


function imageZoomConfig() {
  // eslint-disable-next-line no-undef
  imageZoom.zoom({
    active: 'zoom-active',
    transition: 'zoom-transition',
    visible: 'visible',
    zoom: 'zoom' // Image container class

  }, {
    scaleDefault: 2.5,
    // Used on doubleclick, doubletap and resize
    scaleMax: 4,
    // Maximum zoom
    scaleMin: 1,
    // Minimum zoom
    transitionDuration: 200,
    // This should correspond with zoom-transition transition duration
    doubleclickDelay: 300,
    // Delay between clicks - used when scripts decides if user performed doubleclick or not
    slickCarousel: 'js-large-images-list',
    // Slick Carousel parent element
    isMobile: isMobile,
    // source is mobile or not
    hideThumbnail: $('.js-hide-thumbnail-images-wrapper').length > 0 // toggled on/off show thumbnail config

  }, function (container, zoomActive) {
    var $zoomImg = $(container).find('img');
    var hiResImg = $zoomImg.data('zoom-image');

    if (hiResImg) {
      $zoomImg.attr('src', hiResImg);
    }

    $('.js-large-images-list').not('.slick-initialized').slick('slickSetOption', {
      touchMove: !zoomActive,
      swipe: !zoomActive
    });
  });
}
/**
 * Setup mobile image carousel and zoom functionality
 *
 */


function mobileZoomImagesInt() {
  var productCarousel = '.js-product-carousel';
  var productSlidesCount = $(productCarousel).data('slides-to-show');
  var productArrows = $(productCarousel).data('arrows');
  var productDots = true;
  var $mobileImagesList = $('.js-large-images-list');
  var isThumbnailEnabled = $('.thumbnail-wrapper').data('is-thumbnail-visible'); // Rearrange the thumbnails to be after the mobile carousel

  $('.thumbnail-wrapper').insertAfter('.large-images-wrapper').removeClass('hidden-md-down');
  $('.thumbnails-shimmer').remove();
  $thumbnailNextBtn.remove();
  $thumbnailPrevBtn.remove();
  $mobileImagesList.on('init.mobile', function () {
    mobileThumbnailClick();
  });

  if ($('.hide-dot-indicator').length > 0) {
    productDots = false;
  }

  if (isThumbnailEnabled) {
    productArrows = $(productCarousel).data('arrows');
    productDots = false;
  }

  $($mobileImagesList).not('.slick-initialized').slick({
    slidesToShow: productSlidesCount,
    slidesToScroll: 1,
    accessibility: true,
    arrows: productArrows,
    dots: productDots,
    swipe: true
  });
  $imageList.on('beforeChange.mobile', function (event, slick, currentSlide, nextSlide) {
    if (currentSlide === nextSlide) {
      return false;
    }

    resetImgZoom();
    setActiveThumbnail(nextSlide);
  });
  imageZoomConfig();
}
/**
 * on page scroll or accordion click switch the thumbnail accordingly
 *
 */


function switchThumbnail() {
  var $windowScroll = $(window).scrollTop();
  var headerHeight = $('header').outerHeight();
  var $length = $('.js-large-images li').length; // Set the active thumbnail to the main image in view

  for (var j = 0; j <= $length - 1; j++) {
    // determining which image has the scollbar crossed
    arr[j] = $('.js-large-images li:eq(' + j + ')').offset().top - headerHeight - 2;

    if ($windowScroll > arr[j]) {
      $('.js-thumbnail-btn').removeClass('active');
      $('.thumbnail-' + j).addClass('active');
    }
  }
}
/**
 * On scroll, keeps the left side thumbnail bar stick until bottom of images
 *
 */


function stickyThumbnail() {
  var thumbnailYPos = $thumbnail.length > 0 ? $thumbnail.offset().top : 0;
  var thumbnailHeight = $thumbnail.length > 0 ? $thumbnail.outerHeight() : 0;
  $(window).on('scroll.desktop', function () {
    var stickyStopTopOffset = $pdpStickyStopper.offset().top;
    var $windowScroll = $(window).scrollTop();
    var headerHeight = $('header').outerHeight();

    if ($windowScroll + thumbnailHeight + headerHeight + 50 >= stickyStopTopOffset) {
      $thumbnail.removeClass('sticky');
      $thumbnail.addClass('bottom');
    } else if (thumbnailYPos - headerHeight <= $windowScroll) {
      $thumbnail.addClass('sticky');
      $thumbnail.removeClass('bottom');
    }

    switchThumbnail();
  });
}
/**
 * @function resetProductDetailsLeftMargin
 * @description Sets explicit left margin on product details element. Helper function to ensure left/right alignment remains consistent while scrolling.
 */


function resetProductDetailsLeftMargin() {
  $productContent.css({
    marginLeft: ''
  });
  $productContent.css({
    marginLeft: $productContent.css('margin-left')
  });
}
/**
 * Sticky Product Details
 *
 */


function stickyProductDetails() {
  var stickyStopTopOffset = $pdpStickyStopper.offset().top;
  var lastScrollTop = 0; // Padding to offset the sticky scrolling element from the top of the screen.

  var visualPadding = 20; // Set fixed left margin to ensure left/right alignment remains consistent while scrolling

  resetProductDetailsLeftMargin();
  $(window).on('resize.desktop', debounce(function () {
    resetProductDetailsLeftMargin();
  }, 0));
  $(window).on('scroll.desktop', debounce(function () {
    var productImageContainerHeight = $imageList.outerHeight();
    var productDetailsHeight = $productContent.outerHeight();
    var productDetailsOffsetTop = $productContent.offset().top;
    var $windowScroll = $(window).scrollTop();
    var headerHeight = $('header').outerHeight();
    var $windowHeight = $(window).scrollTop() + window.innerHeight;
    var lastOffset = $productContent.offset().top + ($productContent.height() - 10); // adding min section shown while fixed scrolling (buffer value - 200px)

    var endpoint = $imageList.offset().top + $imageList.height();
    var productcontentTotal = $productContent.height() + $('.product-detail-container').offset().top;
    var scrollDirection = '';
    var currentScroll = $(this).scrollTop();

    if (currentScroll > lastScrollTop) {
      scrollDirection = 'down';
    } else {
      scrollDirection = 'up';
    }

    lastScrollTop = currentScroll;

    if (productcontentTotal > window.innerHeight) {
      if (scrollDirection === 'down' && productImageContainerHeight > productDetailsHeight) {
        $imageListContainer.removeClass('bottom');

        if ($windowHeight > lastOffset && $windowHeight < endpoint && window.innerHeight < stickyStopTopOffset) {
          // become sticky on scroll
          productDetailsPosTop = $productContent.offset().top - headerHeight - 20;
          $productContent.removeClass('sticky');
          $productContent.css({
            position: 'fixed',
            top: '',
            bottom: 0,
            width: '100%'
          });
        } else if ($windowHeight > stickyStopTopOffset) {
          $productContent.css({
            position: 'absolute',
            top: '',
            bottom: 0
          });
        } else if ($windowHeight > endpoint && window.innerHeight < stickyStopTopOffset) {
          // Stick to the bottom
          $productContent.removeClass('sticky');
          $productContent.css({
            position: 'absolute',
            top: 'auto',
            bottom: 0
          });
        } else {
          $productContent.removeClass('sticky');
          $productContent.css({
            position: '',
            top: '',
            bottom: ''
          });
        }
      } else if (scrollDirection === 'up' && productImageContainerHeight > productDetailsHeight && window.innerHeight < stickyStopTopOffset) {
        // Remain in place so user can scroll up
        $productContent.removeClass('sticky');

        if ($windowHeight > endpoint) {
          $productContent.css({
            position: 'absolute',
            top: '',
            bottom: 0
          });
        } else {
          $productContent.css({
            position: 'absolute',
            top: productDetailsPosTop,
            bottom: ''
          });
        }

        if ($windowScroll === 0) {
          $productContent.removeClass('sticky');
          $productContent.css({
            position: 'initial',
            top: '',
            bottom: ''
          });
        } else if ($windowScroll + 10 < productDetailsOffsetTop - headerHeight && window.innerHeight < stickyStopTopOffset) {
          // Re-stick and stay stuck while scrolling up
          $productContent.addClass('sticky');
          $productContent.css({
            position: '',
            top: headerHeight + visualPadding,
            bottom: ''
          });
        }
      }
    } else {
      $productContent.addClass('sticky');
      $productContent.css({
        position: '',
        top: headerHeight + visualPadding,
        bottom: ''
      });
    }
  }, 0));
}
/**
 * Sticky Desktop Main Image
 *
 */


function stickyMainProductImage() {
  // let stickyStopTopOffset = $pdpStickyStopper.offset().top;
  // let imageListYPos = $imageListContainer.offset().top;
  var $windowHeight = $(window).scrollTop() + window.innerHeight;
  var endpoint = $productContent.offset().top + $productContent.height();
  var productDetailsHeight = $productContent.outerHeight();
  var productImageContainerHeight = $imageList.outerHeight();
  var headerHeight = $('header').outerHeight();
  var zoomOutValue = window.innerHeight - headerHeight - $('.js-large-images-list li').height();
  var lastOffset = $imageList.height() + ($imageList.offset().top - 10) + (zoomOutValue >= 1 ? zoomOutValue : 0);
  var imageListTotal = $imageList.height() + $('.image-detail-container').offset().top;
  $imageListContainer.css({
    position: '',
    top: '',
    bottom: ''
  });

  if (imageListTotal > window.innerHeight) {
    if ($windowHeight > lastOffset && $windowHeight < endpoint && productImageContainerHeight < productDetailsHeight) {
      $imageListContainer.removeClass('top').addClass('sticky');

      if (zoomOutValue >= 1) {
        $imageListContainer.css('bottom', zoomOutValue);
      }

      imageListPosTop = $imageListContainer.offset().top - headerHeight - 20;
    } else if ($windowHeight > endpoint && productImageContainerHeight < productDetailsHeight) {
      $imageListContainer.removeClass('top').removeClass('sticky').addClass('bottom');
      $imageListContainer.css('bottom', '');
      imageListPosTop = $imageListContainer.offset().top - headerHeight - 20;
    } else {
      $imageListContainer.removeClass('sticky').removeClass('bottom').removeClass('top');
      $imageListContainer.css('bottom', '');
      imageListPosTop = $imageListContainer.offset().top - headerHeight - 20;
    }
  } else if (productImageContainerHeight < productDetailsHeight) {
    $imageListContainer.removeClass('sticky').removeClass('bottom').addClass('top');
    $imageListContainer.css('bottom', '');
  }
}
/**
 * Sets large image container width
 * @param {string} minDesktopWidth - minimum desktop width
 * @param {string} imgWidth - width of large image
 */


function initImageWidth(minDesktopWidth, imgWidth) {
  if (minDesktopWidth) {
    $imageListContainer.css({
      width: imgWidth,
      'min-width': imgWidth
    });
    $('.large-images-container').css({
      width: imgWidth,
      'min-width': imgWidth
    });
  }

  $imageListContainer.css({
    width: $imageListContainer.outerWidth(),
    'min-width': $imageListContainer.outerWidth()
  });
}
/**
 * @function resetImageListContainerWidth
 * @description Sets explicit width on image list container element. Helper function to ensure width remains consistent while scrolling.
 */


function resetImageListContainerWidth() {
  var minDesktop = isDesktop && $(window).width() < 1200;
  var imageWidth;

  if (!initialImageWidth) {
    initialImageWidth = true; // wait until page load to set image container width

    $(window).on('load', function () {
      imageWidth = $('.large-images img').width();
      initImageWidth(minDesktop, imageWidth);
    });
  } else {
    imageWidth = $('.large-images img').width();
    initImageWidth(minDesktop, imageWidth);
  }
}
/**
 * Sticky Desktop Main Image
 *
 */


function stickyMainProductImageHandler() {
  var lastScrollTop = 0;
  resetImageListContainerWidth();
  $(window).on('resize', debounce(function () {
    $imageListContainer.css({
      width: '',
      'min-width': ''
    });
    $('.large-images-container').css({
      width: '',
      'min-width': ''
    });
    resetImageListContainerWidth();
  }, 0));
  $(window).on('scroll.desktop', function () {
    var stickyStopTopOffset = $pdpStickyStopper.offset().top;
    var productDetailsHeight = $productContent.outerHeight();
    var productImageContainerHeight = $imageList.outerHeight();
    var imageListYPos = $imageListContainer.offset().top;
    var $windowScroll = $(window).scrollTop();
    var headerHeight = $('header').outerHeight();
    var scrollDirection = '';
    var currentScroll = $(this).scrollTop();

    if (currentScroll > lastScrollTop) {
      scrollDirection = 'down';
    } else {
      scrollDirection = 'up';
    }

    lastScrollTop = currentScroll;

    if (scrollDirection === 'down') {
      stickyMainProductImage();
    } else if (scrollDirection === 'up') {
      // Re-stick and stay stuck while scrolling up
      if (productImageContainerHeight < productDetailsHeight && window.innerHeight + $windowScroll < stickyStopTopOffset) {
        $imageListContainer.removeClass('sticky').removeClass('bottom').removeClass('top');
        $imageListContainer.css({
          position: 'absolute',
          top: imageListPosTop,
          bottom: 'auto'
        });
      }

      if (imageListYPos - headerHeight > $windowScroll && $windowScroll > $productContent.offset().top - headerHeight && productImageContainerHeight < productDetailsHeight) {
        $imageListContainer.removeClass('bottom').addClass('top');
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });
      } else if ($productContent.offset().top - headerHeight > $windowScroll && productImageContainerHeight < productDetailsHeight) {
        $imageListContainer.removeClass('bottom').removeClass('top');
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });
      }
    }
  });
}
/**
 * on accordion click retain sticky behavior only for desktop
 *
 */


function onAccordionClick() {
  $(window).on('collapsible:toggle.desktop', function (e, collapsibleEl) {
    // Product Details Column
    var $windowScroll = $(window).scrollTop();
    var headerHeight = $('header').outerHeight();
    var productDetailsHeight = $productContent.outerHeight();
    var stickyStopTopOffset = $pdpStickyStopper.offset().top;
    var productDetailsOffsetTop = $productContent.offset().top;
    var productImageContainerHeight = $imageList.outerHeight(); // const imageEndPoint = $imageList.height() + $imageList.offset().top;

    var productcontentTotal = $productContent.height() + $productContent.offset().top;
    var $windowHeight = $(window).scrollTop() + window.innerHeight;
    var visualPadding = 20; // Listen to the collapsibleItem.js custom event to check if details or design section is opened
    // if a different collapsible item is toggled, exit the function instead

    var collapsibleToggle = false;

    if ($(collapsibleEl).length && $(collapsibleEl).hasClass('pdp-design-details')) {
      collapsibleToggle = true;
    } else if ($(collapsibleEl).length && !$(collapsibleEl).hasClass('pdp-design-details')) {
      return false;
    }

    if (collapsibleToggle) {
      if ($windowHeight > stickyStopTopOffset) {
        if (productImageContainerHeight < productDetailsHeight) {
          $imageListContainer.removeClass('sticky').addClass('bottom');
          $imageListContainer.css({
            position: '',
            top: '',
            bottom: ''
          });
        }
      }

      if (productImageContainerHeight < productDetailsHeight) {
        $imageListContainer.removeClass('bottom').addClass('sticky');
        $productContent.removeClass('sticky');
        $productContent.css({
          position: 'static',
          top: 0,
          bottom: 'auto'
        });
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });

        if ($windowHeight > productcontentTotal) {
          $imageListContainer.removeClass('sticky').addClass('bottom');
        }
      } else {
        $imageListContainer.removeClass('bottom').removeClass('top');
        $productContent.addClass('sticky');
        $productContent.css({
          position: '',
          top: '0'
        });
        productDetailsPosTop = $productContent.offset().top - headerHeight - 20;
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });
      }

      if ($windowScroll + 10 < productDetailsOffsetTop - headerHeight && productImageContainerHeight > productDetailsHeight) {
        // Re-stickto top if product detail height allows to see the whole sidebar
        $productContent.addClass('sticky');
        $productContent.css({
          position: '',
          top: headerHeight + visualPadding,
          bottom: ''
        });
      }

      stickyMainProductImage();
    }

    switchThumbnail();
  });
}
/**
 * on send by dropdown change retain sticky behavior only for desktop
 *
 */


function onSendByTypeChange() {
  $('body').on('change.desktop', '#gctype', function () {
    var $windowScroll = $(window).scrollTop();
    var headerHeight = $('header').outerHeight();
    var productDetailsHeight = $productContent.outerHeight();
    var stickyStopTopOffset = $pdpStickyStopper.offset().top;
    var productDetailsOffsetTop = $productContent.offset().top;
    var productImageContainerHeight = $imageList.outerHeight();
    var productcontentTotal = $productContent.height() + $productContent.offset().top;
    var $windowHeight = $(window).scrollTop() + window.innerHeight;
    var visualPadding = 20;
    var sendByChange = $('.js-gctype option:selected').data('gctype');

    if (sendByChange === 'virtual') {
      if ($windowHeight > stickyStopTopOffset) {
        if (productImageContainerHeight < productDetailsHeight) {
          $imageListContainer.removeClass('sticky').addClass('bottom');
          $imageListContainer.css({
            position: '',
            top: '',
            bottom: ''
          });
        }
      }

      if (productImageContainerHeight < productDetailsHeight) {
        $imageListContainer.removeClass('bottom').addClass('sticky');
        $productContent.removeClass('sticky');
        $productContent.css({
          position: 'static',
          top: 0,
          bottom: 'auto'
        });
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });

        if ($windowHeight > productcontentTotal) {
          $imageListContainer.removeClass('sticky').addClass('bottom');
        }
      } else {
        $imageListContainer.removeClass('bottom').removeClass('top');
        $productContent.addClass('sticky');
        $productContent.css({
          position: '',
          top: '0'
        });
        productDetailsPosTop = $productContent.offset().top - headerHeight - 20;
        $imageListContainer.css({
          position: '',
          top: '',
          bottom: ''
        });
      }

      if ($windowScroll + 10 < productDetailsOffsetTop - headerHeight && productImageContainerHeight > productDetailsHeight) {
        // Re-stickto top if product detail height allows to see the whole sidebar
        $productContent.addClass('sticky');
        $productContent.css({
          position: '',
          top: headerHeight + visualPadding,
          bottom: ''
        });
      }

      stickyMainProductImage();
    }

    switchThumbnail();
  });
}
/**
* media zoom Image - Only for Desktop
*/


function initializingMediaZoom() {
  $('.zoom-image').ezPlus({
    zoomType: 'inner',
    zoomWindowFadeIn: 200,
    zoomWindowFadeOut: 200
  });
}

module.exports = {
  setupPDPImages: function setupPDPImages() {
    if (!isQuickView() && $(window).width() > SCREENSIZE.DESKTOPMIN && isFluid !== 'true' && !isEditModal() && $thumbnail.length > 0) {
      getImageID();
      previousThumbnail();
      nextThumbnail();
      stickyMainProductImageHandler();
      stickyProductDetails();
      stickyThumbnail();
      defaultActive();
      onAccordionClick();
      onSendByTypeChange();
      switchThumbnail();
    } else if ($(window).width() <= SCREENSIZE.DESKTOPMIN && isFluid !== 'true') {
      defaultActive();
      mobileZoomImagesInt();
    }
  },
  setupMediaZoom: function setupMediaZoom() {
    if (isDesktop && isFluid !== 'true') {
      mediaZoom.productMediaZoom();
      initializingMediaZoom();
    }
  },
  landscapeViewResize: function landscapeViewResize() {
    $(window).on('resize', function () {
      if ($(window).width() > SCREENSIZE.DESKTOPMIN) {
        $('.zoomContainer').remove();
        $productContent.css({
          top: 0
        });
        $('.js-thumbnail-btn').off('.mobile');
        $imageList.off('.mobile');

        if ($imageList.hasClass('slick-initialized')) {
          $imageList.slick('unslick');
        }

        $('.thumbnail-wrapper').prependTo('.images-wrapper').addClass('hidden-md-down');
        $thumbnailNextBtn.appendTo('.thumbnail-images');
        $thumbnailPrevBtn.prependTo('.thumbnail-images');
        getImageID();
        previousThumbnail();
        nextThumbnail();
        stickyMainProductImageHandler();
        stickyProductDetails();
        stickyThumbnail();
        onAccordionClick();
        onSendByTypeChange();
        switchThumbnail();
      } else if ($(window).width() <= SCREENSIZE.DESKTOPMIN) {
        var detail = __webpack_require__(/*! ./detail */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/detail.js");

        detail.stickyAddToCart();
        $('.zoomContainer').remove();
        $(window).off('.desktop');
        $('.js-thumbnail-btn').off('.desktop');
        $('.product-detail-content').css({
          position: 'sticky'
        });
        $thumbnail.css({
          position: 'sticky'
        });
        $('.large-images-wrapper').removeClass('bottom');
        mobileZoomImagesInt();
        $('.js-thumbnail-btn').each(function (index, btn) {
          var jqBtn = $(btn);

          if ($(jqBtn).hasClass('active') && index !== 0) {
            $imageList.slick('slickGoTo', index);
          }
        });
        $imageListContainer.css({
          width: '',
          'min-width': ''
        });
        imageZoomConfig();
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/productSet.js":
/*!****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/productSet.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isDesktop = $(window).width() >= SCREENSIZE.DESKTOPMIN;
var isTabletOrBelow = $(window).width() < SCREENSIZE.DESKTOPMIN;

var imageZoom = __webpack_require__(/*! ../thirdParty/zoom */ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/zoom.js");

var mediaZoom = __webpack_require__(/*! ../thirdParty/mediaZoom */ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/mediaZoom.js");

var $imageList = $('.js-large-images-list');
/**
* media zoom Image - Only for Desktop
*/

function initializingMediaZoom() {
  $('.zoom-image').ezPlus({
    zoomType: 'inner',
    zoomWindowFadeIn: 200,
    zoomWindowFadeOut: 200
  });
}
/**
 * assign thumbnail ID to Large image ID
 * @param {$thumbnailID} tid - passing thumnail ID
 * @param {button} elem - passing the button that clicked
 */


function assignImageID(tid, elem) {
  var largeId = elem.closest('.product-set-detail').find('.large-' + tid);
  elem.closest('.product-set-detail').find('.js-large-images-list li').addClass('d-none');
  largeId.removeClass('d-none');
}
/**
 * appending thumbnail image to large image on click
 */


function imageAppend() {
  $('body').on('click.appendImage', '.js-thumbnail-btn', function () {
    var thumbId = $(this).data('thumbnail');
    $(this).closest('.product-set-detail').find('.js-thumbnail-btn').removeClass('active');
    $(this).addClass('active');
    assignImageID(thumbId, $(this));
    $('.zoomContainer').remove();
    initializingMediaZoom();
  });
  $('body').on('click.appendImage', '.js-prev-btn', function () {
    var $currentThumb = $(this).closest('.product-set-detail').find('.js-thumbnail-btn.active');
    var $previousThumb = $currentThumb.prev('.js-thumbnail-btn');

    if ($previousThumb.length !== 0) {
      $currentThumb.removeClass('active');
      $previousThumb.addClass('active');
      var thumbId = $previousThumb.data('thumbnail');
      assignImageID(thumbId, $(this));
      $('.zoomContainer').remove();
      initializingMediaZoom();
    }
  });
  $('body').on('click.appendImage', '.js-next-btn', function () {
    var $currentThumb = $(this).closest('.product-set-detail').find('.js-thumbnail-btn.active');
    var $nextThumb = $currentThumb.next('.js-thumbnail-btn');

    if ($nextThumb.length !== 0) {
      $currentThumb.removeClass('active');
      $nextThumb.addClass('active');
      var thumbId = $nextThumb.data('thumbnail');
      assignImageID(thumbId, $(this));
      $('.zoomContainer').remove();
      initializingMediaZoom();
    }
  });
}
/**
 * Adding class active to first thumbnail on default
 *
 */


function defaultActive() {
  $('.product-set-detail').each(function () {
    $(this).find('.js-thumbnail-btn:eq(0)').addClass('active');
  });
}
/**
 * Resets zoom to 0%
 *
 */


function resetImgZoom() {
  var $zoomedContainers = $('.zoom');

  if ($zoomedContainers.length) {
    $zoomedContainers.each(function () {
      var $zoomedImg = $(this).children('img');
      $zoomedImg.attr({
        'data-scale': 1,
        'data-translate-x': 0,
        'data-translate-y': 0
      }).removeAttr('style');
      $zoomedContainers.removeClass('zoom-active');
    });
  }
}
/**
 * Sets Thumbnail to match active slide
 *  @param {string} nextSlide - Slider Slider next slide index
 *
 */


function setActiveThumbnail(nextSlide) {
  var deviceWidth = window.outerWidth;
  var $thumbnailContainer = $('.thumbnail-images');
  var $targetThumbnail = $(".thumbnail-".concat(nextSlide));
  var targetThumbnailPos = $targetThumbnail.offset().left;

  if (targetThumbnailPos < 0) {
    $thumbnailContainer.scrollLeft(0);
  } else if (targetThumbnailPos + $targetThumbnail.outerWidth() > deviceWidth) {
    $thumbnailContainer.scrollLeft(targetThumbnailPos);
  }
}
/**
 * When clicking on a mobile thumbnail, navigate slider
 *
 */


function mobileThumbnailClick() {
  $('.js-thumbnail-btn').on('click', function () {
    var targetSlide = $(this).index();
    $(this).closest('.product-set-detail').find('.js-large-images-list').slick('slickGoTo', targetSlide);
    $(this).closest('.product-set-detail').find('.js-thumbnail-btn').removeClass('active');
    $(this).addClass('active');
  });
}
/**
 * Setup mobile image carousel and zoom functionality
 *
 */


function mobileZoomImagesInt() {
  var productCarousel = '.js-product-carousel';
  var productSlidesCount = $(productCarousel).data('slides-to-show');
  var productArrows = $(productCarousel).data('arrows');
  var $mobileImagesList = $('.js-large-images-list');
  var $thumbnailNextBtn = $('.js-next-btn');
  var $thumbnailPrevBtn = $('.js-prev-btn');
  $('.product-set-detail').find('.thumbnail-wrapper').removeClass('hidden-md-down');
  $('.thumbnail-wrapper').each(function () {
    var $largeImage = $(this).closest('.product-set-detail').find('.large-images-wrapper');
    $(this).insertAfter($largeImage);
  });
  $mobileImagesList.on('init', function () {
    mobileThumbnailClick();
  });
  $thumbnailNextBtn.remove();
  $thumbnailPrevBtn.remove(); // Adding .not('slick-initialized') stops code from breaking due to multiple slider calls

  $($mobileImagesList).not('.slick-initialized').slick({
    slidesToShow: productSlidesCount,
    slidesToScroll: 1,
    accessibility: true,
    arrows: productArrows,
    dots: false
  });
  $imageList.on('beforeChange', function (event, slick, currentSlide, nextSlide) {
    if (currentSlide === nextSlide) {
      return false;
    }

    resetImgZoom();
    $(this).closest('.product-set-detail').find(".thumbnail-".concat(currentSlide)).removeClass('active');
    $(this).closest('.product-set-detail').find(".thumbnail-".concat(nextSlide)).addClass('active');
    setActiveThumbnail(nextSlide);
  }); // eslint-disable-next-line no-undef

  imageZoom.zoom({
    active: 'zoom-active',
    transition: 'zoom-transition',
    visible: 'visible',
    zoom: 'zoom' // Image container class

  }, {
    scaleDefault: 2.5,
    // Used on doubleclick, doubletap and resize
    scaleMax: 4,
    // Maximum zoom
    scaleMin: 1,
    // Minimum zoom
    transitionDuration: 200,
    // This should correspond with zoom-transition transition duration
    doubleclickDelay: 300,
    // Delay between clicks - used when scripts decides if user performed doubleclick or not
    slickCarousel: 'js-large-images-list' // Slick Carousel parent element

  }, function (container, zoomActive) {
    var $zoomImg = $(container).find('img');
    var hiResImg = $zoomImg.data('zoomImg');

    if (hiResImg) {
      $zoomImg.attr('src', hiResImg);
    }

    $('.js-large-images-list').slick('slickSetOption', {
      touchMove: !zoomActive,
      swipe: !zoomActive
    });
  });
}
/**
 * To validate if size & color selection is done
 * @return {string} - return false if selection is not done
 * @param {jquery} elem - DOM container of the corresponding next button
 */


function variantValidation(elem) {
  var $productContainer = elem; // Need to use this for size selector instead of color attribute

  var $selectedSizeAttr = $productContainer.find('.select-size .size-option');
  var inStock = $productContainer.find('.size-option.selected').length ? $productContainer.find('.size-option.selected').data('isinstock') : true;
  var inStockColor = $productContainer.find('.color-value.selected').length ? $productContainer.find('.color-value.selected').data('isinstock') : true;
  var $selectedColorAttr = $productContainer.find('.color-attribute-value .swatch-circle.selected');
  var sizeNotSelected = $selectedSizeAttr && $selectedSizeAttr.length && !$selectedSizeAttr.hasClass('selected');
  var $sizeSelected = $selectedSizeAttr.hasClass('selected');
  var $nosizeAttribute = $('.variationAttributes').hasClass('.select-size .size-option');
  var colorNotSelected = $selectedColorAttr && $selectedColorAttr.length && !$selectedColorAttr.hasClass('selected');

  if (sizeNotSelected || colorNotSelected) {
    $('body').trigger('event:productError', $selectedSizeAttr);
    var $targetAttribute = colorNotSelected ? $selectedColorAttr : $selectedSizeAttr;
    var $attributeSelector = $targetAttribute.closest('.attribute');
    $attributeSelector.find('.attribute-error:first').removeClass('d-none');
    setTimeout(function () {
      $attributeSelector.find('.size-option:first input').focus();
    }, 3000);
    return false;
  } else if (!inStockColor) {
    var $target = $selectedColorAttr;
    var $attr = $target.closest('.attribute');
    $attr.find('.attribute-error:first').removeClass('d-none').attr('role', 'alert').focus();
    return false;
  } else if (!inStock) {
    var _$target = $selectedSizeAttr;

    var _$attr = _$target.closest('.attribute');

    _$attr.find('.attribute-error:first').removeClass('d-none').attr('role', 'alert').focus();

    return false;
  }

  if ($sizeSelected || !$nosizeAttribute) {
    $('.add-to-cart-global').removeAttr('disabled');
  }

  return true;
}
/**
 * @param {string} activeResponsePrice - price for a given product
 * @param {string} qtyUpdated - quantity for a given product
 */


function updateProductSetQtyPrice(activeResponsePrice, qtyUpdated) {
  /* Qty*/
  var prevQty = $('.product-set-flyout-wrapper.visited').find('.quantity-select');
  var prevQtyTotal = 0;
  $.each(prevQty, function (key, qty) {
    prevQtyTotal += parseInt($(qty).val(), 10);
  });
  var activeQty = parseInt($('.product-set-flyout-wrapper.active').find('.quantity-select').val(), 10);
  var currentQty = prevQtyTotal + activeQty;
  currentQty = currentQty > 1 ? currentQty + ' items' : currentQty + ' item';
  $('.product-set-flyout-wrapper.active .qty-value').html(currentQty);
  /* Price*/

  var currency = $('.product-set-flyout-wrapper.active').find('.default-price .sales .value').text().trim().match(/[^0-9/.-]+/g);
  var activePrice;
  var prevPrice = $('.product-set-flyout-wrapper.active').prev('.product-set-flyout-wrapper.visited').find('.price-value').text();

  if (activeResponsePrice) {
    activePrice = Number(activeResponsePrice.replace(/[^0-9/.-]+/g, ''));
  } else {
    activePrice = $($('.product-set-flyout-wrapper.active').find('.default-price .sales .value')[0]).text().trim();
    activePrice = Number(activePrice.replace(/[^0-9/.-]+/g, ''));
  }

  prevPrice = Number(prevPrice.replace(/[^0-9/.-]+/g, ''));

  if (!qtyUpdated) {
    activePrice *= activeQty;
  }

  var currentPrice = prevPrice + activePrice;
  $('.product-set-flyout-wrapper.active .price-value').html(currency[0] + currentPrice.toFixed(2));
}
/**
 * @param {jQuery} elem - price container element for a given product
 */


function quantityPriceTotal(elem) {
  var qtyValue = elem.find('.quantity-select').val();
  var qtyText = qtyValue > 1 ? qtyValue + ' items' : qtyValue + ' item';
  var currency = elem.find('.default-price .sales .value').text().trim().match(/[^0-9/.-]+/g);
  var priceValue = elem.find('.default-price .sales .value').text().trim().replace(/[^0-9/.-]+/g, '');
  priceValue *= qtyValue;
  var messageHtml = '<div class="total-amount-messsage"> <span class="total-title"> Total Amount </span>(<span class="qty-value">' + qtyText + '</span>): <span class="price-value">' + currency[0] + priceValue.toFixed(2) + '</span> </div>';
  var $priceWrapper = elem.find('.prices-add-to-cart-actions');
  var $total = $('<div class="total-amount"></div>');
  $total.append(messageHtml);
  $total.insertBefore($priceWrapper);
}

module.exports = {
  productSetImages: function productSetImages() {
    if (isDesktop) {
      $('body').off('.appendImage');
      $('.product-set-detail').find('.js-thumbnail-btn').removeClass('active');
      $('.js-large-images-list li:not(:first-child)').addClass('d-none'); // Hide Large images except first

      $('.product-set-detail').find('.js-thumbnail-btn:eq(0)').addClass('active'); // Default active

      $('.js-large-images-list li:first-child').removeClass('d-none');
      imageAppend();
    } else if (isTabletOrBelow) {
      mobileZoomImagesInt();
      defaultActive();
    }
  },
  setupMediaZoom: function setupMediaZoom() {
    if (isDesktop) {
      mediaZoom.productMediaZoom();
      initializingMediaZoom();
    }
  },
  buyAllProducts: function buyAllProducts() {
    $('.js-buy-all-set').click(function () {
      var productSetDetailLength = $('.product-set-wrapper .product-set-detail').length;
      $('.product-set-flyout-image').empty();
      $('.product-set-flyout-details').empty();

      for (var i = 0; i < productSetDetailLength; i++) {
        $('.product-set-wrapper .product-set-detail:eq(' + i + ')').find('.large-thumbnail-0:eq(0)').children().clone().appendTo('.product-set-flyout-wrapper:eq(' + i + ') .product-set-flyout-image');
        $('.product-set-wrapper .product-set-detail:eq(' + i + ')').find('.product-detail-content').clone().appendTo('.product-set-flyout-wrapper:eq(' + i + ') .product-set-flyout-details');
        $('.product-set-flyout-wrapper:eq(' + i + ') .product-set-flyout-details').find('.product-ratings').remove();
        $('.product-set-flyout-wrapper:eq(' + i + ')').find('.product-set-flyout-next').clone().appendTo('.product-set-flyout-wrapper:eq(' + i + ') .quantity-addtocart-grid-set');
        var $Container = $('.product-set-flyout-wrapper:eq(' + i + ')');
        quantityPriceTotal($Container);
        $('.product-set-flyout-details:eq(' + i + ') .attributes .thirdparty-payment').addClass('d-none');
      }

      var $flyoutDetails = $('.modal-body .product-set-flyout-details');

      if ($flyoutDetails.length > 0) {
        $flyoutDetails.find(".color-attribute-value span[data-isinstock='false']").parent().remove();
        $flyoutDetails.find("div.size-option[data-isinstock='false']").remove();
      }

      $('.product-set-flyout-details .product-set-flyout-next').removeClass('d-none');
      $('.product-set-flyout-wrapper').removeClass('active');
      $('.product-set-flyout-wrapper:eq(0)').addClass('active');
      $('.product-set-flyout-wrapper .cart-and-ipay, .product-set-flyout-wrapper .design-and-detail').remove();
      $('.product-set-flyout-wrapper:first-child .product-set-flyout-previous').remove();
      $('.product-set-flyout-wrapper:last-child .product-set-flyout-next').remove();
      $('.global-add-to-cart-wrapper .cart-and-ipay').clone().appendTo('.product-set-flyout-wrapper:last-child .quantity-addtocart-grid-set');
      $('.product-set-flyout-details .quantity-select').val(1);
      $('.product-set-flyout-details .full-pdp-link span').addClass('d-inline');
    });
  },
  changeQuantity: function changeQuantity() {
    var flyout = $('.product-set-flyout-details');
    flyout.on('change', '.quantity-select', function () {
      var $productContainer = $(this).closest('.product-detail');
      var inStockSize = $productContainer.find('.size-option.selected').length ? $productContainer.find('.size-option.selected').data('isinstock') : true;
      var inStockColor = $productContainer.find('.color-value.selected').length ? $productContainer.find('.color-value.selected').data('isinstock') : true;

      if (inStockSize && inStockColor) {
        var totalQuantity = $('.quantity-select', flyout).toArray().reduce(function (acc, el) {
          var value = acc + parseInt($(el).val() || 0, 10);
          return value;
        }, 0);
        var addToCartGlobal = $('.add-to-cart-global', flyout);
        var label = addToCartGlobal.data('primaryLabel');
        addToCartGlobal.text(label + ' (' + totalQuantity + ')').attr('aria-label', label + ' ' + totalQuantity);
      }

      updateProductSetQtyPrice();
    });
  },
  nextButton: function nextButton() {
    $(document).on('click', '.product-set-flyout-next', function () {
      var currentItem = $(this).closest('.product-set-flyout-wrapper');
      var nextItem = currentItem.next('.product-set-flyout-wrapper');
      var $productContainer = $(this).closest('.product-detail');
      var selection = variantValidation($productContainer);

      if (selection) {
        currentItem.removeClass('active').addClass('visited');
        nextItem.addClass('active');
        setTimeout(function () {
          nextItem.find('.product-set-flyout-next:visible').focus();
        }, 100);
        updateProductSetQtyPrice();
      }
    });
  },
  previousButton: function previousButton() {
    $(document).on('click', '.product-set-flyout-previous', function () {
      var currentItem = $(this).closest('.product-set-flyout-wrapper');
      var prevItem = currentItem.prev('.product-set-flyout-wrapper');
      currentItem.removeClass('active visited');
      prevItem.addClass('active').removeClass('visited');
      setTimeout(function () {
        prevItem.find('.product-set-flyout-previous:visible').focus();
      }, 100);
      updateProductSetQtyPrice();
    });
  },
  cancelButton: function cancelButton() {
    $(document).on('click', '.product-flyout-cancel-link, .blurred-background', function (e) {
      e.preventDefault();
      $('.product-flyout-close').trigger('click');
    });
  },
  selectItemsFromSet: function selectItemsFromSet() {
    $(document).on('click', '.select-set', function () {
      var position = $('#scroll-js') && $('#scroll-js').length ? $('#scroll-js').offset().top - $('header').height() : 0;
      $('html, body').animate({
        scrollTop: position
      }, 500);
    });
  },
  changeVariant: function changeVariant() {
    $(document).on('product:afterAttributeSelect', function (e, response) {
      if ($('.product-set-flyout-wrapper.active').length > 0) {
        $('.product-set-flyout-wrapper.active').find('.product-set-flyout-details .full-pdp-link-js').attr('href', response.data.product.selectedProductUrl);
      } // if size is selected, prevent the focus to move to first color variant - instead stay on the same element


      if ($(response.target).attr('id') && $(response.target).attr('id').indexOf('size') > -1) {
        $('#size_' + response.data.product.id + '_' + response.data.product.variationAttributes[1].displayValue + '_' + response.data.locale.split('_')[1]).focus();
      }

      if (response.container.parent('.product-set-flyout-wrapper').length !== 0) {
        if (response.data.product.price && response.data.product.price.sales) {
          updateProductSetQtyPrice(response.data.product.price.sales.formatted);
        }

        if (response.data.product.total) {
          updateProductSetQtyPrice(response.data.product.total.sales.formatted, true);
        }
      }
    });
  },
  shopThisBundlePopUp: function shopThisBundlePopUp() {
    $(document).on('shown.bs.modal', '#editProductSetModal', function () {
      $('.product-flyout-close').focus();

      if ($(this).find('.product-set-flyout-wrapper').length > 0) {
        $('.btn-add-to-favorites').addClass('d-none');
        $('.product-set-flyout-wrapper').find('label').map(function (i, ind) {
          $(ind).siblings().attr('id', 'flyout-' + $(ind).siblings().attr('id'));
          $(ind).attr('for', $(ind).siblings().attr('id'));
          return true;
        });
        $('.product-set-flyout-wrapper').each(function (ind, ele) {
          var id = $(ele).attr('data-pid');
          $(ele).find('.add-fav-heart').attr('aria-label', $(ele).find('.add-fav-heart').attr('aria-label') + ' ' + $(ele).find('.product-name')[0].innerText);
          $(ele).find('.remove-fav-heart').attr('aria-label', $(ele).find('.remove-fav-heart').attr('aria-label') + ' ' + $(ele).find('.product-name')[0].innerText);
          $(ele).find('.quantity-select').attr('id', 'flyout-' + id + '-' + $(ele).find('.quantity-select').attr('id'));
          $(ele).find('.select-size').attr('id', 'flyout-' + id + '-' + $(ele).find('.select-size').attr('id'));
          $(ele).find('[data-bv-show="rating_summary"]').attr('id', 'flyout-' + id + '-' + $(ele).find('[data-bv-show="rating_summary"]').attr('id'));
          $(ele).find('[data-bv-show="rating_summary"] ul').removeAttr('id');
        });
      }
    });
  },
  closeThisBundlePopUp: function closeThisBundlePopUp() {
    $(document).on('hidden.bs.modal', '#editProductSetModal', function () {
      $('.btn-add-to-favorites').removeClass('d-none');
    });
  },
  setFavorites: function setFavorites() {
    // ToDo: Add trigger event for wishlist functionality
    if ($('.js-buy-all-set').length > 0) {
      var products = $('#scroll-js .product-detail');
      var wishlistedProducts = $('.wishlistedItems').length > 0 ? $('.wishlistedItems').val().split(',') : [];
      products.each(function () {
        if (wishlistedProducts && wishlistedProducts.includes($(this).data('product-id').toString())) {
          $(this).find('.add-fav-heart').addClass('d-none');
          $(this).find('.add-to-favorites').addClass('d-none');
          $(this).find('.remove-fav-heart').removeClass('d-none');
          $(this).find('.remove-from-favorites').removeClass('d-none');
        } else {
          $(this).find('.add-fav-heart').removeClass('d-none');
          $(this).find('.add-to-favorites').removeClass('d-none');
          $(this).find('.remove-fav-heart').addClass('d-none');
          $(this).find('.remove-from-favorites').addClass('d-none');
        }
      });
    }
  },
  productSetFlyoutModal: function productSetFlyoutModal() {
    $(document).on('click', '.size-chart-modal .close, .size-chart-modal, .blurred-background', function () {
      $('#editProductSetModal').css('z-index', 1050);

      if ($('#editProductSetModal').hasClass('show')) {
        $('body').addClass('overflow-hidden');
      } else {
        $('body').removeClass('overflow-hidden');
      }
    });
  },
  productSetSizeModal: function productSetSizeModal() {
    $(document).on('click', '.size-guide-cta', function () {
      $('#editProductSetModal').css('z-index', 1040);
    });
  },
  productSetReadMore: function productSetReadMore() {
    var $productDescription = $('.product-description-container .product-description');

    if (isTabletOrBelow && $productDescription.length) {
      $productDescription.css('display', '-webkit-box');
      $('.product-set-cta-container').click(function () {
        var readMore = $('.product-set-read-more');
        var readLess = $('.product-set-read-less');

        if (readMore.hasClass('d-none')) {
          $productDescription.css('-webkit-line-clamp', '4');
          readMore.removeClass('d-none');
          readLess.addClass('d-none');
        } else {
          $productDescription.css('-webkit-line-clamp', 'unset');
          readMore.addClass('d-none');
          readLess.removeClass('d-none');
        }
      });
    }
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/quickView.js":
/*!***************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/quickView.js ***!
  \***************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base = __webpack_require__(/*! ./base */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js");

var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");

var updateFavorites = (__webpack_require__(/*! ./favorites */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/favorites.js").updateFavorites);

var sizeGuideTabs = __webpack_require__(/*! ./localizeSizeLabels */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/localizeSizeLabels.js");

var notifyMe = __webpack_require__(/*! ../components/notifyMe */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/notifyMe.js");
/**
 * Generates the modal window on the first call.
 *
 */


function getModalHtmlElement() {
  if ($('#quickViewModal').length !== 0) {
    $('#quickViewModal').remove();
  }

  var htmlString = '<!-- Modal -->' + '<div class="modal fade" id="quickViewModal" role="dialog">' + '<span class="enter-message sr-only" ></span>' + '<div class="modal-dialog quick-view-dialog modal-dialog-centered">' + '<!-- Modal content-->' + '<div class="modal-content border-0 rounded-0">' + '<div class="modal-header border-0 bg-transparent">' + '    <button type="button" class="close m-0 pull-right" data-dismiss="modal">' + '    </button>' + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer"></div>' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
 * @typedef {Object} QuickViewHtml
 * @property {string} body - Main Quick View body
 * @property {string} footer - Quick View footer content
 */

/**
 * Parse HTML code in Ajax response
 *
 * @param {string} html - Rendered HTML from quickview template
 * @return {QuickViewHtml} - QuickView content components
 */


function parseHtml(html) {
  var $html = $('<div>').append($.parseHTML(html));
  var body = $html.find('.product-quickview');
  var footer = $html.find('.modal-footer').children();
  return {
    body: body,
    footer: footer
  };
}
/**
 * assign thumbnail ID to Large image ID
 * @param {$thumbnailID} tid - passing thumnail ID
 */


function assignImageID(tid) {
  var largeId = $('.large-' + tid);
  $('.product-quickview .js-large-images-list li').addClass('d-none');
  largeId.removeClass('d-none');
}
/**
 * assign current thumbanil reference
 * @param {$currElement} currElement - thumbanil reference to get the thumnail productID
 */


function getImageInteractionEvent(currElement) {
  var productID;

  if (window.$('.product-quickview, .product-detail').length > 0) {
    var product = window.$(currElement).closest('.product-quickview, .product-detail');

    if (product.length > 0 && product[0].dataset && product[0].dataset.pid) {
      productID = product[0].dataset.pid;
    }
  }

  $('body').trigger('event:imageInteraction', productID);
}
/**
 * appending thumbnail image to large image on click
 */


function imageAppend() {
  $('.product-quickview .js-large-images-list li:not(:first-child)').addClass('d-none'); // Hide Large images except first

  $('.js-thumbnail-btn:eq(0)').addClass('active'); // Default active

  $('body').on('click', '.js-thumbnail-btn', function () {
    var thumbId = $(this).data('thumbnail');
    $('.js-thumbnail-btn').removeClass('active');
    $(this).addClass('active');
    assignImageID(thumbId);
  });
  $('body').on('click', '.js-prev-btn', function (event) {
    event.stopImmediatePropagation();
    var $currentThumb = $('.js-thumbnail-btn.active');
    var $previousThumb = $currentThumb.prev('.js-thumbnail-btn');

    if ($previousThumb.length !== 0) {
      $currentThumb.removeClass('active');
      $previousThumb.addClass('active');
      var thumbId = $previousThumb.data('thumbnail');
      assignImageID(thumbId);
    }

    getImageInteractionEvent(this);
  });
  $('body').on('click', '.js-next-btn', function (event) {
    event.stopImmediatePropagation();
    var $currentThumb = $('.js-thumbnail-btn.active');
    var $nextThumb = $currentThumb.next('.js-thumbnail-btn');

    if ($nextThumb.length !== 0) {
      $currentThumb.removeClass('active');
      $nextThumb.addClass('active');
      var thumbId = $nextThumb.data('thumbnail');
      assignImageID(thumbId);
    }

    getImageInteractionEvent(this);
  });
}
/**
 * replaces the content in the modal window on for the selected product variation.
 * @param {string} selectedValueUrl - url to be used to retrieve a new product model
 * @param {string} closeText - content used for close button in flyout
 */


function fillModalElement(selectedValueUrl, closeText) {
  $('#quickViewModal .modal-header .close').attr('aria-label', closeText);
  $.ajax({
    url: selectedValueUrl,
    method: 'GET',
    dataType: 'json',
    success: function success(data) {
      var parsedHtml = parseHtml(data.renderedTemplate);
      $('#quickViewModal').find('.modal-body').empty();
      $('#quickViewModal').find('.modal-body').html(parsedHtml.body);
      $('#quickViewModal').find('.modal-footer').html(parsedHtml.footer);
      $('#quickViewModal .modal-header .close').attr('aria-label', data.closeButtonText);
      $('#quickViewModal .enter-message').text(data.enterDialogMessage);
      $('#quickViewModal').modal('show');
      $('body').trigger('quickview:ready');
      $('body').trigger('event:quickView', data);
      base.sizeBoxCalc();
      imageAppend();
      updateFavorites(data.isFavoriteProduct, parsedHtml.body);
      var wishlistedProducts = $('.wishlistedItems').length > 0 ? $('.wishlistedItems').val().split(',') : [];
      var QVProduct = $('.product-quickview');
      QVProduct.find('.large-images .mk-heart-filled').css('visibility', 'hidden');
      QVProduct.find('.large-images .mk-heart').css('visibility', 'hidden');

      if (wishlistedProducts && wishlistedProducts.includes(QVProduct.data('pid').toString())) {
        QVProduct.find('.add-fav-heart, .add-to-favorites').addClass('d-none');
        QVProduct.find('.remove-fav-heart, .remove-from-favorites').removeClass('d-none');
      } else {
        QVProduct.find('.add-fav-heart, .add-to-favorites').removeClass('d-none');
        QVProduct.find('.remove-fav-heart, .remove-from-favorites').addClass('d-none');
      }

      sizeGuideTabs.localizeSizeLabels();

      if (typeof BV !== 'undefined') {
        $('.product-quickview .product-ratings').each(base.observingBV);
      }

      if (data.product.availability !== undefined && data.product.availability.dcQuantityAvailable !== undefined && !data.product.availability.dcQuantityAvailable) {
        QVProduct.find('.dcquantity-notavailable-msg').removeClass('d-none');
      }
    },
    error: function error() {}
  });
}

module.exports = {
  showQuickview: function showQuickview() {
    $('body').on('click', '.quickview', function (e) {
      e.stopImmediatePropagation();
      e.preventDefault();
      var selectedValueUrl = $(this).closest('a.quickview').attr('href');
      $(e.target).trigger('quickview:show');
      getModalHtmlElement();
      fillModalElement(selectedValueUrl, $(this).data('close-label'));
      notifyMe.submitRecaptchaNotifyMe();

      window.bvCallback = function (BV) {
        if (typeof BV !== 'undefined') {
          if (BV.reviews) {
            BV.reviews.on('show', function () {
              // This line assumes SFRA collapsible panels and is called when clicking on the review summary
              $('.row.reviews:not(.active)').toggleClass('active');
            });
          }

          if (BV.questions) {
            BV.questions.on('show', function () {
              // This line assumes SFRA collapsible panels and is called when clicking on the Q&A summary
              $('.row.questions:not(.active)').toggleClass('active');
            });
          }
        }
      };
    });
  },
  focusQuickview: function focusQuickview() {
    $('body').on('shown.bs.modal', '#quickViewModal', function (e) {
      if ($('#sizeChartModal').attr('quickview') === 'true') {
        e.stopImmediatePropagation();
        $('#sizeChartModal').attr('quickview', false);
        $('#quickViewModal a.size-chart').focus();
      } else {
        $('#quickViewModal .close').focus();
      }
    });
  },
  trapQuickviewFocus: function trapQuickviewFocus() {
    $('body').on('keydown', '#quickViewModal', function (e) {
      var focusParams = {
        event: e,
        containerSelector: '#quickViewModal',
        firstElementSelector: '.close',
        lastElementSelector: '.btn-add-to-favorites .btn-favorite:visible',
        nextToLastElementSelector: '.add-to-cart-global'
      };
      focusHelper.setTabNextFocus(focusParams);
    });
  },
  availability: base.availability,
  addToCart: base.addToCart,
  showSpinner: function showSpinner() {
    $('body').on('product:beforeAddToCart', function (e, data) {
      $(data).closest('.modal-content').spinner().start();
    });
  },
  hideDialog: function hideDialog() {
    $('body').on('product:afterAddToCart', function () {
      $('#quickViewModal').modal('hide');
    });
  },
  updateColorAttributeName: function updateColorAttributeName() {
    $(document).on('mouseover', '.color-swatch .swatch-circle', function () {
      $(this).closest('.color-swatch').find('.display-color-name').html(this.title);
    }).on('mouseleave', '.color-swatch .swatch-circle', function () {
      var colorName = $(this).closest('.color-attribute-value').find('.swatch-circle.selected').attr('title');
      $(this).closest('.attribute.color-swatch').find('.display-color-name').html(colorName);
    });
    $(document).on('focus', '.color-attribute', function () {
      var colorTitle = $(this).find('.swatch-circle').attr('title');
      $(this).closest('.color-swatch').find('.display-color-name').html(colorTitle);
    });
  },
  updateAttribute: function updateAttribute() {
    $('body').on('product:afterAttributeSelect', function (e, response) {
      if ($('.modal.show .product-quickview>.bundle-items').length) {
        $('.modal.show').find(response.container).data('pid', response.data.product.id);
        $('.modal.show').find(response.container).find('.product-id').text(response.data.product.id);
      } else if ($('.set-items').length) {
        response.container.find('.product-id').text(response.data.product.id);
      } else {
        $('.modal.show .product-quickview').data('pid', response.data.product.id);

        if ($('.set-item').length === 0) {
          $('.modal.show .full-pdp-link-js').attr('href', response.data.product.selectedProductUrl);
        }
      }
    });
  },
  updateAddToCart: function updateAddToCart() {
    $('body').on('product:updateAddToCart', function (e, response) {
      base.updateAddToCartCommon(response); // Update add to cart label based on availability

      if (!response.product.available) {
        $('button.add-to-cart-js', response.$productContainer).html(response.product.soldOutLabel.pdp);
        $('button.update-cart-product-global', response.$productContainer).html(response.product.soldOutLabel.pdp);
        $('button.move-to-cart-wishlist', response.$productContainer).html(response.product.soldOutLabel.pdp);
      } else {
        var addToCartLabel = $('button.add-to-cart-js', response.$productContainer).data('primary-label');
        $('button.add-to-cart-js', response.$productContainer).html(addToCartLabel);
        var updateToCartLabel = $('button.add-to-cart-js', response.$productContainer).data('primary-label');
        $('button.add-to-cart-js', response.$productContainer).html(updateToCartLabel);
      } // update global add to cart (single products, bundles)


      var dialog = $(response.$productContainer).closest('.quick-view-dialog');
      $('.add-to-cart-global', dialog).attr('disabled', !$('.global-availability', dialog).data('ready-to-order') || !$('.global-availability', dialog).data('available'));
    });
  },
  updateAvailability: function updateAvailability() {
    $('body').on('product:updateAvailability', function (e, response) {
      // bundle individual products
      $('.product-availability', response.$productContainer).data('ready-to-order', response.product.readyToOrder).data('available', response.product.available).find('.availability-msg li').empty().html(response.product.availability.messages[0] ? '<div class="availability text-uppercase">' + response.product.availability.messages[0] + '</div>' : '');
      var dialog = $(response.$productContainer).closest('.quick-view-dialog');

      if ($('.product-availability', dialog).length) {
        // bundle all products
        var allAvailable = $('.product-availability', dialog).toArray().every(function (item) {
          return $(item).data('available');
        });
        var allReady = $('.product-availability', dialog).toArray().every(function (item) {
          return $(item).data('ready-to-order');
        });
        $('.global-availability', dialog).data('ready-to-order', allReady).data('available', allAvailable);
        $('.global-availability .availability-msg', dialog).empty().html(allReady ? response.message : response.resources.info_selectforstock);
      } else {
        // single product
        $('.global-availability', dialog).data('ready-to-order', response.product.readyToOrder).data('available', response.product.available).find('.availability-msg li').empty().html(response.product.availability.messages[0] ? '<div class="availability text-uppercase">' + response.product.availability.messages[0] + '</div>' : '');
      }
    });
  },
  sizeChartDialogClose: function sizeChartDialogClose() {
    $(document).on('hidden.bs.modal', '#sizeChartModal', function () {
      if ($('.cart-page').length > 0) {
        $('body').addClass('modal-open');
      }

      if ($(this).attr('quickview') === 'true') {
        $('#quickViewModal').removeClass('d-none');
        $('body').addClass('modal-open');
      }

      if ($(this).attr('id') === 'sizeChartModal') {
        setTimeout(function () {
          $('.size-guide-cta').focus();
        }, 100);
      }
    });
  },
  sizeChartDialogOpen: function sizeChartDialogOpen() {
    $(document).on('shown.bs.modal', '#sizeChartModal', function () {
      $('body').addClass('modal-open');
    });
  },
  hideQuickView: function hideQuickView() {
    $(document).on('hidden.bs.modal', '.modal', function () {
      if ($(this).find('.quick-view-dialog').length > 0) {
        var wishlistedProducts = $('.wishlistedItems').length > 0 ? $('.wishlistedItems').val().split(',') : [];
        $('.product-tile-show').each(function () {
          if (wishlistedProducts && wishlistedProducts.includes($(this).attr('data-pid').toString())) {
            $(this).find('.wishlistTile.add-wish-list').addClass('d-none');
            $(this).find('.wishlistTile.remove-from-wishlist').removeClass('d-none');
          }
        });
      }
    });
  },
  sizeChart: base.sizeChart()
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/sharedwishlist.js":
/*!********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/sharedwishlist.js ***!
  \********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

module.exports = {
  addToWishlist: function addToWishlist() {
    $('body').on('click', '.sharedWishlistTile', function (e) {
      e.preventDefault();
      var url = $(this).attr('href');
      var pid = $(this).closest('.product-info').data('pid');

      if ($('.wishlist-icon-wrapper').length > 0) {
        $(this).closest('.wishlist-icon-wrapper').find('.sharedRemovewishlistTile').removeClass('d-none');
        $(this).addClass('d-none');
      }

      $.spinner().start();
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: {
          pid: pid
        },
        success: function success(data) {
          var isSuccess = true;
          clientSideUtil.floatToastMessage(data.msg, 5000, isSuccess);
          $.spinner().stop();
        },
        error: function error(err) {
          clientSideUtil.floatToastMessage(err, 5000, false);
          $.spinner().stop();
        }
      });
    });
  },
  removeWishlist: function removeWishlist() {
    $('body').on('click', '.sharedRemovewishlistTile', function (e) {
      e.preventDefault();
      var url = $(this).attr('href');
      var pid = $(this).closest('.product-info').data('pid');
      $(this).closest('.wishlist-icon-wrapper').find('.sharedWishlistTile').removeClass('d-none');
      $(this).addClass('d-none');
      $.spinner().start();
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: {
          pid: pid
        },
        success: function success(data) {
          var isSuccess = true;
          clientSideUtil.floatToastMessage(data.productRemovedMsg, 5000, isSuccess);
          $.spinner().stop();
        },
        error: function error(err) {
          clientSideUtil.floatToastMessage(err, 5000, false);
          $.spinner().stop();
        }
      });
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js":
/*!**************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var base = __webpack_require__(/*! ../product/base */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/base.js");

var focusHelper = __webpack_require__(/*! ../components/focus */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/focus.js");

var sharedwishlist = __webpack_require__(/*! ../product/sharedwishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/sharedwishlist.js");

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() <= SCREENSIZE.MOBILEMAX;
var isDesktop = $(window).width() >= SCREENSIZE.DESKTOPMIN;

var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");

var sizeGuideTabs = __webpack_require__(/*! ./localizeSizeLabels */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/localizeSizeLabels.js");

var notifyMe = __webpack_require__(/*! ../components/notifyMe */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/notifyMe.js");

var MENUCLOSEDELAY = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").MENUCLOSEDELAY);

var updateMiniWishlist = true;
var isWishlistMobileEnabled = $('.right-nav').find('.wishlist-icon').hasClass('wishlist-icon-js');
var isMob = $(window).width() <= SCREENSIZE.TABLETMAX;
/**
 * appends params to a url
 * @param {string} data - data returned from the server's ajax call
 * @param {Object} button - button that was clicked to add a product to the wishlist
 */

function displayMessage(data, button) {
  $.spinner().stop();
  var status;

  if (data.success) {
    status = 'alert-success';
  } else {
    status = 'alert-danger';
  }

  if ($('.add-to-wishlist-messages').length === 0) {
    $('body').append('<div class="add-to-wishlist-messages "></div>');
  }

  $('.add-to-wishlist-messages').empty().append('<div class="add-to-wishlist-alert text-center ' + status + '">' + DOMpurify.sanitize(data.msg) + '</div>');
  setTimeout(function () {
    $('.add-to-wishlist-messages').remove();
    button.removeAttr('disabled');
  }, 5000);
}
/**
 * Parses the html for a modal window
 * @param {string} html - representing the body and footer of the modal window
 *
 * @return {Object} - Object with properties body and footer.
 */


function parseHtml(html) {
  var $html = $('<div>').append($.parseHTML(html));
  var body = $html.find('.product-quickview');
  var footer = $html.find('.modal-footer').children();
  return {
    body: body,
    footer: footer
  };
}
/**
 * load notify me form
 * @param {string} pid - product ID
 * @param {Object} $selector - selector for form container
 * @param {string} url - url to GET form from
 */


function loadNotifyMeForm(pid, $selector, url) {
  $.ajax({
    url: url + '&formOnly=true',
    method: 'GET',
    dataType: 'json',
    success: function success(data) {
      if (data.success) {
        $selector.empty();
        $selector.html(DOMpurify.sanitize(data.renderedTemplate));
        $('#notify-email').focus();
      } else {
        $selector.html('');
      }
    },
    error: function error() {
      $selector.html('');
    }
  });
}
/**
 * replaces the content in the modal window for product variation to be edited.
 * @param {string} editFavoriteUrl - url to be used to retrieve a new product model
 */


function fillModalElement(editFavoriteUrl) {
  $.ajax({
    url: editFavoriteUrl,
    method: 'GET',
    dataType: 'json',
    success: function success(response) {
      var parsedHtml = parseHtml(response.renderedTemplate);
      $('#editWishlistProductModal .modal-body').empty();
      $('#editWishlistProductModal .modal-body').html(parsedHtml.body);
      $('#editWishlistProductModal .modal-header .close').attr('aria-label', DOMpurify.sanitize(response.closeButtonText));
      $('#editWishlistProductModal .enter-message').text(response.enterDialogMessage);
      $('.default-price').each(function () {
        if ($(this).find('.list').length) {
          $(this).find('.list .sr-only').text($(this).find('.list').text());
        }

        $(this).find('.sales .sr-only').text($(this).find('.sales').text());
      });
      var $notifyMeContainer = $('div.notify-me-form-container', response.$productContainer);
      var $addToCartGrid = $('div.quantity-addtocart-grid-quick-view', response.$productContainer);
      sizeGuideTabs.localizeSizeLabels();

      if (!response.product.available) {
        if (response.product.isNotifyMeActive) {
          $('div.quantity-addtocart-grid-quick-view').find('.add-to-cart-url').addClass('notify-me-enabled');
          $notifyMeContainer.removeClass('d-none');
          $('.full-pdp-link').addClass('d-none');
          loadNotifyMeForm(response.product.id, $notifyMeContainer, response.product.notifyURL);
        }
      } else {
        $addToCartGrid.removeClass('d-none');
        $notifyMeContainer.addClass('d-none');
        var addToCartLabel = $('button.update-cart-product-global', response.$productContainer).response('primary-label');
        $('button.move-to-cart-wishlist', response.$productContainer).html(addToCartLabel);
      }

      $.spinner().stop();
    },
    error: function error() {
      $.spinner().stop();
    }
  });
}
/**
 * Generates the modal window on the first call.
 *
 */


function getModalHtmlElement() {
  if ($('#editWishlistProductModal').length !== 0) {
    $('#editWishlistProductModal').remove();
  }

  var htmlString = '<!-- Modal -->' + '<div class="modal right fade edit-product-modal pr-0" id="editWishlistProductModal" tabindex="-1" role="dialog" aria-label="edit-modal">' + '<span class="enter-message sr-only" ></span>' + '<div class="modal-dialog quick-view-dialog cart-quick-view-dialog">' + '<!-- Modal content-->' + '<div class="modal-content rounded-0">' + '<div class="modal-header rounded-0">' + '    <button type="button" class="close pull-right" data-dismiss="modal"></button>' + '</div>' + '<div class="modal-body"></div>' + '<div class="modal-footer"></div>' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
 * Generates the border bottom after each row
 */


function borderBottomInRows() {
  var leftovers;

  if (isMobile) {
    leftovers = $('.main-wishlist .product-info:visible').length % 2;
  } else {
    leftovers = $('.main-wishlist .product-info:visible').length % 3;
  }

  $('.main-wishlist:visible .product-info:nth-last-child(-n+' + leftovers + ')').css('border-bottom', 'none');
}
/**
 * Generates padding for the error scenario
 */


function errorMessages() {
  if ($('.invalid-feedback').hasClass('visible')) {
    if (isMobile) {
      $('.overview-container .buttons-wishlist').css('padding-bottom', '65px');
      $('.tile-body').css('margin-bottom', '160px');
      $('.overview-container-cart .buttons-wishlist').css('padding-bottom', '60px');
    } else if (isDesktop) {
      $('.overview-container .buttons-wishlist').css('padding-bottom', '65px');
      $('.tile-body').css('margin-bottom', '140px');
      $('.overview-container-cart .buttons-wishlist').css('padding-bottom', '60px');
      $('.invalid-feedback').attr('id', 'selectOption');
      $('.select-attributes-wishList .select-attributes-btn').attr('aria-describedby', 'selectOption');
    } else {
      $('.overview-container .buttons-wishlist').css('padding-bottom', '80px');
      $('.tile-body').css('margin-bottom', '160px');
    }
  }
}
/**
 * Generates list of sold out products
 * @param {string} data - data returned from the server's ajax call
 */


function fetchingSoldOutProducts(data) {
  for (var i = 0; i < data.unavailableProducts.length; i++) {
    var soldOutProductID = data.unavailableProducts[i];
    var el = $('.product-grid').find('.product-info.pid-' + soldOutProductID + '.product-tile-wrapper');
    el.find('.invalid-feedback').css('display', 'block').addClass('visible').empty().append(DOMpurify.sanitize(data.OOSProductErrorMsg));
    el.find('.secondary-button-custom').addClass('is-invalid').closest('.buttons-wishlist');
    el.find('.sold-out').addClass('d-none');
    el.find('.remove-sold-out').removeClass('d-none');
    errorMessages();
  }
}
/**
 * Generates toast message for sold out and master products in wishlist
 * @param {string} data - data returned from the server's ajax call
 */


function floatMessagesForWishlist(data) {
  if ($('.float-toast-message-perma').children('.float-toast-errors').length !== 0) {
    if (!isMobile) {
      $('.float-toast-errors').removeAttr('role');
    }

    $('.cart-toasters').find('.toast-alert-error.wishlist-error').removeClass('d-none').empty().append('<span role ="alert">' + DOMpurify.sanitize(data.wishlistHasInvalidProductsErrorMessage) + '</span>');
    var toastMargin = $('.float-toast-message-perma').height() + 18;
    $('.cart-toasters .float-toast-message').css('margin-top', toastMargin);
  }
}
/**
 * Generates list of master products
 * @param {string} data - data returned from the server's ajax call
 */


function fetchingMasterProducts(data) {
  for (var i = 0; i < data.masterProducts.length; i++) {
    var masterProductID = DOMpurify.sanitize(data.masterProducts[i]);
    var el = $('.product-grid').find('.product-info.pid-' + masterProductID + '.product-tile-wrapper');
    el.find('.invalid-feedback').css('display', 'block').addClass('visible').empty().append(DOMpurify.sanitize(data.masterProductErrorMsg));
    el.find('.secondary-button-custom').addClass('is-invalid').closest('.buttons-wishlist');
    errorMessages();
  }
}
/**
 *
 * @param {html} elem - html element
 * @returns {boolean} - true if option selelcted
 */


function isSizeSelected(elem) {
  if (elem) {
    if (elem.find('.size-option').length === 0 || elem.find('.size-option.selected').length > 0) {
      elem.find('.select-size').removeClass('has-error');
      return true;
    }

    elem.find('.select-size').addClass('has-error');
    elem.find('.quickview-attribute-error').removeClass('d-none');
    elem.find('.select-size .size-option[data-isinstock="true"] input').removeAttr('aria-describedby');
    elem.find('.select-size .size-option[data-isinstock="true"]:first input').attr('aria-describedby', 'quickviewError');
    setTimeout(function () {
      elem.find('.select-size .size-option[data-isinstock="true"]:first input').focus();
    }, 1000);
  }

  return false;
}
/**
 * To check if the js-share btn has partially enabled class and stop the modal trigger
 */


function checkPartiallyEnabled() {
  var partiallyEnabled = $('.js-share-button:visible').hasClass('partially-enabled');

  if (!partiallyEnabled) {
    $('.js-share-button:visible').attr('data-target', '#shareFlyoutModal');
  } else {
    $('.js-share-button:visible').attr('data-target', '');
  }
}
/**
 * Deleting stored local storage value for share flyout error
 */


function deleteLocalStorageErrorShare() {
  if (localStorage.getItem('shareFlyoutError')) {
    $('.share-icon.partially-enabled').trigger('click');
    localStorage.removeItem('shareFlyoutError');
  }
}
/**
* Returns static wishlisted items
* @param {string} wishlistedItems - string containing currently wishlisted items
* @returns {Array} wishlisted items
* */


function getWishlistedProducts(wishlistedItems) {
  var wishlistedProducts;

  if (!wishlistedItems) {
    wishlistedProducts = $('.wishlistedItems').length > 0 ? $('.wishlistedItems').val().split(',') : '';
  } else {
    wishlistedProducts = wishlistedItems;
  }

  return wishlistedProducts.length > 0 ? wishlistedProducts : [];
}
/**
* Update heart icon header when adding and removing products while page loader
* @param {string} wishlistedItems - string containing currently wishlisted items
*/


function fillHeaderHeart(wishlistedItems) {
  updateMiniWishlist = true;

  if ($('.wishlistedItems').length > 0 && wishlistedItems !== undefined) {
    $('.wishlistedItems').val(DOMpurify.sanitize(wishlistedItems));
  }

  var wishlistedProducts = getWishlistedProducts(wishlistedItems);
  var noWishlistItems = wishlistedProducts.length === 0 || wishlistedProducts[0] === '' || wishlistedProducts[0] === 'null';
  var $wishlistIcon = $('.wishlist-icon');
  $wishlistIcon.find('.mk-icon.mk-heart').toggleClass('d-none', !noWishlistItems);
  $wishlistIcon.find('.mk-icon.mk-heart-filled').toggleClass('d-none', noWishlistItems);
}
/**
 * @param {boolean} updatewishlist - if miniwishlist is updated
 * @param {Object} wData - wishlist object data
 */


function popupdisplay() {
  var updatewishlist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var wData = arguments.length > 1 ? arguments[1] : undefined;

  if (updatewishlist) {
    var url = $('.miniwishlist').data('action-url');

    if (!updateMiniWishlist) {
      $('.miniwishlist .popover').addClass('show');
      return;
    }

    $('.miniwishlist .popover').addClass('show');
    $.get(url, function (data) {
      $('.miniwishlist .popover').empty();
      $('.miniwishlist .popover').append(data);

      if (wData !== undefined) {
        if (wData.addWishlist) {
          $('.toast-success').removeClass('d-none');
          $('.toast-remove').addClass('d-none');
        } else if (wData.removeWishlist) {
          $('.toast-remove').removeClass('d-none');
          $('.toast-success').addClass('d-none');
        }

        clientSideUtil.clearAndSetTime('.toast-message-miniwishlist .toast-basket-alert', wData.toastTime);
      }

      updateMiniWishlist = false;
      $('.popover .popover-overlay').on('touchstart click', function (event) {
        event.stopPropagation();
        $('.miniwishlist .popover').removeClass('show');
      });
      $('.mk-close-miniwishlist').on('touchstart click', function (event) {
        event.stopPropagation();
        setTimeout(function () {
          $('.miniwishlist .popover').removeClass('show');
        }, 300);
      });
    });
  }
}

module.exports = {
  addwishlistHeart: sharedwishlist.addToWishlist(),
  removewishlistHeart: sharedwishlist.removeWishlist(),
  borderBottomInRows: borderBottomInRows,
  isSizeSelected: isSizeSelected,
  checkPartiallyEnabled: checkPartiallyEnabled,
  errorMessages: errorMessages,
  popupdisplay: popupdisplay,
  fillHeaderHeart: fillHeaderHeart,
  addToWishlist: function addToWishlist() {
    $('.add-to-wish-list').on('click', function (e) {
      e.preventDefault();
      var url = $(this).data('href');
      var button = $(this);
      var pid = $(this).closest('.product-detail').data('pid');
      var optionId = $(this).closest('.product-detail').find('.product-option').attr('data-option-id');
      var optionVal = $(this).closest('.product-detail').find('.options-select option:selected').attr('data-value-id');
      optionId = optionId || null;
      optionVal = optionVal || null;

      if (!url || !pid) {
        return;
      }

      $.spinner().start();
      $(this).attr('disabled', true);
      $.ajax({
        url: url,
        type: 'post',
        dataType: 'json',
        data: {
          pid: pid,
          optionId: optionId,
          optionVal: optionVal
        },
        success: function success(data) {
          displayMessage(data, button);

          if (isWishlistMobileEnabled || !isMob) {
            popupdisplay(true);
            var timer = setTimeout(function () {
              $('.miniwishlist .popover').addClass('show');
            }, 4000);
            $('.miniwishlist .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
          }
        },
        error: function error(err) {
          displayMessage(err, button);
        }
      });
      e.stopImmediatePropagation();
      return false;
    });
  },
  addToCart: function addToCart() {
    $(document).on('click', '.overview-container button.add-to-cart-wishlist', function () {
      var addToCartUrl;
      var pid = $(this).closest('.product-info').data('pid');
      var quantityNew = parseInt($(this).closest('.product-info').find('.quantity-select').val(), 10);
      var action = $('.page').data('action');
      $('body').trigger('product:beforeAddToCart', this);
      addToCartUrl = $('.add-to-cart-url').val();
      var elMyAccount = $('.main-wishlist .product-info:visible').length;
      var sharedListid = null;

      if ($('.js-shared-fav-page').length > 0) {
        var querystring = $('.page').data('querystring');

        if (querystring) {
          sharedListid = querystring.split('&id=')[1];
        }
      }

      var form = {
        pid: pid,
        quantity: quantityNew,
        options: [],
        productCount: elMyAccount,
        action: action,
        sharedListid: sharedListid
      };
      $(this).trigger('updateAddToCartFormData', form);

      if (addToCartUrl) {
        $.spinner().start();
        $.ajax({
          url: addToCartUrl,
          method: 'POST',
          data: form,
          success: function success(data) {
            var isSuccess = true;

            if (DOMpurify.sanitize(data.wishlistOOSError)) {
              $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
              var el = $('.product-grid:visible').find('.product-info.pid-' + DOMpurify.sanitize(data.productID) + '.product-tile-wrapper');
              el.find('.invalid-feedback').css('display', 'block').addClass('visible').empty().append(DOMpurify.sanitize(data.OOSProductErrorMsg));
              el.find('.secondary-button-custom').addClass('is-invalid').closest('.buttons-wishlist');
              el.find('.sold-out').addClass('d-none');
              el.find('.remove-sold-out').removeClass('d-none');
              errorMessages();
              fillHeaderHeart(data.wishlistedItems);
              $.spinner().stop();

              if ($('.float-toast-message-perma').children('.float-toast-errors').length !== 0) {
                $('.cart-toasters').find('.toast-alert-error.wishlist-error').removeClass('d-none').empty().append(DOMpurify.sanitize(data.message));
                var toastMargin = $('.float-toast-message-perma').height() + 18;
                $('.cart-toasters .float-toast-message').css('margin-top', toastMargin);
              }
            } else if (data.cart.numItems === 0) {
              $('body').trigger('event:favAddToCart', data);
              location.reload();
            } else {
              $('body').trigger('product:afterAddToCart', data.message);
              $.spinner().stop();
              base.miniCartReportingUrl(data.reportingURL);
              $('.minicart-quantity').html(DOMpurify.sanitize(data.quantityTotal)).removeClass('invisible');
              var isProductAdded = true;
              $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime]);
              var selector = '.minicart .popover';
              var timer = setTimeout(function () {
                $(selector).removeClass('show');
              }, data.miniBagFlyOutTimeinMilliSec);
              $('.minicart .popover').on('mouseenter', function () {
                clearTimeout(timer);
              });
              $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
              $('.cart-toasters .toast-alert-error.wishlist-error').addClass('d-none').empty();
              $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));

              if (data.cartRenderedTemplate) {
                $('.product-card-section').empty().append(DOMpurify.sanitize(data.cartRenderedTemplate));
              }

              fillHeaderHeart(data.wishlistedItems);
              clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, isSuccess);
              $('body').trigger('event:addToCart', data);
            }
          },
          error: function error() {
            $.spinner().stop();
          }
        });
      }
    });
  },
  moveToCart: function moveToCart() {
    $(document).on('click', '.quick-view-dialog .move-to-cart-wishlist', function () {
      var productDetail = $(this).closest('.product-detail');
      var cartPage = $('.cart-page');

      if (!isSizeSelected(productDetail) || cartPage) {
        return;
      }

      var buttonBlock = $(this).closest('.wishlist-item-update-button-block').find('.add-to-cart-url');
      var addToCartUrl = buttonBlock.val();
      var uuid = buttonBlock.data('uuid');
      var pid = base.getPidValue($(this));
      var quantityNew = 1;
      var elMyAccount = $('.product-info').length;
      var action = $('.page').data('action');
      var querystring = $('.page').data('querystring');
      var sharedListid = null;

      if (querystring) {
        sharedListid = querystring.split('&id=')[1];
      }

      $('body').trigger('product:beforeAddToCart', this);
      var form = {
        pid: pid,
        uuid: uuid,
        quantity: quantityNew,
        options: [],
        productCount: elMyAccount,
        action: action,
        sharedListid: sharedListid
      };
      $(this).trigger('updateAddToCartFormData', form);

      if (addToCartUrl) {
        $.spinner().start();
        $.ajax({
          url: addToCartUrl,
          method: 'POST',
          data: form,
          success: function success(data) {
            var isSuccess = true;
            $.spinner().stop();
            $('body').trigger('product:afterAddToCart', data.message);
            $('#editWishlistProductModal').modal('hide');
            base.miniCartReportingUrl(data.reportingURL);
            $('.minicart-quantity').html(DOMpurify.sanitize(data.quantityTotal)).removeClass('invisible');
            var isProductAdded = true;
            $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime]);
            var selector = '.minicart .popover';
            var timer = setTimeout(function () {
              $(selector).removeClass('show');
            }, data.miniBagFlyOutTimeinMilliSec);
            $('.minicart .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });

            if (data.renderedTemplate) {
              $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
              $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));
            }

            clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, isSuccess);
            deleteLocalStorageErrorShare();
          },
          error: function error() {
            $.spinner().stop();
          }
        });
      }
    });
  },
  updateWishListItem: function updateWishListItem() {
    $(document).on('click', '.quick-view-dialog .update-wishlist-item', function () {
      var productDetail = $(this).closest('.product-detail');

      if (!isSizeSelected(productDetail)) {
        return;
      }

      var updateButtonBlock = $(this).closest('.wishlist-item-update-button-block').find('.update-wishlist-url');
      var updateProductUrl = updateButtonBlock.val();
      var uuid = updateButtonBlock.data('uuid');
      var querystring = $('.page').data('querystring');
      var sharedListid = null;

      if (querystring) {
        sharedListid = querystring.split('&id=')[1];
      }

      var form = {
        uuid: uuid,
        pid: base.getPidValue($(this)),
        sharedListid: sharedListid
      };

      if (updateProductUrl) {
        $.spinner().start();
        $.ajax({
          url: DOMpurify.sanitize(updateProductUrl),
          method: 'POST',
          data: form,
          success: function success(data) {
            $.spinner().stop();
            var isSuccess = true;
            $('#editWishlistProductModal').modal('hide');

            if (data.renderedTemplate) {
              $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
              $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));
              $('.cart-toasters .toast-alert-error.wishlist-error').addClass('d-none').empty();
            }

            clientSideUtil.floatToastMessage(data.itemOptionUpdatedMsg, data.toastMessageDisplayTime, isSuccess);
            checkPartiallyEnabled();
          },
          error: function error() {
            $.spinner().stop();
          }
        });
      }
    });
  },
  editFavorites: function editFavorites() {
    $('body').on('click', '.edit-add-to-wishlist a, .select-attributes-wishList button', function (e) {
      e.preventDefault();
      var editFavoriteUrl = $(this).attr('href');

      if (!editFavoriteUrl) {
        editFavoriteUrl = $(this).data('get-product-url');
      }

      $('.toast-oos.toast-alert-error.validate-basket').addClass('d-none');
      getModalHtmlElement();
      fillModalElement(editFavoriteUrl);
      notifyMe.submitRecaptchaNotifyMe();
    });
  },
  trapEditWishlistModalFocus: function trapEditWishlistModalFocus() {
    $('body').on('keydown', '#editWishlistProductModal', function (e) {
      var focusParams = {
        event: e,
        containerSelector: '#editWishlistProductModal',
        firstElementSelector: '.close',
        lastElementSelector: '.edit-flyout-cancel-btn'
      };
      focusHelper.setTabNextFocus(focusParams);
    });
  },
  printScreenWishlist: function printScreenWishlist() {
    $(document).on('click', '.print-cta', function () {
      window.print();
      return false;
    });
  },
  selectVariations: function selectVariations() {
    $('.select-attributes-btn').on('click', function () {
      getModalHtmlElement();
    });
  },
  removeFromWishlist: function removeFromWishlist() {
    $('body').on('touchstart click', '.remove-from-wishlist, .remove-sold-out', function (e) {
      e.preventDefault();
      var url = $(this).data('url');
      var elMyAccount = $('.main-wishlist .product-info:visible').length;
      var pageType = $('.page').data('action');
      var sharedListid = null;

      if ($('.js-shared-fav-page').length > 0) {
        var querystring = $('.page').data('querystring');

        if (querystring) {
          sharedListid = querystring.split('&id=')[1];
        }
      }

      var form = {
        productCount: elMyAccount,
        pageType: pageType,
        sharedListid: sharedListid
      }; // If user is in my account page, call removeWishlistAccount() end point, re-render wishlist cards

      if (elMyAccount > 0) {
        $.spinner().start();
        $.ajax({
          url: url,
          type: 'get',
          data: form,
          success: function success(data) {
            var isSuccess = true;
            $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
            $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));
            checkPartiallyEnabled();
            borderBottomInRows();
            $.spinner().stop();
            $('.cart-toasters .toast-alert-error.wishlist-error').addClass('d-none');
            $('.sub-total-wishlist').html($('.favourite-count').html());
            $('body').trigger('event:removeProductFromFavourites', data);
            deleteLocalStorageErrorShare();
            fillHeaderHeart(data.wishlistedItems);

            if (isWishlistMobileEnabled || !isMob) {
              popupdisplay(true, {
                addWishlist: false,
                removeWishlist: true,
                toastTime: data.toastMessageDisplayTime
              });
              var timer = setTimeout(function () {
                $('.miniwishlist .popover').addClass('show');
              }, data.miniFavouriteFlyOutTimeinMilliSec);
              $('.miniwishlist .popover').on('mouseenter', function () {
                clearTimeout(timer);
              });
            } else {
              clientSideUtil.floatToastMessage(data.productRemovedMsg, data.toastMessageDisplayTime, isSuccess);
            }
          },
          error: function error() {
            var $elToAppend = $('.product-info');
            $elToAppend.spinner().stop();
          }
        });
      }
    });
  },
  moreWLItems: function moreWLItems() {
    $('body').on('click', '.more-wl-items', function (e) {
      e.preventDefault();
      var url = $(this).data('href');
      var pageType = $('.page').data('action');
      var uuid = $('.js-shared-fav-page').length > 0 ? $(this).data('uuid') : '';
      var cardCount = $('.product-info.product-tile-wrapper').length;
      $.ajax({
        url: url,
        type: 'get',
        data: {
          pageType: pageType,
          sharedListId: uuid
        },
        success: function success(response) {
          $('.main-wishlist').empty().append(DOMpurify.sanitize(response));
          $('body').trigger('event:wlItemsShowMoreLessEvent');
          borderBottomInRows();
        },
        complete: function complete() {
          if (url.split('?')[1] && url.split('?')[1].indexOf('less') < 0) {
            $($('.product-info.product-tile-wrapper')[cardCount]).find('.remove-from-wishlist').focus();
          } else {
            $($('.product-info.product-tile-wrapper')[0]).find('.remove-from-wishlist').focus();
          }
        }
      });
    });
  },
  moveAllToBagEnabled: function moveAllToBagEnabled() {
    $('body').on('click', '.move-all-to-bag', function (e) {
      e.preventDefault();
      var pid;
      var pidsObj;
      var setPids;
      var action = $('.page').data('action');
      $('body').trigger('product:beforeAddToCart', this);
      var addAllToCartUrl = $('.move-all-to-bag').attr('href');
      var type = 'wishlist';
      setPids = [];
      $('.product-grid .product-info:visible').each(function () {
        setPids.push({
          pid: $(this).data('pid'),
          qty: '1',
          options: '[]'
        });
        pidsObj = JSON.stringify(setPids);
        pid = $(this).data('pid');
      });
      var sharedListid = null;

      if ($('.js-shared-fav-page').length > 0) {
        var querystring = $('.page').data('querystring');

        if (querystring) {
          sharedListid = querystring.split('&id=')[1];
        }
      }

      var form = {
        pid: pid,
        pidsObj: pidsObj,
        type: type,
        action: action,
        sharedListid: sharedListid
      };
      $(this).trigger('updateAddToCartFormData', form);

      if (addAllToCartUrl) {
        $.spinner().start();
        $.ajax({
          url: addAllToCartUrl,
          method: 'POST',
          data: form,
          success: function success(data) {
            var isSuccess = true;
            $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
            $('.js-favourite-heading').empty().append(DOMpurify.sanitize(data.senderName));

            if (DOMpurify.sanitize(data.wishlistOOSError)) {
              $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
              var $element = $('.product-grid:visible').find('.product-info.pid-' + DOMpurify.sanitize(data.productID) + '.product-tile-wrapper');
              $element.find('.invalid-feedback').css('display', 'block').addClass('visible').empty().append(DOMpurify.sanitize(data.OOSProductErrorMsg));
              $element.find('.secondary-button-custom').addClass('is-invalid').closest('.buttons-wishlist');
              $element.find('.sold-out').addClass('d-none');
              $element.find('.remove-sold-out').removeClass('d-none');
              errorMessages();
              $.spinner().stop();

              if ($('.float-toast-message-perma').children('.float-toast-errors').length !== 0) {
                $('.cart-toasters').find('.toast-alert-error.wishlist-error').removeClass('d-none').empty().append(DOMpurify.sanitize(data.message));
                var toastMargin = $('.float-toast-message-perma').height() + 18;
                $('.cart-toasters .float-toast-message').css('margin-top', toastMargin);
              }
            } else if (data.unavailableProducts && data.unavailableProducts.length > 0) {
              fetchingSoldOutProducts(data);
              $.spinner().stop();
              floatMessagesForWishlist(data);
            } else if (!data.masterProducts && data.masterProducts === undefined) {
              $('body').trigger('product:afterAddToCart', data.message);
              $.spinner().stop();
              base.miniCartReportingUrl(data.reportingURL);
              $('.minicart-quantity').html(DOMpurify.sanitize(data.quantityTotal)).removeClass('invisible');
              var isProductAdded = true;
              $('.minicart').trigger('minicart:update', [isProductAdded, data.toastMessageDisplayTime]);
              var selector = '.minicart .popover';
              var timer = setTimeout(function () {
                $(selector).removeClass('show');
              }, data.miniBagFlyOutTimeinMilliSec);
              $('.minicart .popover').on('mouseenter', function () {
                clearTimeout(timer);
              });
              $('.cart-toasters .toast-alert-error.wishlist-error').addClass('d-none');
              clientSideUtil.floatToastMessage(data.message, data.toastMessageDisplayTime, isSuccess);
            }

            if (data.masterProducts && data.masterProducts.length > 0) {
              fetchingMasterProducts(data);
              $.spinner().stop();
              floatMessagesForWishlist(data);
            } else if (data.cartRenderedTemplate) {
              location.reload();
            }
          },
          error: function error() {
            $.spinner().stop();
          }
        });
      }
    });
  },
  shareWishlistPartiallyEnabled: function shareWishlistPartiallyEnabled() {
    $('body').on('click', '.share-icon.partially-enabled', function (e) {
      e.preventDefault();
      var addAllToCartUrl = $('.share-icon').attr('href');
      var action = $('.page').data('action');
      var form = {
        action: action
      };

      if (addAllToCartUrl) {
        $.spinner().start();
        $.ajax({
          url: addAllToCartUrl,
          method: 'GET',
          data: form,
          success: function success(data) {
            $.spinner().stop();
            $('.main-wishlist').empty().append(DOMpurify.sanitize(data.renderedTemplate));
            fetchingMasterProducts(data);
            floatMessagesForWishlist(data);
          },
          error: function error() {
            $.spinner().stop();
          }
        });
      }
    });
  },
  updateAddToCart: function updateAddToCart() {
    $('body').on('product:updateAddToCart', function (e, response) {
      if (!response.product.available || !response.product.readyToOrder) {
        $('button.move-to-cart-wishlist', response.$productContainer).attr('disabled', true);
      } else {
        $('button.move-to-cart-wishlist', response.$productContainer).attr('disabled', !response.product.available);
        var moveToCartLabel = $('button.move-to-cart-wishlist', response.$productContainer).data('primary-label');
        $('button.move-to-cart-wishlist', response.$productContainer).html(moveToCartLabel);
      }
    });
  },
  removingBorderFromLastRow: function removingBorderFromLastRow() {
    borderBottomInRows();
  },
  activeTabCartPage: function activeTabCartPage() {
    $(document).on('click', '.js-shopping', function () {
      $('.js-shopping').removeClass('active-selected');
      $(this).addClass('active-selected');
    });
  },
  scrollingToMyFavouriteSection: function scrollingToMyFavouriteSection() {
    $(document).on('click', '.my-favourite-cart', function () {
      var $selectorParents = $('.main-wishlist:visible');
      var scrollValue = $selectorParents.offset().top;
      clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
    });
    $(document).on('scroll', function () {
      if ($('.cart-head').length !== 0 && $('.cart-head:visible').isInViewport()) {
        $('.js-shopping').removeClass('active-selected');
        $('.shopping-cart').addClass('active-selected');
      }
    });
  },
  closeFlyout: function closeFlyout() {
    $('body').on('click', '.edit-flyout-cancel-btn', function () {
      $('#editWishlistProductModal').modal('hide');
    });
  },
  errorMessageOnRefresh: function errorMessageOnRefresh() {
    deleteLocalStorageErrorShare();
  },
  miniwishlist: function miniwishlist() {
    $('body').on('touchstart click', function (e) {
      if ($('.miniwishlist').has(e.target).length <= 0) {
        setTimeout(function () {
          $('.miniwishlist .popover').removeClass('show');
        }, MENUCLOSEDELAY);
      }
    }); // keep miniwishlist open on hover, overwrite minicart button mouseleaves

    $('.miniwishlist').on('mouseenter touchstart', function (e) {
      if (e.target.closest('a') !== null && e.target.closest('a') === e.currentTarget.firstElementChild) {
        e.preventDefault();

        if (!$(this).find('.popover').hasClass('show')) {
          popupdisplay(true);
        }

        $('.miniwishlist .popover').addClass('show');
      }
    }).on('mouseleave', function () {
      setTimeout(function () {
        $('.miniwishlist .popover').removeClass('show');
      }, MENUCLOSEDELAY);
    });
    $('.miniwishlist').on('mouseleave', function (event) {
      if (event.type === 'focusout' && $('.miniwishlist .popover').has(event.target).length > 0 || event.type === 'mouseleave' && $(event.target).is('.miniwishlist .quantity') || $('body').hasClass('modal-open')) {
        event.stopPropagation();
        return;
      }

      setTimeout(function () {
        $('.miniwishlist .popover').removeClass('show');
      }, MENUCLOSEDELAY);
    });
    $(document).on('click', '.miniwishlist .view-wishlist-btn', function () {
      $('body').trigger('event:viewFavorites');
    });
    $(document).on('touchstart click', '.miniwishlist > a > i.mk-icon', function () {
      var windowWidth = $(window).width();

      if (windowWidth > SCREENSIZE.DESKTOPMIN) {
        $('body').trigger('event:heartIconClick');
      } else {
        $('body').trigger('event:heartIconClickEvent');
      }
    });
    $(document).on('click', '.navbar-nav.secondary-nav-container li.nav-item-heading a, .wishlist-icon a, .view-wishlist-button a', function (e) {
      if (($(this).children('i.mk-icon.mk-heart').length !== 0 || $(this).hasClass('view-wishlist-btn')) && $(this).attr('href').indexOf('#') > 0 && window.location.href.indexOf('/cart') > 0) {
        e.preventDefault();

        if ($('.navbar-toggler').hasClass('open')) {
          $('.navbar-toggler').trigger('click');
        }

        if ($('.miniwishlist .popover').hasClass('show')) {
          $('.miniwishlist .popover').removeClass('show');
        }

        var $selectorParents = $('.main-wishlist:visible');
        var scrollValue = $selectorParents.offset().top;
        clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
      }
    });
  },
  updateHeaderHeartIcon: function updateHeaderHeartIcon(wishlistedItems) {
    if (wishlistedItems !== undefined) {
      fillHeaderHeart(wishlistedItems);
    }
  },
  initialLoadCartPage: function initialLoadCartPage() {
    $(window).on('load', function () {
      setTimeout(function () {
        if (window.location.href.indexOf('/cart') > 0 && (window.location.hash === '#mobile-wishlist-anchor' || window.location.hash === '#wishlist-anchor')) {
          var $selectorParents = $('.main-wishlist:visible');
          var scrollValue = $selectorParents.offset().top;
          clientSideUtil.windowScrollToDestination(scrollValue, 0, 'smooth');
        }
      });
    });
  }
};
fillHeaderHeart(getWishlistedProducts());

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlistHeart.js":
/*!*******************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlistHeart.js ***!
  \*******************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideUtil = __webpack_require__(/*! ../utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var wishlisthelper = __webpack_require__(/*! ./wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js");

var isWishlistMobileEnabled = $('.right-nav').find('.wishlist-icon').hasClass('wishlist-icon-js');

var SCREENSIZE = (__webpack_require__(/*! ../utilities/constants */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js").SCREENSIZE);

var isMobile = $(window).width() <= SCREENSIZE.TABLETMAX;
var $body = $('body');
/**
 * Checks DOM element to understand the context
 * @return {boolean} if it's PLP
 */

function isPLP() {
  return $('.plp-container').length;
}
/**
* Update heart icon header when adding and removing products while page loader
* @param {Object} $element - jQuery element
* @param {boolean} fillIn - if the heart should be full or empty
*/


function toggleWishlistIcon($element, fillIn) {
  $element.find('.add-wish-list').toggleClass('d-none', fillIn);
  $element.find('.remove-from-wishlist').toggleClass('d-none', !fillIn);
}
/**
 * Show/hide favorite icons and buttons
 * @param {Object} productDetail - product detail container element
 */


function toggleFavorites(productDetail) {
  if (productDetail) {
    var detailContainer = productDetail; // Check if set product

    var productSet = detailContainer.find('.product-set-detail.product-wrapper');

    if (productSet.length > 0) {
      detailContainer = productSet;
    }

    detailContainer.find('.btn-favorite').toggleClass('d-none');
  }
}
/**
* Update heart icon header when adding and removing products while page loader
* @param {Object} $icon - jQuery element
* @returns {string} pdp or plp id
*/


function getProductId($icon) {
  var pid = $icon.closest('.product-tile-show').attr('data-pid');
  return pid;
}
/**
 * appends params to a url
 * @param {string} data - data returned from the server's ajax call
 * @param {Object} icon - icon that was clicked to add a product to the wishlist
 */


module.exports = {
  addToWishlist: function addToWishlist(element) {
    var $icon = $(element);
    var url = $icon.attr('href');
    var pid = getProductId($icon);

    if (!url || !pid) {
      return;
    }

    var optionId = $icon.closest('.product-detail').find('.product-option').attr('data-option-id') || null;
    var optionVal = $icon.closest('.product-detail').find('.options-select option:selected').attr('data-value-id') || null;
    $.spinner().start();
    $.ajax({
      url: url,
      type: 'post',
      dataType: 'json',
      data: {
        pid: pid,
        optionId: optionId,
        optionVal: optionVal
      },
      success: function success(data) {
        var isSuccess;

        if (data.error) {
          isSuccess = false;

          if (data.msg) {
            clientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }
        } else {
          isSuccess = true;
          $body.trigger('event:addProductToFavourites', data);
          $('.main-wishlist').empty().append(data.renderedTemplate);
          $icon.addClass('d-none');
          $icon.parent('.image-container').find('.remove-from-wishlist').removeClass('d-none');
          wishlisthelper.updateHeaderHeartIcon(data.wishlistedItems);

          if (isWishlistMobileEnabled || !isMobile) {
            wishlisthelper.popupdisplay(true, {
              addWishlist: true,
              removeWishlist: false,
              toastTime: data.toastMessageDisplayTime
            });
            var timer = setTimeout(function () {
              $('.miniwishlist .popover').removeClass('show');
            }, data.miniFavouriteFlyOutTimeinMilliSec);
            $('.miniwishlist .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
          } else if (data.msg) {
            clientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }

          if ($('.cart').length) {
            $('.sub-total-wishlist').text("(".concat(data.wishlistTotal, ")"));
          }
        }

        $.spinner().stop();
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  },
  removeFromWishlist: function removeFromWishlist(element) {
    var $icon = $(element);
    var url = $icon.attr('href') || $icon.attr('data-href') || $icon.attr('data-url');

    if (!url) {
      return;
    }

    $.spinner().start();
    $.ajax({
      url: url,
      type: 'get',
      success: function success(data) {
        var isSuccess;
        $.spinner().stop();

        if (data.error) {
          isSuccess = false;

          if (data.productRemovedMsg) {
            clientSideUtil.floatToastMessage(data.msg, data.toastMessageDisplayTime, isSuccess);
          }
        } else {
          isSuccess = true;
          $('body').trigger('event:removeProductFromFavourites', data);
          var thisPID = $icon.closest('[data-pid]').data('pid');

          if (!thisPID) {
            thisPID = $icon.closest('[data-productid]').data('productid');
          }

          if (!isPLP() && '.product-detail'.length) {
            var $targetPDPTile = $('.product-detail[data-pid=' + thisPID + ']');
            toggleFavorites($targetPDPTile);
          } else if (isPLP() && $('.plp-container .product-tile-show').length) {
            var $targetPLPTile = $('.product-tile-show[data-pid=' + thisPID + ']');
            toggleWishlistIcon($targetPLPTile, false);
          }

          $icon.addClass('d-none');
          $icon.parent('.image-container').find('.add-wish-list').removeClass('d-none');
          wishlisthelper.updateHeaderHeartIcon(data.wishlistedItems);

          if (isWishlistMobileEnabled || !isMobile) {
            wishlisthelper.popupdisplay(true, {
              addWishlist: false,
              removeWishlist: true,
              toastTime: data.toastMessageDisplayTime
            });
            var timer = setTimeout(function () {
              $('.miniwishlist .popover').removeClass('show');
            }, data.miniFavouriteFlyOutTimeinMilliSec);
            $('.miniwishlist .popover').on('mouseenter', function () {
              clearTimeout(timer);
            });
          } else if (data.productRemovedMsg) {
            clientSideUtil.floatToastMessage(data.productRemovedMsg, data.toastMessageDisplayTime, isSuccess);
          }
        }
      }
    });
  },
  bindingEvents: function bindingEvents() {
    var thisObj = this;
    $body.on('touchstart click', '.wishlistTile.add-wish-list', function (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      thisObj.addToWishlist(this);
    });
    $body.on('touchstart click', '.remove-from-wishlist', function (e) {
      e.preventDefault();
      var elMyAccount = $('.main-wishlist .product-info:visible').length;

      if (elMyAccount <= 0) {
        thisObj.removeFromWishlist(this);
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/shareFlyout.js":
/*!*********************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/shareFlyout.js ***!
  \*********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var clientSideValidation = __webpack_require__(/*! ./components/clientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js");

var clientSideUtil = __webpack_require__(/*! ./utilities/clientSideUtil */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js");

var formHelpers = __webpack_require__(/*! ./checkout/formErrors */ "./cartridges/app_mk_storefront/cartridge/client/default/js/checkout/formErrors.js");

var wishlist = __webpack_require__(/*! ./product/wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js");

var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");
/**
 * Textarea message count
 */


function messageCharacterLimit() {
  $(document).on('keyup', 'textarea#message', function () {
    var maxLength = $(this).attr('maxlength');
    var textlength = maxLength - $(this).val().length;
    $('#msgLimit').text(textlength);
  });
}
/**
 * Handle the form submit or button click
 */


function handleShareSendSubmit() {
  var form = $('#share-flyout-form');
  var formObj;
  var formValid;
  formObj = form.get(0);
  formValid = clientSideValidation.functions.validateForm(formObj);

  if (formValid) {
    var formUrl = $(form).attr('action');
    var newForm = $('#share-flyout-form').serialize();
    $.spinner().start();
    $.ajax({
      url: formUrl,
      method: 'POST',
      data: newForm,
      success: function success(data) {
        var isSuccess = true;
        $.spinner().stop();
        clientSideUtil.floatToastMessage(data.wishlistHasValidProductsSuccessMessage, data.toastMessageDisplayTime, isSuccess);
        $('.share-flyout-modal .close').trigger('click');
      },
      error: function error() {
        $.spinner().stop();
      }
    });
  }
}

module.exports = {
  shareFormSubmit: function shareFormSubmit() {
    $(document).on('click', '.js-send-share-flyout', function (e) {
      e.preventDefault();
      handleShareSendSubmit();
    });
  },
  shareLinkClick: function shareLinkClick() {
    $(document).on('click', '.js-share-button', function (e) {
      e.preventDefault();
      $('form#share-flyout-form input, form#share-flyout-form textarea').val('');
      formHelpers.clearPreviousErrors('#share-flyout-form');
      var url = $(this).attr('href');
      $.ajax({
        url: url,
        type: 'get',
        dataType: 'json'
      }).done(function (data) {
        if ($('.js-share-button').hasClass('enabled') && data.masterProductErrorMsg) {
          localStorage.setItem('shareFlyoutError', true);
          window.location.reload();
        }

        $('#shareFlyoutModal .modal-body').empty().append(DOMpurify.sanitize(data.renderedTemplateShareFlyout));
        wishlist.checkPartiallyEnabled();
        clientSideValidation.invalid();
        clientSideValidation.submit();
        clientSideValidation.buttonClick();
        messageCharacterLimit();
        $('form#share-flyout-form input:not([type=hidden]), form#share-flyout-form textarea').val('');
      }).fail(function (err) {
        if (err.responseJSON.redirectUrl) {
          window.location.href = DOMpurify.sanitize(err.responseJSON.redirectUrl);
        }
      });
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/loqateAddressSuggestion.js":
/*!********************************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/loqateAddressSuggestion.js ***!
  \********************************************************************************************************/
/***/ (function(module) {

"use strict";

/**
 * Address suggestion modal creation
 */

function createAddressSuggestionModal() {
  var htmlString = '<!-- Modal -->' + '<div class="modal fade loqate-address-suggestion d-flex align-items-center justify-content-center p-4" id="loqate-address-suggestion" tabindex="-1" role="dialog" aria-labelledby="loqateAddressSuggestion">' + '<div class="modal-dialog modal-margin">' + '<!-- Modal content-->' + '<div class="modal-content">' + '</div>' + '</div>' + '</div>';
  $('body').append(htmlString);
}
/**
 * Address suggestion modal destroy
 * @param {boolean} isEditAddress - boolean
 */


function destroySuggestionModal(isEditAddress) {
  $('#loqate-address-suggestion').remove();
  $('.modal-backdrop').remove();
  $('body').removeClass('modal-open');

  if (!isEditAddress) {
    $('.btn-save-shipping-address').attr('data-isverified', 'true');
    $('.save-address-btn a').attr('data-isverified', 'true');

    if ($('#checkout-main').data('customer-type') === 'registered') {
      $('#shipmentSelector-default option:selected').attr('data-isverified', 'true');
      $('.submit-shipping').attr('data-isverified', $('#shipmentSelector-default option:selected').attr('data-isverified'));
      $('#billingAddressSelector option:selected').attr('data-isverified', 'true');
      $('.submit-payment').attr('data-isverified', $('#billingAddressSelector option:selected').attr('data-isverified'));
    }

    $('.btn-save-billing-address').attr('data-isverified', 'true');
    $('input[name="isVerified"]').val('false');
  } else {
    var currentStage = $('#addressFormAccordion');

    if ($('#checkout-main').length > 0) {
      currentStage = $('#checkout-main').attr('data-checkout-stage');

      if (currentStage === 'shipping') {
        if ($('.shipping-address-block').css('display') === 'none' || $('.shipping-form .customer-checkout-label').attr('data-address-method') === 'edit') {
          $('.shipping-address-block').addClass('d-block');
          $('.edit-save-block, .shipment-summary-change-block, .js-address-method-link').addClass('d-none');
          $('.js-shipping-address-block').removeClass('collapsed');
          $('.save-address-shipping.edit').removeClass('d-none');
          $('.save-address-shipping.save').addClass('d-none');
          $('.save-address-shipping.edit a').addClass('active-suggestion');
        }

        $('#shippingAddressOnedefault').focus();
      } else if (currentStage === 'payment') {
        if ($('.billing-address').hasClass('d-none')) {
          $('.billing-address').removeClass('d-none').addClass('d-block');
          $('.billing-address-summary').addClass('d-none');
          $('.edit-add-billing-address').removeClass('d-flex').addClass('d-none');
          $('.billing-address .address-method-link').addClass('d-none');
          $('.billing-address .js-shipping-address-block').removeClass('collapsed');
          $('.billing-address .loqate-address-block').addClass('d-none');
          $('.btn-save-billing-address').addClass('active-suggestion');
        }

        $('#billingAddressOne').focus();
      }
    } else {
      $('.js-shipping-address-block .addressBookAddressOne').focus();
    }
  }
}
/**
 * Address suggestion custom attribute
 */


function reIntialiseSuggestionModal() {
  $('.submit-shipping').attr('data-isverified', 'false');
  $('.btn-save-shipping-address').attr('data-isverified', 'false');
  $('.save-address-btn a').attr('data-isverified', 'false');
  $('.btn-save-billing-address').attr('data-isverified', 'false');
}
/**
 * Button class to trigger Address suggestion
 * @param {JQuery} $selector - the jquery element that required this class to trigger the address suggestion
 * On page load also we're calling this function
 */


function addClassToCTA($selector) {
  if ($selector.data('address-verify-enabled')) {
    if ($selector.data('address-suggestion-enabled')) {
      $selector.addClass('active-suggestion');
    }
  }
}
/**
 * Empty check for loqate formated field
 * @param {JQuery} formSelector - Current form which need to validate the loqate fields
 */


function loqateRequiredValidation(formSelector) {
  var $loqateAddressSuggestionField = $(formSelector).find('.js-address-suggestion');

  if (!$(formSelector).find('.js-loqate-address-block').hasClass('d-none') && $loqateAddressSuggestionField.length > 0 && $loqateAddressSuggestionField.val().length === 0) {
    $loqateAddressSuggestionField.addClass('is-invalid');
    $loqateAddressSuggestionField.attr('aria-invalid', 'true');
    var validationMessage = $loqateAddressSuggestionField.data('missing-error');
    $(formSelector).find('.js-loqate-address-block .invalid-feedback').text(validationMessage);
  }
}
/**
 * Empty check for loqate formated field
 * @param {JQuery} formSelector - Current form which need to validate the loqate fields
 * @return {boolean} true/false - Based on error on the current form
 */


function formValid(formSelector) {
  var $loqateAddressSuggestionField = formSelector.find('.js-address-suggestion');

  if ($loqateAddressSuggestionField.length > 0 && $loqateAddressSuggestionField.hasClass('is-invalid')) {
    return false;
  }

  return true;
}
/**
 * Check for laqate address modal Save and Continue button
 * @return {boolean} true/false - Based on save and continue button
 */


function saveAndContinue() {
  var isSaveAndContinue;

  if ($('.js-save-suggested-address').length === 0) {
    isSaveAndContinue = false;
  } else {
    isSaveAndContinue = true;
  }

  return isSaveAndContinue;
}
/**
 * Store address form state
 * @param {JQuery} formSelector - form to store its previous state
 */


function storeAddressFormState(formSelector) {
  var $shippingAddressFieldSet = $('#shipmentSelector-default option:selected');
  var shippingFirstName = formSelector.find('.shippingFirstName').val();
  $shippingAddressFieldSet.data('first-name', shippingFirstName);
  var shippingLastName = formSelector.find('.shippingLastName').val();
  $shippingAddressFieldSet.data('last-name', shippingLastName);
  var shippingPhone = formSelector.find('.shippingPhoneNumber').val();
  $shippingAddressFieldSet.data('phone', shippingPhone);
  var shippingAddressOne = formSelector.find('.shippingAddressOne').val();
  $shippingAddressFieldSet.data('address1', shippingAddressOne);
  var shippingAddressTwo = formSelector.find('.shippingAddressTwo').val();
  $shippingAddressFieldSet.data('address2', shippingAddressTwo);
  var shippingAddressCity = formSelector.find('.shippingAddressCity').val();
  $shippingAddressFieldSet.data('city', shippingAddressCity);
  var shippingState = formSelector.find('.shippingState').val();
  $shippingAddressFieldSet.data('state-code', shippingState);
  var shippingZipCode = formSelector.find('.shippingZipCode').val();
  $shippingAddressFieldSet.data('postal-code', shippingZipCode);
}
/**
 * Compare edited address changes for address verification
 * @param {string} loqateSuggestAddress - loqate suggested address
 * @param {string} currentEnteredAddress - current entered address
 */


function verifyNewAddress(loqateSuggestAddress, currentEnteredAddress) {
  var addressVerifyEnabled = currentEnteredAddress === '.billing-address' ? $('.payment-submit-section .submit-payment') : $('.submit-shipping');

  if (addressVerifyEnabled.data('address-verify-enabled')) {
    var address1 = $(loqateSuggestAddress).attr('data-address-one');
    var address2 = $(loqateSuggestAddress).attr('data-address-two');
    var city = $(loqateSuggestAddress).attr('data-address-city');
    var state = $(loqateSuggestAddress).attr('data-address-state');
    var postCode = $(loqateSuggestAddress).attr('data-address-zip-code');

    if (!(address1 === $(currentEnteredAddress).find('.addressOneValidator').val() && address2 === $(currentEnteredAddress).find('.addressTwoValidator').val() && city === $(currentEnteredAddress).find('.addressCityValidator').val() && state === $(currentEnteredAddress).find('.addressStateValidator').val() && postCode.toString() === $(currentEnteredAddress).find('.addressZipCodeValidator').val())) {
      $('.btn-save-shipping-address').addClass('active-suggestion');

      if (currentEnteredAddress === '.billing-address') {
        $('.submit-payment').attr('data-isverified', false);
      } else if (currentEnteredAddress === '.shipping-address-block' && $('.data-checkout-stage').data('customer-type') === 'guest') {
        $('.submit-shipping').attr('data-isverified', false);
      }
    }
  }
}
/**
 * set selected address billing value to hidden input field
 */


function updateBillingSelectedAddress() {
  // Clearing attribute before updating the selected address
  $('#loqateSelectedBillingAddress').attr('data-address-one', '');
  $('#loqateSelectedBillingAddress').attr('data-address-two', '');
  $('#loqateSelectedBillingAddress').attr('data-address-city', '');
  $('#loqateSelectedBillingAddress').attr('data-address-state', '');
  $('#loqateSelectedBillingAddress').attr('data-address-zip-code', '');
  $('#loqateSelectedBillingAddress').attr('data-address-country-code', ''); // updating attribute with selected address

  $('#loqateSelectedBillingAddress').attr('data-address-one', $('.billing-address .billingAddressOne').val());
  $('#loqateSelectedBillingAddress').attr('data-address-two', $('.billing-address .billingAddressTwo').val());
  $('#loqateSelectedBillingAddress').attr('data-address-city', $('.billing-address .billingAddressCity').val());
  $('#loqateSelectedBillingAddress').attr('data-address-state', $('.billing-address .billingState option:selected').val());
  $('#loqateSelectedBillingAddress').attr('data-address-zip-code', $('.billing-address .billingZipCode').val());
  $('#loqateSelectedBillingAddress').attr('data-address-country-code', $('.billingCountry option:selected').val());
}
/**
 * Disable Address One Validation
 * @param {string}  addressModeType - Check if current address is edit/new
 */


function addressOneDisableValidation(addressModeType) {
  if (addressModeType === 'edit') {
    $('.js-address-suggestion').removeAttr('required');
    $('.js-address-suggestion').removeAttr('aria-required');
    $('.js-address-suggestion').removeAttr('aria-invalid');
    $('.js-address-suggestion').removeClass('is-invalid');
    $('.js-loqate-address-block .form-group').removeClass('required').removeClass('is-invalid');
    $('.js-loqate-address-block').addClass('d-none');
  }
}
/**
 * check if selected address mode is edit/new
 */


function addressModeCheck() {
  var addressModeType;

  if ($('.shipment-selector-block .customer-checkout-label').length > 0) {
    addressModeType = $('.shipment-selector-block .customer-checkout-label').attr('data-address-method');
    addressOneDisableValidation(addressModeType);
  }
}

module.exports = {
  methods: {
    createAddressSuggestionModal: createAddressSuggestionModal,
    addClassToCTA: addClassToCTA,
    destroySuggestionModal: destroySuggestionModal,
    reIntialiseSuggestionModal: reIntialiseSuggestionModal,
    loqateRequiredValidation: loqateRequiredValidation,
    formValid: formValid,
    saveAndContinue: saveAndContinue,
    storeAddressFormState: storeAddressFormState,
    verifyNewAddress: verifyNewAddress,
    updateBillingSelectedAddress: updateBillingSelectedAddress,
    addressModeCheck: addressModeCheck,
    addressOneDisableValidation: addressOneDisableValidation
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/mediaZoom.js":
/*!******************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/mediaZoom.js ***!
  \******************************************************************************************/
/***/ (function(module) {

/* jshint -W071, -W074 */

/* global jQuery:false */

/* Disabled options are:
 * W071: This function has too many statements
 * W074: This function's cyclomatic complexity is too high
 */

/*
 *	jQuery ezPlus 1.1.6
 *	Demo's and documentation:
 *	http://igorlino.github.io/elevatezoom-plus/
 *
 *	licensed under MIT license.
 *	http://en.wikipedia.org/wiki/MIT_License
 *
 */
function productMediaZoom() {
  if (typeof Object.create !== 'function') {
    Object.create = function (obj) {
      function F() {}

      F.prototype = obj;
      return new F();
    };
  }

  (function ($, window, document, undefined) {
    var EZP = {
      init: function init(options, elem) {
        var self = this;
        var $galleries;
        self.elem = elem;
        self.$elem = $(elem);
        self.imageSrc = self.$elem.data('zoom-image') ? self.$elem.data('zoom-image') : self.$elem.attr('src');
        self.options = $.extend({}, $.fn.ezPlus.options, self.responsiveConfig(options || {}));

        if (!self.options.enabled) {
          return;
        } //TINT OVERRIDE SETTINGS


        if (self.options.tint) {
          self.options.lensColour = 'none'; //colour of the lens background

          self.options.lensOpacity = '1'; //opacity of the lens
        } //INNER OVERRIDE SETTINGS


        if (self.options.zoomType === 'inner') {
          self.options.showLens = false;
        } //Remove alt on hover


        self.$elem.parent().removeAttr('title').removeAttr('alt');
        self.zoomImage = self.imageSrc;
        self.refresh(1); //Create the image swap from the gallery

        $galleries = $(self.options.gallery ? '#' + self.options.gallery : self.options.gallerySelector);
        $galleries.on('click.zoom', self.options.galleryItem, function (e) {
          //Set a class on the currently active gallery image
          if (self.options.galleryActiveClass) {
            $(self.options.galleryItem, $galleries).removeClass(self.options.galleryActiveClass);
            $(this).addClass(self.options.galleryActiveClass);
          } //stop any link on the a tag from working


          if (this.tagName === 'A') {
            e.preventDefault();
          } //call the swap image function


          if ($(this).data('zoom-image')) {
            self.zoomImagePre = $(this).data('zoom-image');
          } else {
            self.zoomImagePre = $(this).data('image');
          }

          self.swaptheimage($(this).data('image'), self.zoomImagePre);

          if (this.tagName === 'A') {
            return false;
          }
        });
      },
      refresh: function refresh(length) {
        var self = this;
        setTimeout(function () {
          self.fetch(self.imageSrc);
        }, length || self.options.refresh);
      },
      fetch: function fetch(imgsrc) {
        //get the image
        var self = this;
        var newImg = new Image();

        newImg.onload = function () {
          //set the large image dimensions - used to calculte ratio's
          self.largeWidth = newImg.width;
          self.largeHeight = newImg.height; //once image is loaded start the calls

          self.startZoom();
          self.currentImage = self.imageSrc; //let caller know image has been loaded

          self.options.onZoomedImageLoaded(self.$elem);
        };

        self.setImageSource(newImg, imgsrc); // this must be done AFTER setting onload

        return;
      },
      setImageSource: function setImageSource(image, src) {
        //sets an image's source.
        image.src = src;
      },
      startZoom: function startZoom() {
        var self = this; //get dimensions of the non zoomed image

        self.nzWidth = self.$elem.width();
        self.nzHeight = self.$elem.height(); //activated elements

        self.isWindowActive = false;
        self.isLensActive = false;
        self.isTintActive = false;
        self.overWindow = false; //CrossFade Wrapper

        if (self.options.imageCrossfade) {
          self.zoomWrap = self.$elem.wrap('<div style="height:' + self.nzHeight + 'px;width:' + self.nzWidth + 'px;" class="zoomWrapper" />');
          self.$elem.css('position', 'absolute');
        }

        self.zoomLock = 1;
        self.scrollingLock = false;
        self.changeBgSize = false;
        self.currentZoomLevel = self.options.zoomLevel; //get offset of the non zoomed image

        self.nzOffset = self.$elem.offset(); //calculate the width ratio of the large/small image

        self.widthRatio = self.largeWidth / self.currentZoomLevel / self.nzWidth;
        self.heightRatio = self.largeHeight / self.currentZoomLevel / self.nzHeight;

        function getWindowZoomStyle() {
          return 'overflow: hidden;' + 'background-position: 0px 0px;text-align:center;' + 'background-color: ' + String(self.options.zoomWindowBgColour) + ';' + 'width: ' + String(self.options.zoomWindowWidth) + 'px;' + 'height: ' + String(self.options.zoomWindowHeight) + 'px;' + 'float: left;' + 'background-size: ' + self.largeWidth / self.currentZoomLevel + 'px ' + self.largeHeight / self.currentZoomLevel + 'px;' + 'display: none;z-index:100;' + 'border: ' + String(self.options.borderSize) + 'px solid ' + self.options.borderColour + ';' + 'background-repeat: no-repeat;' + 'position: absolute;';
        } //if window zoom


        if (self.options.zoomType === 'window') {
          self.zoomWindowStyle = getWindowZoomStyle();
        }

        function getInnerZoomStyle() {
          //has a border been put on the image? Lets cater for this
          var borderWidth = self.$elem.css('border-left-width');
          return 'overflow: hidden;' + 'margin-left: ' + String(borderWidth) + ';' + 'margin-top: ' + String(borderWidth) + ';' + 'background-position: 0px 0px;' + 'width: ' + String(self.nzWidth) + 'px;' + 'height: ' + String(self.nzHeight) + 'px;' + 'float: left;' + 'display: none;' + 'cursor:' + self.options.cursor + ';' + 'px solid ' + self.options.borderColour + ';' + 'background-repeat: no-repeat;' + 'position: absolute;';
        } //if inner  zoom


        if (self.options.zoomType === 'inner') {
          self.zoomWindowStyle = getInnerZoomStyle();
        }

        function getWindowLensStyle() {
          var lensHeight, lensWidth; // adjust images less than the window height

          if (self.nzHeight < self.options.zoomWindowHeight / self.heightRatio) {
            lensHeight = self.nzHeight;
          } else {
            lensHeight = String(self.options.zoomWindowHeight / self.heightRatio);
          }

          if (self.largeWidth < self.options.zoomWindowWidth) {
            lensWidth = self.nzWidth;
          } else {
            lensWidth = String(self.options.zoomWindowWidth / self.widthRatio);
          }

          return 'background-position: 0px 0px;width: ' + String(self.options.zoomWindowWidth / self.widthRatio) + 'px;' + 'height: ' + String(self.options.zoomWindowHeight / self.heightRatio) + 'px;float: right;display: none;' + 'overflow: hidden;' + 'z-index: 999;' + 'opacity:' + self.options.lensOpacity + ';filter: alpha(opacity = ' + self.options.lensOpacity * 100 + '); zoom:1;' + 'width:' + lensWidth + 'px;' + 'height:' + lensHeight + 'px;' + 'background-color:' + self.options.lensColour + ';' + 'cursor:' + self.options.cursor + ';' + 'border: ' + self.options.lensBorderSize + 'px' + ' solid ' + self.options.lensBorderColour + ';background-repeat: no-repeat;position: absolute;';
        } //lens style for window zoom


        if (self.options.zoomType === 'window') {
          self.lensStyle = getWindowLensStyle();
        } //tint style


        self.tintStyle = 'display: block;' + 'position: absolute;' + 'background-color: ' + self.options.tintColour + ';' + 'filter:alpha(opacity=0);' + 'opacity: 0;' + 'width: ' + self.nzWidth + 'px;' + 'height: ' + self.nzHeight + 'px;'; //lens style for lens zoom with optional round for modern browsers

        self.lensRound = '';

        if (self.options.zoomType === 'lens') {
          self.lensStyle = 'background-position: 0px 0px;' + 'float: left;display: none;' + 'border: ' + String(self.options.borderSize) + 'px solid ' + self.options.borderColour + ';' + 'width:' + String(self.options.lensSize) + 'px;' + 'height:' + String(self.options.lensSize) + 'px;' + 'background-repeat: no-repeat;position: absolute;';
        } //does not round in all browsers


        if (self.options.lensShape === 'round') {
          self.lensRound = 'border-top-left-radius: ' + String(self.options.lensSize / 2 + self.options.borderSize) + 'px;' + 'border-top-right-radius: ' + String(self.options.lensSize / 2 + self.options.borderSize) + 'px;' + 'border-bottom-left-radius: ' + String(self.options.lensSize / 2 + self.options.borderSize) + 'px;' + 'border-bottom-right-radius: ' + String(self.options.lensSize / 2 + self.options.borderSize) + 'px;';
        } //create the div's                                                + ""
        //self.zoomContainer = $('<div/>').addClass('zoomContainer').css({"position":"relative", "height":self.nzHeight, "width":self.nzWidth});


        self.zoomContainer = $('<div class="zoomContainer" style="' + 'position:absolute;' + 'left:' + self.nzOffset.left + 'px;' + 'top:' + self.nzOffset.top + 'px;' + 'height:' + self.nzHeight + 'px;' + '' + 'width:' + self.nzWidth + 'px;' + 'z-index:' + self.options.zIndex + '"></div>');
        $(self.options.zoomContainerAppendTo).append(self.zoomContainer); //this will add overflow hidden and contrain the lens on lens mode

        if (self.options.containLensZoom && self.options.zoomType === 'lens') {
          self.zoomContainer.css('overflow', 'hidden');
        }

        if (self.options.zoomType !== 'inner') {
          self.zoomLens = $('<div class="zoomLens" style="' + self.lensStyle + self.lensRound + '">&nbsp;</div>').appendTo(self.zoomContainer).click(function () {
            self.$elem.trigger('click');
          });

          if (self.options.tint) {
            self.tintContainer = $('<div/>').addClass('tintContainer');
            self.zoomTint = $('<div class="zoomTint" style="' + self.tintStyle + '"></div>');
            self.zoomLens.wrap(self.tintContainer);
            self.zoomTintcss = self.zoomLens.after(self.zoomTint); //if tint enabled - set an image to show over the tint

            self.zoomTintImage = $('<img style="' + 'position: absolute; left: 0px; top: 0px; max-width: none; ' + 'width: ' + self.nzWidth + 'px; ' + 'height: ' + self.nzHeight + 'px;" ' + 'src="' + self.imageSrc + '">').appendTo(self.zoomLens).click(function () {
              self.$elem.trigger('click');
            });
          }
        }

        var targetZoomContainer = isNaN(self.options.zoomWindowPosition) ? 'body' : self.zoomContainer; //create zoom window

        self.zoomWindow = $('<div style="z-index:999;' + 'left:' + self.windowOffsetLeft + 'px;' + 'top:' + self.windowOffsetTop + 'px;' + self.zoomWindowStyle + '" class="zoomWindow">&nbsp;</div>').appendTo(targetZoomContainer).click(function () {
          self.$elem.trigger('click');
        });
        self.zoomWindowContainer = $('<div/>').addClass('zoomWindowContainer').css('width', self.options.zoomWindowWidth);
        self.zoomWindow.wrap(self.zoomWindowContainer); //  self.captionStyle = "text-align: left;background-color: black;'+
        // 'color: white;font-weight: bold;padding: 10px;font-family: sans-serif;font-size: 11px";
        // self.zoomCaption = $('<div class="ezplus-caption" '+
        // 'style="'+self.captionStyle+'display: block; width: 280px;">INSERT ALT TAG</div>').appendTo(self.zoomWindow.parent());

        if (self.options.zoomType === 'lens') {
          self.zoomLens.css('background-image', 'url("' + self.imageSrc + '")');
        }

        if (self.options.zoomType === 'window') {
          self.zoomWindow.css('background-image', 'url("' + self.imageSrc + '")');
        }

        if (self.options.zoomType === 'inner') {
          self.zoomWindow.css('background-image', 'url("' + self.imageSrc + '")');
        }
        /*-------------------END THE ZOOM WINDOW AND LENS----------------------------------*/


        if (self.options.touchEnabled) {
          //touch events
          self.$elem.bind('touchmove', function (e) {
            e.preventDefault();
            var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
            self.setPosition(touch);
          });
          self.zoomContainer.bind('touchmove', function (e) {
            if (self.options.zoomType === 'inner') {
              self.showHideWindow('show');
            }

            e.preventDefault();
            var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
            self.setPosition(touch);
          });
          self.zoomContainer.bind('touchend', function (e) {
            self.showHideWindow('hide');

            if (self.options.showLens) {
              self.showHideLens('hide');
            }

            if (self.options.tint && self.options.zoomType !== 'inner') {
              self.showHideTint('hide');
            }
          });
          self.$elem.bind('touchend', function (e) {
            self.showHideWindow('hide');

            if (self.options.showLens) {
              self.showHideLens('hide');
            }

            if (self.options.tint && self.options.zoomType !== 'inner') {
              self.showHideTint('hide');
            }
          });

          if (self.options.showLens) {
            self.zoomLens.bind('touchmove', function (e) {
              e.preventDefault();
              var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
              self.setPosition(touch);
            });
            self.zoomLens.bind('touchend', function (e) {
              self.showHideWindow('hide');

              if (self.options.showLens) {
                self.showHideLens('hide');
              }

              if (self.options.tint && self.options.zoomType !== 'inner') {
                self.showHideTint('hide');
              }
            });
          }
        } //Needed to work in IE


        self.$elem.bind('mousemove', function (e) {
          if (self.overWindow === false) {
            self.setElements('show');
          } //make sure on orientation change the setposition is not fired


          if (self.lastX !== e.clientX || self.lastY !== e.clientY) {
            self.setPosition(e);
            self.currentLoc = e;
          }

          self.lastX = e.clientX;
          self.lastY = e.clientY;
        });
        self.zoomContainer.bind('click', self.options.onImageClick);
        self.zoomContainer.bind('mousemove', function (e) {
          if (self.overWindow === false) {
            self.setElements('show');
          }

          mouseMoveZoomHandler(e);
        });

        function mouseMoveZoomHandler(e) {
          //self.overWindow = true;
          //make sure on orientation change the setposition is not fired
          if (self.lastX !== e.clientX || self.lastY !== e.clientY) {
            self.setPosition(e);
            self.currentLoc = e;
          }

          self.lastX = e.clientX;
          self.lastY = e.clientY;
        }

        var elementToTrack = null;

        if (self.options.zoomType !== 'inner') {
          elementToTrack = self.zoomLens;
        }

        if (self.options.tint && self.options.zoomType !== 'inner') {
          elementToTrack = self.zoomTint;
        }

        if (self.options.zoomType === 'inner') {
          elementToTrack = self.zoomWindow;
        } //register the mouse tracking


        if (elementToTrack) {
          elementToTrack.bind('mousemove', mouseMoveZoomHandler);
        } //  lensFadeOut: 500,  zoomTintFadeIn


        self.zoomContainer.add(self.$elem).mouseenter(function () {
          if (self.overWindow === false) {
            self.setElements('show');
          }
        }).mouseleave(function () {
          if (!self.scrollLock) {
            self.setElements('hide');
            self.options.onDestroy(self.$elem);
          }
        }); //end ove image

        if (self.options.zoomType !== 'inner') {
          self.zoomWindow.mouseenter(function () {
            self.overWindow = true;
            self.setElements('hide');
          }).mouseleave(function () {
            self.overWindow = false;
          });
        } //end ove image
        // var delta = parseInt(e.originalEvent.wheelDelta || -e.originalEvent.detail);
        //      $(this).empty();
        //    return false;
        //fix for initial zoom setting
        //if (self.options.zoomLevel !== 1) {
        //    	self.changeZoomLevel(self.currentZoomLevel);
        //}
        //set the min zoomlevel


        if (self.options.minZoomLevel) {
          self.minZoomLevel = self.options.minZoomLevel;
        } else {
          self.minZoomLevel = self.options.scrollZoomIncrement * 2;
        }

        if (self.options.scrollZoom) {
          self.zoomContainer.add(self.$elem).bind('wheel DOMMouseScroll MozMousePixelScroll', function (e) {
            // in IE there is issue with firing of mouseleave - So check whether still scrolling
            // and on mouseleave check if scrolllock
            self.scrollLock = true;
            clearTimeout($.data(this, 'timer'));
            $.data(this, 'timer', setTimeout(function () {
              self.scrollLock = false; //do something
            }, 250));
            var theEvent = e.originalEvent.deltaY || e.originalEvent.detail * -1; //this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
            //   e.preventDefault();

            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();

            if (theEvent / 120 > 0) {
              //scrolling up
              if (self.currentZoomLevel >= self.minZoomLevel) {
                self.changeZoomLevel(self.currentZoomLevel - self.options.scrollZoomIncrement);
              }
            } else {
              //scrolling down
              //Check if it has to maintain original zoom window aspect ratio or not
              if (!self.fullheight && !self.fullwidth || !self.options.mantainZoomAspectRatio) {
                if (self.options.maxZoomLevel) {
                  if (self.currentZoomLevel <= self.options.maxZoomLevel) {
                    self.changeZoomLevel(parseFloat(self.currentZoomLevel) + self.options.scrollZoomIncrement);
                  }
                } else {
                  //andy
                  self.changeZoomLevel(parseFloat(self.currentZoomLevel) + self.options.scrollZoomIncrement);
                }
              }
            }

            return false;
          });
        }
      },
      setElements: function setElements(type) {
        var self = this;

        if (!self.options.zoomEnabled) {
          return false;
        }

        if (type === 'show') {
          if (self.isWindowSet) {
            if (self.options.zoomType === 'inner') {
              self.showHideWindow('show');
            }

            if (self.options.zoomType === 'window') {
              self.showHideWindow('show');
            }

            if (self.options.showLens) {
              self.showHideLens('show');
            }

            if (self.options.tint && self.options.zoomType !== 'inner') {
              self.showHideTint('show');
            }
          }
        }

        if (type === 'hide') {
          if (self.options.zoomType === 'window') {
            self.showHideWindow('hide');
          }

          if (!self.options.tint) {
            self.showHideWindow('hide');
          }

          if (self.options.showLens) {
            self.showHideLens('hide');
          }

          if (self.options.tint) {
            self.showHideTint('hide');
          }
        }
      },
      setPosition: function setPosition(e) {
        var self = this;

        if (!self.options.zoomEnabled) {
          return false;
        } //recaclc offset each time in case the image moves
        //this can be caused by other on page elements


        self.nzHeight = self.$elem.height();
        self.nzWidth = self.$elem.width();
        self.nzOffset = self.$elem.offset();

        if (self.options.tint && self.options.zoomType !== 'inner') {
          self.zoomTint.css({
            top: 0,
            left: 0
          });
        } //set responsive
        //will checking if the image needs changing before running this code work faster?


        if (self.options.responsive && !self.options.scrollZoom) {
          if (self.options.showLens) {
            var lensHeight, lensWidth;

            if (self.nzHeight < self.options.zoomWindowWidth / self.widthRatio) {
              lensHeight = self.nzHeight;
            } else {
              lensHeight = String(self.options.zoomWindowHeight / self.heightRatio);
            }

            if (self.largeWidth < self.options.zoomWindowWidth) {
              lensWidth = self.nzWidth;
            } else {
              lensWidth = self.options.zoomWindowWidth / self.widthRatio;
            }

            self.widthRatio = self.largeWidth / self.nzWidth;
            self.heightRatio = self.largeHeight / self.nzHeight;

            if (self.options.zoomType !== 'lens') {
              //possibly dont need to keep recalcalculating
              //if the lens is heigher than the image, then set lens size to image size
              if (self.nzHeight < self.options.zoomWindowWidth / self.widthRatio) {
                lensHeight = self.nzHeight;
              } else {
                lensHeight = String(self.options.zoomWindowHeight / self.heightRatio);
              }

              if (self.nzWidth < self.options.zoomWindowHeight / self.heightRatio) {
                lensWidth = self.nzWidth;
              } else {
                lensWidth = String(self.options.zoomWindowWidth / self.widthRatio);
              }

              self.zoomLens.css({
                'width': lensWidth,
                'height': lensHeight
              });

              if (self.options.tint) {
                self.zoomTintImage.css({
                  'width': self.nzWidth,
                  'height': self.nzHeight
                });
              }
            }

            if (self.options.zoomType === 'lens') {
              self.zoomLens.css({
                width: String(self.options.lensSize) + 'px',
                height: String(self.options.lensSize) + 'px'
              });
            } //end responsive image change

          }
        } //container fix


        self.zoomContainer.css({
          top: self.nzOffset.top,
          left: self.nzOffset.left
        });
        self.mouseLeft = parseInt(e.pageX - self.nzOffset.left);
        self.mouseTop = parseInt(e.pageY - self.nzOffset.top); //calculate the Location of the Lens
        //calculate the bound regions - but only if zoom window

        if (self.options.zoomType === 'window') {
          var zoomLensHeight = self.zoomLens.height() / 2;
          var zoomLensWidth = self.zoomLens.width() / 2;
          self.Etoppos = self.mouseTop < 0 + zoomLensHeight;
          self.Eboppos = self.mouseTop > self.nzHeight - zoomLensHeight - self.options.lensBorderSize * 2;
          self.Eloppos = self.mouseLeft < 0 + zoomLensWidth;
          self.Eroppos = self.mouseLeft > self.nzWidth - zoomLensWidth - self.options.lensBorderSize * 2;
        } //calculate the bound regions - but only for inner zoom


        if (self.options.zoomType === 'inner') {
          self.Etoppos = self.mouseTop < self.nzHeight / 2 / self.heightRatio;
          self.Eboppos = self.mouseTop > self.nzHeight - self.nzHeight / 2 / self.heightRatio;
          self.Eloppos = self.mouseLeft < 0 + self.nzWidth / 2 / self.widthRatio;
          self.Eroppos = self.mouseLeft > self.nzWidth - self.nzWidth / 2 / self.widthRatio - self.options.lensBorderSize * 2;
        } // if the mouse position of the slider is one of the outerbounds, then hide  window and lens


        if (self.mouseLeft < 0 || self.mouseTop < 0 || self.mouseLeft > self.nzWidth || self.mouseTop > self.nzHeight) {
          self.setElements('hide');
          return;
        } //else continue with operations
        else {
          //lens options
          if (self.options.showLens) {
            //		self.showHideLens('show');
            //set background position of lens
            self.lensLeftPos = String(Math.floor(self.mouseLeft - self.zoomLens.width() / 2));
            self.lensTopPos = String(Math.floor(self.mouseTop - self.zoomLens.height() / 2));
          } //adjust the background position if the mouse is in one of the outer regions
          //Top region


          if (self.Etoppos) {
            self.lensTopPos = 0;
          } //Left Region


          if (self.Eloppos) {
            self.windowLeftPos = 0;
            self.lensLeftPos = 0;
            self.tintpos = 0;
          } //Set bottom and right region for window mode


          if (self.options.zoomType === 'window') {
            if (self.Eboppos) {
              self.lensTopPos = Math.max(self.nzHeight - self.zoomLens.height() - self.options.lensBorderSize * 2, 0);
            }

            if (self.Eroppos) {
              self.lensLeftPos = self.nzWidth - self.zoomLens.width() - self.options.lensBorderSize * 2;
            }
          } //Set bottom and right region for inner mode


          if (self.options.zoomType === 'inner') {
            if (self.Eboppos) {
              self.lensTopPos = Math.max(self.nzHeight - self.options.lensBorderSize * 2, 0);
            }

            if (self.Eroppos) {
              self.lensLeftPos = self.nzWidth - self.nzWidth - self.options.lensBorderSize * 2;
            }
          } //if lens zoom


          if (self.options.zoomType === 'lens') {
            self.windowLeftPos = String(((e.pageX - self.nzOffset.left) * self.widthRatio - self.zoomLens.width() / 2) * -1);
            self.windowTopPos = String(((e.pageY - self.nzOffset.top) * self.heightRatio - self.zoomLens.height() / 2) * -1);
            self.zoomLens.css('background-position', self.windowLeftPos + 'px ' + self.windowTopPos + 'px');

            if (self.changeBgSize) {
              if (self.nzHeight > self.nzWidth) {
                if (self.options.zoomType === 'lens') {
                  self.zoomLens.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                }

                self.zoomWindow.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
              } else {
                if (self.options.zoomType === 'lens') {
                  self.zoomLens.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                }

                self.zoomWindow.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
              }

              self.changeBgSize = false;
            }

            self.setWindowPosition(e);
          } //if tint zoom


          if (self.options.tint && self.options.zoomType !== 'inner') {
            self.setTintPosition(e);
          } //set the css background position


          if (self.options.zoomType === 'window') {
            self.setWindowPosition(e);
          }

          if (self.options.zoomType === 'inner') {
            self.setWindowPosition(e);
          }

          if (self.options.showLens) {
            if (self.fullwidth && self.options.zoomType !== 'lens') {
              self.lensLeftPos = 0;
            }

            self.zoomLens.css({
              left: self.lensLeftPos + 'px',
              top: self.lensTopPos + 'px'
            });
          }
        } //end else

      },
      showHideZoomContainer: function showHideZoomContainer(change) {
        var self = this;

        if (change === 'show') {
          if (self.zoomContainer) {
            self.zoomContainer.show();
          }
        }

        if (change === 'hide') {
          if (self.zoomContainer) {
            self.zoomContainer.hide();
          }
        }
      },
      showHideWindow: function showHideWindow(change) {
        var self = this;

        if (change === 'show') {
          if (!self.isWindowActive && self.zoomWindow) {
            self.options.onShow(self);

            if (self.options.zoomWindowFadeIn) {
              self.zoomWindow.stop(true, true, false).fadeIn(self.options.zoomWindowFadeIn);
            } else {
              self.zoomWindow.show();
            }

            self.isWindowActive = true;
          }
        }

        if (change === 'hide') {
          if (self.isWindowActive) {
            if (self.options.zoomWindowFadeOut) {
              self.zoomWindow.stop(true, true).fadeOut(self.options.zoomWindowFadeOut, function () {
                if (self.loop) {
                  //stop moving the zoom window when zoom window is faded out
                  clearInterval(self.loop);
                  self.loop = false;
                }
              });
            } else {
              self.zoomWindow.hide();
            }

            self.isWindowActive = false;
          }
        }
      },
      showHideLens: function showHideLens(change) {
        var self = this;

        if (change === 'show') {
          if (!self.isLensActive) {
            if (self.options.lensFadeIn && self.zoomLens) {
              self.zoomLens.stop(true, true, false).fadeIn(self.options.lensFadeIn);
            } else {
              self.zoomLens.show();
            }

            self.isLensActive = true;
          }
        }

        if (change === 'hide') {
          if (self.isLensActive) {
            if (self.options.lensFadeOut) {
              self.zoomLens.stop(true, true).fadeOut(self.options.lensFadeOut);
            } else {
              self.zoomLens.hide();
            }

            self.isLensActive = false;
          }
        }
      },
      showHideTint: function showHideTint(change) {
        var self = this;

        if (change === 'show') {
          if (!self.isTintActive && self.zoomTint) {
            if (self.options.zoomTintFadeIn) {
              self.zoomTint.css('opacity', self.options.tintOpacity).animate().stop(true, true).fadeIn('slow');
            } else {
              self.zoomTint.css('opacity', self.options.tintOpacity).animate();
              self.zoomTint.show();
            }

            self.isTintActive = true;
          }
        }

        if (change === 'hide') {
          if (self.isTintActive) {
            if (self.options.zoomTintFadeOut) {
              self.zoomTint.stop(true, true).fadeOut(self.options.zoomTintFadeOut);
            } else {
              self.zoomTint.hide();
            }

            self.isTintActive = false;
          }
        }
      },
      setLensPosition: function setLensPosition(e) {},
      setWindowPosition: function setWindowPosition(e) {
        //return obj.slice( 0, count );
        var self = this;

        if (!isNaN(self.options.zoomWindowPosition)) {
          switch (self.options.zoomWindowPosition) {
            case 1:
              //done
              self.windowOffsetTop = self.options.zoomWindowOffsetY; //DONE - 1

              self.windowOffsetLeft = +self.nzWidth; //DONE 1, 2, 3, 4, 16

              break;

            case 2:
              if (self.options.zoomWindowHeight > self.nzHeight) {
                //positive margin
                self.windowOffsetTop = (self.options.zoomWindowHeight / 2 - self.nzHeight / 2) * -1;
                self.windowOffsetLeft = self.nzWidth; //DONE 1, 2, 3, 4, 16
              } else {
                //negative margin
                $.noop();
              }

              break;

            case 3:
              //done
              self.windowOffsetTop = self.nzHeight - self.zoomWindow.height() - self.options.borderSize * 2; //DONE 3,9

              self.windowOffsetLeft = self.nzWidth; //DONE 1, 2, 3, 4, 16

              break;

            case 4:
              //done
              self.windowOffsetTop = self.nzHeight; //DONE - 4,5,6,7,8

              self.windowOffsetLeft = self.nzWidth; //DONE 1, 2, 3, 4, 16

              break;

            case 5:
              //done
              self.windowOffsetTop = self.nzHeight; //DONE - 4,5,6,7,8

              self.windowOffsetLeft = self.nzWidth - self.zoomWindow.width() - self.options.borderSize * 2; //DONE - 5,15

              break;

            case 6:
              if (self.options.zoomWindowHeight > self.nzHeight) {
                //positive margin
                self.windowOffsetTop = self.nzHeight; //DONE - 4,5,6,7,8

                self.windowOffsetLeft = (self.options.zoomWindowWidth / 2 - self.nzWidth / 2 + self.options.borderSize * 2) * -1;
              } else {
                //negative margin
                $.noop();
              }

              break;

            case 7:
              //done
              self.windowOffsetTop = self.nzHeight; //DONE - 4,5,6,7,8

              self.windowOffsetLeft = 0; //DONE 7, 13

              break;

            case 8:
              //done
              self.windowOffsetTop = self.nzHeight; //DONE - 4,5,6,7,8

              self.windowOffsetLeft = (self.zoomWindow.width() + self.options.borderSize * 2) * -1; //DONE 8,9,10,11,12

              break;

            case 9:
              //done
              self.windowOffsetTop = self.nzHeight - self.zoomWindow.height() - self.options.borderSize * 2; //DONE 3,9

              self.windowOffsetLeft = (self.zoomWindow.width() + self.options.borderSize * 2) * -1; //DONE 8,9,10,11,12

              break;

            case 10:
              if (self.options.zoomWindowHeight > self.nzHeight) {
                //positive margin
                self.windowOffsetTop = (self.options.zoomWindowHeight / 2 - self.nzHeight / 2) * -1;
                self.windowOffsetLeft = (self.zoomWindow.width() + self.options.borderSize * 2) * -1; //DONE 8,9,10,11,12
              } else {
                //negative margin
                $.noop();
              }

              break;

            case 11:
              self.windowOffsetTop = self.options.zoomWindowOffsetY;
              self.windowOffsetLeft = (self.zoomWindow.width() + self.options.borderSize * 2) * -1; //DONE 8,9,10,11,12

              break;

            case 12:
              //done
              self.windowOffsetTop = (self.zoomWindow.height() + self.options.borderSize * 2) * -1; //DONE 12,13,14,15,16

              self.windowOffsetLeft = (self.zoomWindow.width() + self.options.borderSize * 2) * -1; //DONE 8,9,10,11,12

              break;

            case 13:
              //done
              self.windowOffsetTop = (self.zoomWindow.height() + self.options.borderSize * 2) * -1; //DONE 12,13,14,15,16

              self.windowOffsetLeft = 0; //DONE 7, 13

              break;

            case 14:
              if (self.options.zoomWindowHeight > self.nzHeight) {
                //positive margin
                self.windowOffsetTop = (self.zoomWindow.height() + self.options.borderSize * 2) * -1; //DONE 12,13,14,15,16

                self.windowOffsetLeft = (self.options.zoomWindowWidth / 2 - self.nzWidth / 2 + self.options.borderSize * 2) * -1;
              } else {
                //negative margin
                $.noop();
              }

              break;

            case 15:
              //done
              self.windowOffsetTop = (self.zoomWindow.height() + self.options.borderSize * 2) * -1; //DONE 12,13,14,15,16

              self.windowOffsetLeft = self.nzWidth - self.zoomWindow.width() - self.options.borderSize * 2; //DONE - 5,15

              break;

            case 16:
              //done
              self.windowOffsetTop = (self.zoomWindow.height() + self.options.borderSize * 2) * -1; //DONE 12,13,14,15,16

              self.windowOffsetLeft = self.nzWidth; //DONE 1, 2, 3, 4, 16

              break;

            default:
              //done
              self.windowOffsetTop = self.options.zoomWindowOffsetY; //DONE - 1

              self.windowOffsetLeft = self.nzWidth;
            //DONE 1, 2, 3, 4, 16
          }
        } //end isNAN
        else {
          //WE CAN POSITION IN A CLASS - ASSUME THAT ANY STRING PASSED IS
          self.externalContainer = $('#' + self.options.zoomWindowPosition);
          self.externalContainerWidth = self.externalContainer.width();
          self.externalContainerHeight = self.externalContainer.height();
          self.externalContainerOffset = self.externalContainer.offset();
          self.windowOffsetTop = self.externalContainerOffset.top; //DONE - 1

          self.windowOffsetLeft = self.externalContainerOffset.left; //DONE 1, 2, 3, 4, 16
        }

        self.isWindowSet = true;
        self.windowOffsetTop = self.windowOffsetTop + self.options.zoomWindowOffsetY;
        self.windowOffsetLeft = self.windowOffsetLeft + self.options.zoomWindowOffsetX;
        self.zoomWindow.css({
          top: self.windowOffsetTop,
          left: self.windowOffsetLeft
        });

        if (self.options.zoomType === 'inner') {
          self.zoomWindow.css({
            top: 0,
            left: 0
          });
        }

        self.windowLeftPos = String(((e.pageX - self.nzOffset.left) * self.widthRatio - self.zoomWindow.width() / 2) * -1);
        self.windowTopPos = String(((e.pageY - self.nzOffset.top) * self.heightRatio - self.zoomWindow.height() / 2) * -1);

        if (self.Etoppos) {
          self.windowTopPos = 0;
        }

        if (self.Eloppos) {
          self.windowLeftPos = 0;
        }

        if (self.Eboppos) {
          self.windowTopPos = (self.largeHeight / self.currentZoomLevel - self.zoomWindow.height()) * -1;
        }

        if (self.Eroppos) {
          self.windowLeftPos = (self.largeWidth / self.currentZoomLevel - self.zoomWindow.width()) * -1;
        } //stops micro movements


        if (self.fullheight) {
          self.windowTopPos = 0;
        }

        if (self.fullwidth) {
          self.windowLeftPos = 0;
        } //set the css background position


        if (self.options.zoomType === 'window' || self.options.zoomType === 'inner') {
          if (self.zoomLock === 1) {
            //overrides for images not zoomable
            if (self.widthRatio <= 1) {
              self.windowLeftPos = 0;
            }

            if (self.heightRatio <= 1) {
              self.windowTopPos = 0;
            }
          } // adjust images less than the window height


          if (self.options.zoomType === 'window') {
            if (self.largeHeight < self.options.zoomWindowHeight) {
              self.windowTopPos = 0;
            }

            if (self.largeWidth < self.options.zoomWindowWidth) {
              self.windowLeftPos = 0;
            }
          } //set the zoomwindow background position


          if (self.options.easing) {
            //     if(self.changeZoom){
            //           clearInterval(self.loop);
            //           self.changeZoom = false;
            //           self.loop = false;
            //            }
            //set the pos to 0 if not set
            if (!self.xp) {
              self.xp = 0;
            }

            if (!self.yp) {
              self.yp = 0;
            } //if loop not already started, then run it


            if (!self.loop) {
              self.loop = setInterval(function () {
                //using zeno's paradox
                self.xp += (self.windowLeftPos - self.xp) / self.options.easingAmount;
                self.yp += (self.windowTopPos - self.yp) / self.options.easingAmount;

                if (self.scrollingLock) {
                  clearInterval(self.loop);
                  self.xp = self.windowLeftPos;
                  self.yp = self.windowTopPos;
                  self.xp = ((e.pageX - self.nzOffset.left) * self.widthRatio - self.zoomWindow.width() / 2) * -1;
                  self.yp = ((e.pageY - self.nzOffset.top) * self.heightRatio - self.zoomWindow.height() / 2) * -1;

                  if (self.changeBgSize) {
                    if (self.nzHeight > self.nzWidth) {
                      if (self.options.zoomType === 'lens') {
                        self.zoomLens.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                      }

                      self.zoomWindow.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                    } else {
                      if (self.options.zoomType !== 'lens') {
                        self.zoomLens.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                      }

                      self.zoomWindow.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                    }
                    /*
                     if(!self.bgxp){self.bgxp = self.largeWidth/self.newvalue;}
                     if(!self.bgyp){self.bgyp = self.largeHeight/self.newvalue ;}
                     if (!self.bgloop){
                     self.bgloop = setInterval(function(){
                          self.bgxp += (self.largeWidth/self.newvalue  - self.bgxp) / self.options.easingAmount;
                     self.bgyp += (self.largeHeight/self.newvalue  - self.bgyp) / self.options.easingAmount;
                          self.zoomWindow.css('background-size', self.bgxp + 'px ' + self.bgyp + 'px' );
                               }, 16);
                          }
                     */


                    self.changeBgSize = false;
                  }

                  self.zoomWindow.css('background-position', self.windowLeftPos + 'px ' + self.windowTopPos + 'px');
                  self.scrollingLock = false;
                  self.loop = false;
                } else if (Math.round(Math.abs(self.xp - self.windowLeftPos) + Math.abs(self.yp - self.windowTopPos)) < 1) {
                  //stops micro movements
                  clearInterval(self.loop);
                  self.zoomWindow.css('background-position', self.windowLeftPos + 'px ' + self.windowTopPos + 'px');
                  self.loop = false;
                } else {
                  if (self.changeBgSize) {
                    if (self.nzHeight > self.nzWidth) {
                      if (self.options.zoomType === 'lens') {
                        self.zoomLens.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                      }

                      self.zoomWindow.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                    } else {
                      if (self.options.zoomType !== 'lens') {
                        self.zoomLens.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                      }

                      self.zoomWindow.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                    }

                    self.changeBgSize = false;
                  }

                  self.zoomWindow.css('background-position', self.xp + 'px ' + self.yp + 'px');
                }
              }, 16);
            }
          } else {
            if (self.changeBgSize) {
              if (self.nzHeight > self.nzWidth) {
                if (self.options.zoomType === 'lens') {
                  self.zoomLens.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                }

                self.zoomWindow.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
              } else {
                if (self.options.zoomType === 'lens') {
                  self.zoomLens.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                }

                if (self.largeHeight / self.newvaluewidth < self.options.zoomWindowHeight) {
                  self.zoomWindow.css('background-size', self.largeWidth / self.newvaluewidth + 'px ' + self.largeHeight / self.newvaluewidth + 'px');
                } else {
                  self.zoomWindow.css('background-size', self.largeWidth / self.newvalueheight + 'px ' + self.largeHeight / self.newvalueheight + 'px');
                }
              }

              self.changeBgSize = false;
            }

            self.zoomWindow.css('background-position', self.windowLeftPos + 'px ' + self.windowTopPos + 'px');
          }
        }
      },
      setTintPosition: function setTintPosition(e) {
        var self = this;
        var zoomLensWidth = self.zoomLens.width();
        var zoomLensHeight = self.zoomLens.height();
        self.nzOffset = self.$elem.offset();
        self.tintpos = String((e.pageX - self.nzOffset.left - zoomLensWidth / 2) * -1);
        self.tintposy = String((e.pageY - self.nzOffset.top - zoomLensHeight / 2) * -1);

        if (self.Etoppos) {
          self.tintposy = 0;
        }

        if (self.Eloppos) {
          self.tintpos = 0;
        }

        if (self.Eboppos) {
          self.tintposy = (self.nzHeight - zoomLensHeight - self.options.lensBorderSize * 2) * -1;
        }

        if (self.Eroppos) {
          self.tintpos = (self.nzWidth - zoomLensWidth - self.options.lensBorderSize * 2) * -1;
        }

        if (self.options.tint) {
          //stops micro movements
          if (self.fullheight) {
            self.tintposy = 0;
          }

          if (self.fullwidth) {
            self.tintpos = 0;
          }

          self.zoomTintImage.css({
            'left': self.tintpos + 'px',
            'top': self.tintposy + 'px'
          });
        }
      },
      swaptheimage: function swaptheimage(smallimage, largeimage) {
        var self = this;
        var newImg = new Image();

        if (self.options.loadingIcon) {
          self.spinner = $('<div style="' + 'background: url(\'' + self.options.loadingIcon + '\') no-repeat center;' + 'height:' + self.nzHeight + 'px;' + 'width:' + self.nzWidth + 'px;' + 'z-index: 2000;position: absolute; ' + 'background-position: center center;"></div>');
          self.$elem.after(self.spinner);
        }

        self.options.onImageSwap(self.$elem);

        newImg.onload = function () {
          self.largeWidth = newImg.width;
          self.largeHeight = newImg.height;
          self.zoomImage = largeimage;
          self.zoomWindow.css('background-size', self.largeWidth + 'px ' + self.largeHeight + 'px');
          self.swapAction(smallimage, largeimage);
          return;
        };

        self.setImageSource(newImg, largeimage); // this must be done AFTER setting onload
      },
      swapAction: function swapAction(smallimage, largeimage) {
        var self = this;
        var elemWidth = self.$elem.width();
        var elemHeight = self.$elem.height();
        var newImg2 = new Image();

        newImg2.onload = function () {
          //re-calculate values
          self.nzHeight = newImg2.height;
          self.nzWidth = newImg2.width;
          self.options.onImageSwapComplete(self.$elem);
          self.doneCallback();
          return;
        };

        self.setImageSource(newImg2, smallimage); //reset the zoomlevel to that initially set in options

        self.currentZoomLevel = self.options.zoomLevel;
        self.options.maxZoomLevel = false; //swaps the main image
        //self.$elem.attr('src',smallimage);
        //swaps the zoom image

        if (self.options.zoomType === 'lens') {
          self.zoomLens.css('background-image', 'url("' + largeimage + '")');
        }

        if (self.options.zoomType === 'window') {
          self.zoomWindow.css('background-image', 'url("' + largeimage + '")');
        }

        if (self.options.zoomType === 'inner') {
          self.zoomWindow.css('background-image', 'url("' + largeimage + '")');
        }

        self.currentImage = largeimage;

        if (self.options.imageCrossfade) {
          var oldImg = self.$elem;
          var newImg = oldImg.clone();
          self.$elem.attr('src', smallimage);
          self.$elem.after(newImg);
          newImg.stop(true).fadeOut(self.options.imageCrossfade, function () {
            $(this).remove();
          }); // if(self.options.zoomType === 'inner'){
          //remove any attributes on the cloned image so we can resize later

          self.$elem.width('auto').removeAttr('width');
          self.$elem.height('auto').removeAttr('height'); //   }

          oldImg.fadeIn(self.options.imageCrossfade);

          if (self.options.tint && self.options.zoomType !== 'inner') {
            var oldImgTint = self.zoomTintImage;
            var newImgTint = oldImgTint.clone();
            self.zoomTintImage.attr('src', largeimage);
            self.zoomTintImage.after(newImgTint);
            newImgTint.stop(true).fadeOut(self.options.imageCrossfade, function () {
              $(this).remove();
            });
            oldImgTint.fadeIn(self.options.imageCrossfade); //self.zoomTintImage.attr('width',elem.data('image'));
            //resize the tint window

            self.zoomTint.css({
              height: elemHeight,
              width: elemWidth
            });
          }

          self.zoomContainer.css({
            'height': elemHeight,
            'width': elemWidth
          });

          if (self.options.zoomType === 'inner') {
            if (!self.options.constrainType) {
              self.zoomWrap.parent().css({
                'height': elemHeight,
                'width': elemWidth
              });
              self.zoomWindow.css({
                'height': elemHeight,
                'width': elemWidth
              });
            }
          }

          if (self.options.imageCrossfade) {
            self.zoomWrap.css({
              'height': elemHeight,
              'width': elemWidth
            });
          }
        } else {
          self.$elem.attr('src', smallimage);

          if (self.options.tint) {
            self.zoomTintImage.attr('src', largeimage); //self.zoomTintImage.attr('width',elem.data('image'));

            self.zoomTintImage.attr('height', elemHeight); //self.zoomTintImage.attr('src') = elem.data('image');

            self.zoomTintImage.css('height', elemHeight);
            self.zoomTint.css('height', elemHeight);
          }

          self.zoomContainer.css({
            'height': elemHeight,
            'width': elemWidth
          });

          if (self.options.imageCrossfade) {
            self.zoomWrap.css({
              'height': elemHeight,
              'width': elemWidth
            });
          }
        }

        if (self.options.constrainType) {
          //This will contrain the image proportions
          if (self.options.constrainType === 'height') {
            var autoWDimension = {
              'height': self.options.constrainSize,
              'width': 'auto'
            };
            self.zoomContainer.css(autoWDimension);

            if (self.options.imageCrossfade) {
              self.zoomWrap.css(autoWDimension);
              self.constwidth = self.zoomWrap.width();
            } else {
              self.$elem.css(autoWDimension);
              self.constwidth = elemWidth;
            }

            var constWDim = {
              'height': self.options.constrainSize,
              'width': self.constwidth
            };

            if (self.options.zoomType === 'inner') {
              self.zoomWrap.parent().css(constWDim);
              self.zoomWindow.css(constWDim);
            }

            if (self.options.tint) {
              self.tintContainer.css(constWDim);
              self.zoomTint.css(constWDim);
              self.zoomTintImage.css(constWDim);
            }
          }

          if (self.options.constrainType === 'width') {
            var autoHDimension = {
              'height': 'auto',
              'width': self.options.constrainSize
            };
            self.zoomContainer.css(autoHDimension);

            if (self.options.imageCrossfade) {
              self.zoomWrap.css(autoHDimension);
              self.constheight = self.zoomWrap.height();
            } else {
              self.$elem.css(autoHDimension);
              self.constheight = elemHeight;
            }

            var constHDim = {
              'height': self.constheight,
              'width': self.options.constrainSize
            };

            if (self.options.zoomType === 'inner') {
              self.zoomWrap.parent().css(constHDim);
              self.zoomWindow.css(constHDim);
            }

            if (self.options.tint) {
              self.tintContainer.css(constHDim);
              self.zoomTint.css(constHDim);
              self.zoomTintImage.css(constHDim);
            }
          }
        }
      },
      doneCallback: function doneCallback() {
        var self = this;

        if (self.options.loadingIcon) {
          self.spinner.hide();
        }

        self.nzOffset = self.$elem.offset();
        self.nzWidth = self.$elem.width();
        self.nzHeight = self.$elem.height(); // reset the zoomlevel back to default

        self.currentZoomLevel = self.options.zoomLevel; //ratio of the large to small image

        self.widthRatio = self.largeWidth / self.nzWidth;
        self.heightRatio = self.largeHeight / self.nzHeight; //NEED TO ADD THE LENS SIZE FOR ROUND
        // adjust images less than the window height

        if (self.options.zoomType === 'window') {
          var lensHeight, lensWidth;

          if (self.nzHeight < self.options.zoomWindowHeight / self.heightRatio) {
            lensHeight = self.nzHeight;
          } else {
            lensHeight = String(self.options.zoomWindowHeight / self.heightRatio);
          }

          if (self.nzWidth < self.options.zoomWindowWidth) {
            lensWidth = self.nzWidth;
          } else {
            lensWidth = self.options.zoomWindowWidth / self.widthRatio;
          }

          if (self.zoomLens) {
            self.zoomLens.css({
              'width': lensWidth,
              'height': lensHeight
            });
          }
        }
      },
      getCurrentImage: function getCurrentImage() {
        var self = this;
        return self.zoomImage;
      },
      getGalleryList: function getGalleryList() {
        var self = this; //loop through the gallery options and set them in list for fancybox

        self.gallerylist = [];

        if (self.options.gallery) {
          $('#' + self.options.gallery + ' a').each(function () {
            var imgSrc = '';

            if ($(this).data('zoom-image')) {
              imgSrc = $(this).data('zoom-image');
            } else if ($(this).data('image')) {
              imgSrc = $(this).data('image');
            } //put the current image at the start


            if (imgSrc === self.zoomImage) {
              self.gallerylist.unshift({
                href: '' + imgSrc + '',
                title: $(this).find('img').attr('title')
              });
            } else {
              self.gallerylist.push({
                href: '' + imgSrc + '',
                title: $(this).find('img').attr('title')
              });
            }
          });
        } //if no gallery - return current image
        else {
          self.gallerylist.push({
            href: '' + self.zoomImage + '',
            title: $(this).find('img').attr('title')
          });
        }

        return self.gallerylist;
      },
      changeZoomLevel: function changeZoomLevel(value) {
        var self = this; //flag a zoom, so can adjust the easing during setPosition

        self.scrollingLock = true; //round to two decimal places

        self.newvalue = parseFloat(value).toFixed(2);
        var newvalue = self.newvalue; //maxwidth & Maxheight of the image

        var maxheightnewvalue = self.largeHeight / (self.options.zoomWindowHeight / self.nzHeight * self.nzHeight);
        var maxwidthtnewvalue = self.largeWidth / (self.options.zoomWindowWidth / self.nzWidth * self.nzWidth); //calculate new heightratio

        if (self.options.zoomType !== 'inner') {
          if (maxheightnewvalue <= newvalue) {
            self.heightRatio = self.largeHeight / maxheightnewvalue / self.nzHeight;
            self.newvalueheight = maxheightnewvalue;
            self.fullheight = true;
          } else {
            self.heightRatio = self.largeHeight / newvalue / self.nzHeight;
            self.newvalueheight = newvalue;
            self.fullheight = false;
          } // calculate new width ratio


          if (maxwidthtnewvalue <= newvalue) {
            self.widthRatio = self.largeWidth / maxwidthtnewvalue / self.nzWidth;
            self.newvaluewidth = maxwidthtnewvalue;
            self.fullwidth = true;
          } else {
            self.widthRatio = self.largeWidth / newvalue / self.nzWidth;
            self.newvaluewidth = newvalue;
            self.fullwidth = false;
          }

          if (self.options.zoomType === 'lens') {
            if (maxheightnewvalue <= newvalue) {
              self.fullwidth = true;
              self.newvaluewidth = maxheightnewvalue;
            } else {
              self.widthRatio = self.largeWidth / newvalue / self.nzWidth;
              self.newvaluewidth = newvalue;
              self.fullwidth = false;
            }
          }
        }

        if (self.options.zoomType === 'inner') {
          maxheightnewvalue = parseFloat(self.largeHeight / self.nzHeight).toFixed(2);
          maxwidthtnewvalue = parseFloat(self.largeWidth / self.nzWidth).toFixed(2);

          if (newvalue > maxheightnewvalue) {
            newvalue = maxheightnewvalue;
          }

          if (newvalue > maxwidthtnewvalue) {
            newvalue = maxwidthtnewvalue;
          }

          if (maxheightnewvalue <= newvalue) {
            self.heightRatio = self.largeHeight / newvalue / self.nzHeight;

            if (newvalue > maxheightnewvalue) {
              self.newvalueheight = maxheightnewvalue;
            } else {
              self.newvalueheight = newvalue;
            }

            self.fullheight = true;
          } else {
            self.heightRatio = self.largeHeight / newvalue / self.nzHeight;

            if (newvalue > maxheightnewvalue) {
              self.newvalueheight = maxheightnewvalue;
            } else {
              self.newvalueheight = newvalue;
            }

            self.fullheight = false;
          }

          if (maxwidthtnewvalue <= newvalue) {
            self.widthRatio = self.largeWidth / newvalue / self.nzWidth;

            if (newvalue > maxwidthtnewvalue) {
              self.newvaluewidth = maxwidthtnewvalue;
            } else {
              self.newvaluewidth = newvalue;
            }

            self.fullwidth = true;
          } else {
            self.widthRatio = self.largeWidth / newvalue / self.nzWidth;
            self.newvaluewidth = newvalue;
            self.fullwidth = false;
          }
        } //end inner


        var scrcontinue = false;

        if (self.options.zoomType === 'inner') {
          if (self.nzWidth >= self.nzHeight) {
            if (self.newvaluewidth <= maxwidthtnewvalue) {
              scrcontinue = true;
            } else {
              scrcontinue = false;
              self.fullheight = true;
              self.fullwidth = true;
            }
          }

          if (self.nzHeight > self.nzWidth) {
            if (self.newvaluewidth <= maxwidthtnewvalue) {
              scrcontinue = true;
            } else {
              scrcontinue = false;
              self.fullheight = true;
              self.fullwidth = true;
            }
          }
        }

        if (self.options.zoomType !== 'inner') {
          scrcontinue = true;
        }

        if (scrcontinue) {
          self.zoomLock = 0;
          self.changeZoom = true; //if lens height is less than image height

          if (self.options.zoomWindowHeight / self.heightRatio <= self.nzHeight) {
            self.currentZoomLevel = self.newvalueheight;

            if (self.options.zoomType !== 'lens' && self.options.zoomType !== 'inner') {
              self.changeBgSize = true;
              self.zoomLens.css('height', String(self.options.zoomWindowHeight / self.heightRatio) + 'px');
            }

            if (self.options.zoomType === 'lens' || self.options.zoomType === 'inner') {
              self.changeBgSize = true;
            }
          }

          if (self.options.zoomWindowWidth / self.widthRatio <= self.nzWidth) {
            if (self.options.zoomType !== 'inner') {
              if (self.newvaluewidth > self.newvalueheight) {
                self.currentZoomLevel = self.newvaluewidth;
              }
            }

            if (self.options.zoomType !== 'lens' && self.options.zoomType !== 'inner') {
              self.changeBgSize = true;
              self.zoomLens.css('width', String(self.options.zoomWindowWidth / self.widthRatio) + 'px');
            }

            if (self.options.zoomType === 'lens' || self.options.zoomType === 'inner') {
              self.changeBgSize = true;
            }
          }

          if (self.options.zoomType === 'inner') {
            self.changeBgSize = true;

            if (self.nzWidth > self.nzHeight) {
              self.currentZoomLevel = self.newvaluewidth;
            }

            if (self.nzHeight > self.nzWidth) {
              self.currentZoomLevel = self.newvaluewidth;
            }
          }
        } //under
        //sets the boundry change, called in setWindowPos


        self.setPosition(self.currentLoc); //
      },
      closeAll: function closeAll() {
        var self = this;

        if (self.zoomWindow) {
          self.zoomWindow.hide();
        }

        if (self.zoomLens) {
          self.zoomLens.hide();
        }

        if (self.zoomTint) {
          self.zoomTint.hide();
        }
      },
      changeState: function changeState(value) {
        var self = this;

        if (value === 'enable') {
          self.options.zoomEnabled = true;
        }

        if (value === 'disable') {
          self.options.zoomEnabled = false;
        }
      },
      responsiveConfig: function responsiveConfig(options) {
        if (options.respond && options.respond.length > 0) {
          return $.extend({}, options, this.configByScreenWidth(options));
        }

        return options;
      },
      configByScreenWidth: function configByScreenWidth(options) {
        var screenWidth = $(window).width();
        var config = $.grep(options.respond, function (item) {
          var range = item.range.split('-');
          return screenWidth >= range[0] && screenWidth <= range[1];
        });

        if (config.length > 0) {
          return config[0];
        } else {
          return options;
        }
      }
    };

    $.fn.ezPlus = function (options) {
      return this.each(function () {
        var elevate = Object.create(EZP);
        elevate.init(options, this);
        $.data(this, 'ezPlus', elevate);
      });
    };

    $.fn.ezPlus.options = {
      borderColour: '#888',
      borderSize: 4,
      constrainSize: false,
      //in pixels the dimensions you want to constrain on
      constrainType: false,
      //width or height
      containLensZoom: false,
      cursor: 'inherit',
      // user should set to what they want the cursor as, if they have set a click function
      debug: false,
      easing: false,
      easingAmount: 12,
      enabled: true,
      gallery: false,
      galleryActiveClass: 'zoomGalleryActive',
      gallerySelector: false,
      galleryItem: 'a',
      imageCrossfade: false,
      lensBorderColour: '#000',
      lensBorderSize: 1,
      lensColour: 'white',
      //colour of the lens background
      lensFadeIn: false,
      lensFadeOut: false,
      lensOpacity: 0.4,
      //opacity of the lens
      lensShape: 'square',
      //can be 'round'
      lensSize: 200,
      lenszoom: false,
      loadingIcon: false,
      //http://www.example.com/spinner.gif
      // This change will allow to decide if you want to decrease
      // zoom of one of the dimensions once the other reached it's top value,
      // or keep the aspect ratio, default behaviour still being as always,
      // allow to continue zooming out, so it keeps retrocompatibility.
      mantainZoomAspectRatio: false,
      maxZoomLevel: false,
      minZoomLevel: false,
      onComplete: $.noop,
      onDestroy: $.noop,
      onImageClick: $.noop,
      onImageSwap: $.noop,
      onImageSwapComplete: $.noop,
      onShow: $.noop,
      onZoomedImageLoaded: $.noop,
      preloading: 1,
      //by default, load all the images, if 0, then only load images after activated (PLACEHOLDER FOR NEXT VERSION)
      respond: [],
      responsive: true,
      scrollZoom: false,
      //allow zoom on mousewheel, true to activate
      scrollZoomIncrement: 0.1,
      //steps of the scrollzoom
      showLens: true,
      tint: false,
      //enable the tinting
      tintColour: '#333',
      //default tint color, can be anything, red, #ccc, rgb(0,0,0)
      tintOpacity: 0.4,
      //opacity of the tint
      touchEnabled: true,
      zoomActivation: 'hover',
      // Can also be click (PLACEHOLDER FOR NEXT VERSION)
      zoomContainerAppendTo: 'body',
      //zoom container parent selector
      zoomLevel: 1,
      //default zoom level of image
      zoomTintFadeIn: false,
      zoomTintFadeOut: false,
      zoomType: 'window',
      //window is default,  also 'lens' available -
      zoomWindowAlwaysShow: false,
      zoomWindowBgColour: '#fff',
      zoomWindowFadeIn: false,
      zoomWindowFadeOut: false,
      zoomWindowHeight: 400,
      zoomWindowOffsetX: 0,
      zoomWindowOffsetY: 0,
      zoomWindowPosition: 1,
      zoomWindowWidth: 400,
      zoomEnabled: true,
      //false disables zoomwindow from showing
      zIndex: 999
    };
  })(jQuery, window, document);
}

module.exports = {
  productMediaZoom: productMediaZoom
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/zoom.js":
/*!*************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/thirdParty/zoom.js ***!
  \*************************************************************************************/
/***/ (function(module) {

"use strict";

/* https://github.com/ironexdev/zoom
    Customized for Michael Kors to allow mobile scrolling
    and to disable Slick Slider when zoomed in
*/

/* Example call
  zoom({
    active: 'zoom-active',
    transition: 'zoom-transition',
    visible: 'visible',
    zoom: 'zoom' // Image container class
  }, {
    scaleDefault: 2, // Used on doubleclick, doubletap and resize
    scaleDifference: 0.5, // Used on wheel zoom
    scaleMax: 10, // Maximum zoom
    scaleMin: 1, // Minimum zoom
    scrollDisable: true,
    transitionDuration: 200, // This should correspond with zoom-transition transition duration
    doubleclickDelay: 300 // Delay between clicks - used when scripts decides if user performed doubleclick or not
  }, (function ($container, zoomed) {
    console.log(zoomed);
  }));
*/

function zoom(classNames, settings, callback) {
  /* Settings */
  classNames = typeof classNames !== 'undefined' && Object.keys(classNames).length ? classNames : {};
  settings = typeof settings !== 'undefined' && Object.keys(settings).length ? settings : {};
  var SCALE_DEFAULT = settings['scaleDefault'] || 2; // Used on doubleclick, doubletap and resize

  var SCALE_MAX = settings['scaleMax'] || 10;
  var SCALE_MIN = settings['scaleMin'] || 1;
  var TRANSITION_DURATION = settings['transitionDuration'] || 200; // This should correspond with zoom-transition transition duration

  var DOUBLECLICK_DELAY = settings['doubleclickDelay'] || 300;
  /* Safari on iOS doesn't properly scale images using 3d transforms */

  var SUPPORT_3D_TRANSFORM = !iOSSafari();
  /* Selectors */

  var _active = classNames['active'] || 'zoom-active';

  var _dataScale = 'data-scale';
  var _dataTranslateX = 'data-translate-x';
  var _dataTranslateY = 'data-translate-y';

  var _transition = classNames['transition'] || 'zoom-transition';

  var _visible = classNames['visible'] || 'zoom-visible';

  var _zoom = classNames['zoom'] || 'zoom';

  var $container;
  var $element;
  var $zoom = document.getElementsByClassName(_zoom);
  var lastTouchStart = null;
  var lastClickTime = null;
  /* Helpers */

  var capture = false;
  var containerHeight;
  var containerWidth;
  var containerOffsetX;
  var containerOffsetY;
  var initialScale;
  var elementHeight;
  var elementWidth;
  var initialOffsetX;
  var initialOffsetY;
  var initialPinchDistance;
  var initialPointerOffsetX;
  var initialPointerOffsetX2;
  var initialPointerOffsetY;
  var initialPointerOffsetY2;
  var limitOffsetX;
  var limitOffsetY;
  var offset;
  var pinchOffsetX;
  var pinchOffsetY;
  var pointerOffsetX;
  var pointerOffsetX2;
  var pointerOffsetY;
  var pointerOffsetY2;
  var scaleDirection;
  var scaleDifference;
  var targetOffsetX;
  var targetOffsetY;
  var targetPinchDistance;
  var targetScale;
  var touchCount;
  var touchmoveCount = 0;
  var doubleTapMonitor = [null];
  var slickCarousel = settings['slickCarousel'] || '';
  var clickCount = 0;
  var isMobile = settings['isMobile'] || false;
  var hideThumbnail = settings['hideThumbnail'] || false;

  for (var i = 0; i < $zoom.length; i++) {
    /* Initialize selectors */
    $container = $zoom[i];
    $element = $container.children[0];
    /* Set attributes */

    $element.setAttribute(_dataScale, 1);
    $element.setAttribute(_dataTranslateX, 0);
    $element.setAttribute(_dataTranslateY, 0);
  }

  window.addEventListener('load', function () {
    /* Wait for images to be loaded */
    for (var i = 0; i < $zoom.length; i++) {
      /* Initialize selectors */
      $container = $zoom[i];
      $element = $container.children[0];
      addClass($element, _visible);
    }
  });
  massAddEventListener($zoom, 'touchstart', touchStart);
  massAddEventListener($zoom, 'click', onClick);
  document.addEventListener('touchmove', touchMove, {
    passive: false
  }); // Google Chrome - [Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive.

  document.addEventListener('touchend', touchEnd);

  function onClick(e) {
    if (clickCount > 0) {
      return;
    }

    clickCount++;
    resetClickCount();
    /* Initialize helpers */

    offset = $container.getBoundingClientRect();
    containerOffsetX = offset.left;
    containerOffsetY = offset.top;
    containerHeight = $container.clientHeight;
    containerWidth = $container.clientWidth;
    elementHeight = $element.clientHeight;
    elementWidth = $element.clientWidth;
    initialPointerOffsetX = e.clientX;
    initialPointerOffsetY = e.clientY;
    initialScale = minMax(parseFloat($element.getAttribute(_dataScale)), SCALE_MIN, SCALE_MAX);
    doubleTapMonitor[0] = e.target;
    doubleTapMonitor[1] = initialPointerOffsetX;
    doubleTapMonitor[2] = initialPointerOffsetY;
    addClass($element, _transition);
    var time = new Date().getTime();

    if (lastClickTime && time - lastClickTime < DOUBLECLICK_DELAY) {
      lastClickTime = time;
      return false;
    }

    lastClickTime = time;

    if (hasClass($container, _active) === true) {
      /* Set attributes */
      $element.setAttribute(_dataScale, 1);
      $element.setAttribute(_dataTranslateX, 0);
      $element.setAttribute(_dataTranslateY, 0);
      zoomInactive($container);
      moveScaleElement($element, 0, 0, 1);
    } else {
      pointerOffsetX = e.clientX;
      pointerOffsetY = e.clientY;
      targetScale = SCALE_DEFAULT;
      scaleDirection = 1;
      scaleDifference = (SCALE_DEFAULT - 1) * scaleDirection;
      /* Set offset limits */

      limitOffsetX = getLimitOffset(elementWidth, containerWidth, targetScale);
      limitOffsetY = getLimitOffset(elementHeight, containerHeight, targetScale);

      if (targetScale <= 1) {
        targetOffsetX = 0;
        targetOffsetY = 0;
      } else {
        /* Set target offsets */
        targetOffsetX = elementWidth * targetScale <= containerWidth ? 0 : minMax(initialOffsetX - (pointerOffsetX - containerOffsetX - containerWidth / 2 - initialOffsetX) / (targetScale - scaleDifference) * scaleDifference, limitOffsetX * -1, limitOffsetX);
        targetOffsetY = elementHeight * targetScale <= containerHeight ? 0 : minMax(initialOffsetY - (pointerOffsetY - containerOffsetY - containerHeight / 2 - initialOffsetY) / (targetScale - scaleDifference) * scaleDifference, limitOffsetY * -1, limitOffsetY);
      }

      zoomActive($container);
      /* Set attributes */

      $element.setAttribute(_dataScale, targetScale);
      $element.setAttribute(_dataTranslateX, targetOffsetX);
      $element.setAttribute(_dataTranslateY, targetOffsetY);
      moveScaleElement($element, targetOffsetX + 'px', targetOffsetY + 'px', SCALE_DEFAULT);
    }

    setTimeout(function () {
      removeClass($element, _transition);
    }, TRANSITION_DURATION);
    /* Initialize helpers */

    initialOffsetX = parseFloat($element.getAttribute(_dataTranslateX));
    initialOffsetY = parseFloat($element.getAttribute(_dataTranslateY));
  }

  function touchStart(e) {
    touchCount = e.touches.length;
    var time = new Date().getTime();

    if (touchCount > 2) {
      return false;
    }

    if (touchCount > 1) {
      lastTouchStart = null;
    }

    if (time - lastTouchStart < DOUBLECLICK_DELAY) {
      doubleClicked = false;
    }

    if (clickCount > 0) {
      return;
    }
    /* Initialize selectors */


    $container = this;
    $element = this.children[0];
    /* Initialize helpers */

    offset = $container.getBoundingClientRect();
    containerOffsetX = offset.left;
    containerOffsetY = offset.top;
    containerHeight = $container.clientHeight;
    containerWidth = $container.clientWidth;
    elementHeight = $element.clientHeight;
    elementWidth = $element.clientWidth;
    initialPointerOffsetX = e.touches[0].clientX;
    initialPointerOffsetY = e.touches[0].clientY;
    initialScale = minMax(parseFloat($element.getAttribute(_dataScale)), SCALE_MIN, SCALE_MAX);

    if (touchCount === 1)
      /* Single touch */
      {
        preventSlide(offset, initialPointerOffsetX);
        /* Doubletap */

        if (doubleTapMonitor[0] === null) {
          doubleTapMonitor[0] = e.target;
          doubleTapMonitor[1] = initialPointerOffsetX;
          doubleTapMonitor[2] = initialPointerOffsetY;
          setTimeout(function () {
            doubleTapMonitor = [null];
          }, DOUBLECLICK_DELAY);
        } else if (doubleTapMonitor[0] === e.target && touchmoveCount <= 1 && isWithinRange(initialPointerOffsetX, doubleTapMonitor[1] - 10, doubleTapMonitor[1] + 10) === true && isWithinRange(initialPointerOffsetY, doubleTapMonitor[2] - 10, doubleTapMonitor[2] + 10) === true) {
          addClass($element, _transition);

          if (hasClass($container, _active) === true) {
            /* Set attributes */
            $element.setAttribute(_dataScale, 1);
            $element.setAttribute(_dataTranslateX, 0);
            $element.setAttribute(_dataTranslateY, 0);
            zoomInactive($container);
            moveScaleElement($element, 0, 0, 1);
          } else {
            pointerOffsetX = e.touches[0].clientX;
            pointerOffsetY = e.touches[0].clientY;
            targetScale = SCALE_DEFAULT;
            scaleDirection = 1;
            scaleDifference = (SCALE_DEFAULT - 1) * scaleDirection;
            /* Set offset limits */

            limitOffsetX = getLimitOffset(elementWidth, containerWidth, targetScale);
            limitOffsetY = getLimitOffset(elementHeight, containerHeight, targetScale);

            if (targetScale <= 1) {
              targetOffsetX = 0;
              targetOffsetY = 0;
            } else {
              /* Set target offsets */
              targetOffsetX = elementWidth * targetScale <= containerWidth ? 0 : minMax(initialOffsetX - (pointerOffsetX - containerOffsetX - containerWidth / 2 - initialOffsetX) / (targetScale - scaleDifference) * scaleDifference, limitOffsetX * -1, limitOffsetX);
              targetOffsetY = elementHeight * targetScale <= containerHeight ? 0 : minMax(initialOffsetY - (pointerOffsetY - containerOffsetY - containerHeight / 2 - initialOffsetY) / (targetScale - scaleDifference) * scaleDifference, limitOffsetY * -1, limitOffsetY);
            }

            zoomActive($container);

            if (Math.abs(targetOffsetX) === Math.abs(limitOffsetX) && targetScale > 1 && slickCarousel.length) {
              $(".".concat(slickCarousel)).slick('slickSetOption', {
                'touchMove': true,
                'swipe': true
              });
            }
            /* Set attributes */


            $element.setAttribute(_dataScale, targetScale);
            $element.setAttribute(_dataTranslateX, targetOffsetX);
            $element.setAttribute(_dataTranslateY, targetOffsetY);
            moveScaleElement($element, targetOffsetX + "px", targetOffsetY + "px", SCALE_DEFAULT);
          }

          setTimeout(function () {
            removeClass($element, _transition);
          }, TRANSITION_DURATION);
          doubleTapMonitor = [null];
          return false;
        }
        /* Initialize helpers */


        initialOffsetX = parseFloat($element.getAttribute(_dataTranslateX));
        initialOffsetY = parseFloat($element.getAttribute(_dataTranslateY));
      } else if (touchCount === 2)
      /* Pinch */
      {
        /* Initialize helpers */
        initialOffsetX = parseFloat($element.getAttribute(_dataTranslateX));
        initialOffsetY = parseFloat($element.getAttribute(_dataTranslateY));
        initialPointerOffsetX2 = e.touches[1].clientX;
        initialPointerOffsetY2 = e.touches[1].clientY;
        pinchOffsetX = (initialPointerOffsetX + initialPointerOffsetX2) / 2;
        pinchOffsetY = (initialPointerOffsetY + initialPointerOffsetY2) / 2;
        initialPinchDistance = Math.sqrt((initialPointerOffsetX - initialPointerOffsetX2) * (initialPointerOffsetX - initialPointerOffsetX2) + (initialPointerOffsetY - initialPointerOffsetY2) * (initialPointerOffsetY - initialPointerOffsetY2));
      }

    touchmoveCount = 0;
    /* Set capture */

    capture = true;
  }

  function touchMove(e) {
    if (e.target == $element && hasClass($container, _active) == true) {
      preventDefault();
    }

    if (capture === false) {
      return false;
    }
    /* Initialize helpers */


    pointerOffsetX = e.touches[0].clientX;
    pointerOffsetY = e.touches[0].clientY;
    touchCount = e.touches.length;
    touchmoveCount++;
    offset = $container.getBoundingClientRect();

    if (touchCount > 1)
      /* Pinch */
      {
        pointerOffsetX2 = e.touches[1].clientX;
        pointerOffsetY2 = e.touches[1].clientY;
        targetPinchDistance = Math.sqrt((pointerOffsetX - pointerOffsetX2) * (pointerOffsetX - pointerOffsetX2) + (pointerOffsetY - pointerOffsetY2) * (pointerOffsetY - pointerOffsetY2));

        if (initialPinchDistance === null) {
          initialPinchDistance = targetPinchDistance;
        }

        if (Math.abs(initialPinchDistance - targetPinchDistance) >= 1) {
          /* Initialize helpers */
          targetScale = minMax(targetPinchDistance / initialPinchDistance * initialScale, SCALE_MIN, SCALE_MAX);
          limitOffsetX = getLimitOffset(elementWidth, containerWidth, targetScale);
          limitOffsetY = getLimitOffset(elementHeight, containerHeight, targetScale);
          scaleDifference = targetScale - initialScale;
          targetOffsetX = elementWidth * targetScale <= containerWidth ? 0 : minMax(initialOffsetX - (pinchOffsetX - containerOffsetX - containerWidth / 2 - initialOffsetX) / (targetScale - scaleDifference) * scaleDifference, limitOffsetX * -1, limitOffsetX);
          targetOffsetY = elementHeight * targetScale <= containerHeight ? 0 : minMax(initialOffsetY - (pinchOffsetY - containerOffsetY - containerHeight / 2 - initialOffsetY) / (targetScale - scaleDifference) * scaleDifference, limitOffsetY * -1, limitOffsetY);

          if (targetScale > 1) {
            zoomActive($container);
          } else {
            zoomInactive($container);
          }

          moveScaleElement($element, targetOffsetX + 'px', targetOffsetY + 'px', targetScale);
          /* Initialize helpers */

          initialPinchDistance = targetPinchDistance;
          initialScale = targetScale;
          initialOffsetX = targetOffsetX;
          initialOffsetY = targetOffsetY;
        }
      } else
      /* Single touch */
      {
        /* Initialize helpers */
        targetScale = initialScale;
        limitOffsetX = getLimitOffset(elementWidth, containerWidth, targetScale);
        limitOffsetY = getLimitOffset(elementHeight, containerHeight, targetScale);
        targetOffsetX = elementWidth * targetScale <= containerWidth ? 0 : minMax(pointerOffsetX - (initialPointerOffsetX - initialOffsetX), limitOffsetX * -1, limitOffsetX);
        targetOffsetY = elementHeight * targetScale <= containerHeight ? 0 : minMax(pointerOffsetY - (initialPointerOffsetY - initialOffsetY), limitOffsetY * -1, limitOffsetY);

        if (Math.abs(targetOffsetX) === Math.abs(limitOffsetX)) {
          initialOffsetX = targetOffsetX;
          initialPointerOffsetX = pointerOffsetX;
        }

        if (Math.abs(targetOffsetY) === Math.abs(limitOffsetY)) {
          initialOffsetY = targetOffsetY;
          initialPointerOffsetY = pointerOffsetY;
        } // When zoomed in, only allow swiping to next slide when at the X limit edges


        if (Math.abs(targetOffsetX) === Math.abs(limitOffsetX) && targetScale > 1 && slickCarousel.length) {
          $(".".concat(slickCarousel)).slick('slickSetOption', {
            'touchMove': true,
            'swipe': true
          });
        }
        /* Set attributes */


        $element.setAttribute(_dataScale, initialScale);
        $element.setAttribute(_dataTranslateX, targetOffsetX);
        $element.setAttribute(_dataTranslateY, targetOffsetY);
        moveScaleElement($element, targetOffsetX + 'px', targetOffsetY + 'px', targetScale);
      }
  }

  function touchEnd(e) {
    touchCount = e.touches.length;

    if (capture === false) {
      return false;
    }

    if (touchCount === 0)
      /* No touch */
      {
        /* Set attributes */
        $element.setAttribute(_dataScale, initialScale);
        $element.setAttribute(_dataTranslateX, targetOffsetX);
        $element.setAttribute(_dataTranslateY, targetOffsetY);
        initialPinchDistance = null;
        capture = false;
      } else if (touchCount === 1)
      /* Single touch */
      {
        initialPointerOffsetX = e.touches[0].clientX;
        initialPointerOffsetY = e.touches[0].clientY;
      } else if (touchCount > 1)
      /* Pinch */
      {
        initialPinchDistance = null;
      }
  }

  function addClass($element, targetClass) {
    if (hasClass($element, targetClass) === false) {
      $element.className += ' ' + targetClass;
    }
  }

  function isWithinRange(value, min, max) {
    return value >= min && value <= max;
  }

  function hasClass($element, targetClass) {
    var rgx = new RegExp('(?:^|\\s)' + targetClass + '(?!\\S)', 'g');
    return !!$element.className.match(rgx);
  }

  function massAddEventListener($elements, event, customFunction, useCapture) {
    var useCapture = useCapture || false;

    for (var i = 0; i < $elements.length; i++) {
      $elements[i].addEventListener(event, customFunction, useCapture);
    }
  }

  function minMax(value, min, max) {
    if (value < min) {
      value = min;
    } else if (value > max) {
      value = max;
    }

    return value;
  }

  function moveScaleElement($element, targetOffsetX, targetOffsetY, targetScale) {
    if (SUPPORT_3D_TRANSFORM) {
      $element.style.cssText = '-moz-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + '-ms-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') scale(' + targetScale + '); ' + '-o-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + '-webkit-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + 'transform : translate3d(' + targetOffsetX + ', ' + targetOffsetY + ', 0) scale3d(' + targetScale + ', ' + targetScale + ', 1);';
    } else {
      $element.style.cssText = '-moz-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + '-ms-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') scale(' + targetScale + '); ' + '-o-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + '-webkit-transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') ' + 'scale(' + targetScale + '); ' + 'transform : translate(' + targetOffsetX + ', ' + targetOffsetY + ') scale(' + targetScale + ', ' + targetScale + ')';
    }
  }

  function preventDefault(e) {
    e = e || window.event;

    if (e.preventDefault) {
      e.preventDefault();
    }

    e.returnValue = false;
  }

  function preventDefaultForScrollKeys(e) {
    var keys = {
      37: 1,
      38: 1,
      39: 1,
      40: 1
    };

    if (keys[e.keyCode]) {
      preventDefault(e);
      return false;
    }
  }

  function removeClass($element, targetClass) {
    var rgx = new RegExp('(?:^|\\s)' + targetClass + '(?!\\S)', 'g');
    $element.className = $element.className.replace(rgx, '');
  }

  function getLimitOffset(elementDimension, containerDimension, targetScale) {
    return (elementDimension * targetScale - containerDimension) / 2;
  }

  function zoomActive($container) {
    addClass($container, _active);

    if (callback) {
      callback($container, true);
    }
  }

  function zoomInactive($container) {
    removeClass($container, _active);

    if (callback) {
      callback($container, false);
    }
  }

  function iOSSafari() {
    if (['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) > -1 || navigator.userAgent.includes('Mac') && 'ontouchend' in document) {
      var ua = navigator.userAgent.toLowerCase();

      if (ua.indexOf('safari') > -1 && ua.indexOf('chrome') === -1) {
        return true;
      }
    }

    return false;
  }

  function preventSlide(containerOffset, pointerOffset) {
    if (isMobile && hideThumbnail) {
      return;
    }

    var limit = containerOffset.width * .1;
    var leftLimit = containerOffset.left + limit;
    var rightLimit = containerOffset.right - limit;
    var leftLimitCheck = pointerOffset > containerOffset.left && pointerOffset < leftLimit;
    var rightLimitCheck = pointerOffset < containerOffset.right && pointerOffset > rightLimit;

    if (hasClass($container, _active) === true) {
      if (leftLimitCheck || rightLimitCheck) {
        $(".".concat(slickCarousel)).slick('slickSetOption', {
          'touchMove': true,
          'swipe': true
        });
      } else {
        $(".".concat(slickCarousel)).slick('slickSetOption', {
          'touchMove': false,
          'swipe': false
        });
      }
    } else {
      $(".".concat(slickCarousel)).slick('slickSetOption', {
        'touchMove': true,
        'swipe': true
      });
    }
  }

  ;

  function resetClickCount() {
    setTimeout(function () {
      clickCount = 0;
    }, 600);
  }
}

if (true) {
  module.exports = {
    zoom: zoom
  };
}

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/util.js":
/*!**************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/util.js ***!
  \**************************************************************************/
/***/ (function(module) {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (include) {
  if (typeof include === 'function') {
    include();
  } else if (_typeof(include) === 'object') {
    Object.keys(include).forEach(function (key) {
      if (typeof include[key] === 'function') {
        include[key]();
      }
    });
  }
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js":
/*!**********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/clientSideUtil.js ***!
  \**********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var DOMpurify = __webpack_require__(/*! dompurify */ "./node_modules/dompurify/dist/purify.js");

var timer;
/**
 * cleartimout and setting the timer for minicart after add a product to cart
 * @param {string} selector - current selector
 * @param {number} millisec - duration after which this event will trigger
 */

function clearAndSetTime(selector, millisec) {
  if (timer) {
    window.clearTimeout(timer);
  }

  timer = window.setTimeout(function () {
    $(selector).addClass('d-none');
  }, millisec);
}
/**
* scroll to destination element
* @param {integer} top - Top value for current element
* @param {integer} left - left value for current element
* @param {string} behavior - behavior for the scroll smooth/instant/auto
*/


function windowScrollToDestination(top, left, behavior) {
  var topValue = top;

  if ($('header').outerHeight()) {
    topValue -= $('header').outerHeight();
  }

  window.scroll({
    top: topValue,
    left: left,
    behavior: behavior
  });
}
/**
 * Tooltip for Shipping Restriction
 */


function initTooltip() {
  if ($('[data-toggle="tooltip"]').length) {
    $('[data-toggle="tooltip"]').tooltip();
  }
}
/**
 * floatToastMessage
 * @param {string} message - message
 * @param {string} alertTime - timer
 * @param {boolean} isSuccess - isSuccess
 * @param {string} updateCartFlag - updateCartFlag
 */


function floatToastMessage(message, alertTime, isSuccess, updateCartFlag) {
  var messageType = isSuccess ? 'toast-alert-success' : 'toast-alert-error';

  if ($('.float-toast-message').length === 0) {
    $('body').append('<div class="float-toast-message" aria-live="assertive"></div>');
  }

  $('.float-toast-message').empty().append('<div class="alert ' + DOMpurify.sanitize(messageType) + ' float-toast-alert text-center toastfont-small" aria-live="assertive" role="alert">' + DOMpurify.sanitize(message) + '</div>');

  if (updateCartFlag === 'updateCart') {
    $('nav').attr('aria-hidden', true);
    $('.float-toast-alert').removeAttr('role');
    $('.float-toast-alert').attr('tabindex', '0');
    setTimeout(function () {
      $('.float-toast-alert').focus();
    }, 200);
  }

  setTimeout(function () {
    $('nav').removeAttr('aria-hidden');
    $('.float-toast-alert').remove();

    if ($('.cart-page').length > 0) {
      var selectedProductID = $('.cart-page').attr('selected-product-id');
      $('.cartproduct-card').each(function () {
        var currentProductID = $(this).attr('data-product-id');

        if (selectedProductID === currentProductID) {
          $(this).find('.product-item-edit .edit').focus();
        }
      });
    }

    if ($('.edit-btn-address') && $('.edit-btn-address').length > 0) {
      $('.edit-btn-address[data-edit-id="' + $('.address-summary-section').attr('current_edit') + '"]').focus();
      $('.address-summary-section').removeAttr('current_edit');
    }
  }, alertTime);
}
/**
 *
 * @param {string} formId form id
 * @returns {Object} custom object
 */


function convertFormDataToObj(formId) {
  var form = document.getElementById(formId);
  var formData = new FormData(form);
  var obj = {};
  formData.forEach(function (value, key) {
    if (!Reflect.has(obj, key)) {
      obj[key] = value;
      return;
    }

    if (!Array.isArray(obj[key])) {
      obj[key] = [obj[key]];
    }

    obj[key].push(value);
  });
  return obj;
}

$.fn.isInViewport = function () {
  var elementTop = $(this).offset().top;
  var elementBottom = elementTop + $(this).outerHeight();
  var $header = $('.checkout-header').length ? $('.checkout-header') : $('header');
  var viewportTop = $(window).scrollTop() + $header.height();
  var viewportBottom = viewportTop + $(window).height();
  return elementBottom > viewportTop && elementTop < viewportBottom;
};

module.exports = {
  windowScrollToDestination: windowScrollToDestination,
  initTooltip: initTooltip,
  clearAndSetTime: clearAndSetTime,
  floatToastMessage: floatToastMessage,
  convertFormDataToObj: convertFormDataToObj
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js":
/*!*****************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/constants.js ***!
  \*****************************************************************************************/
/***/ (function(module) {

var SCREENSIZES = {
  MOBILEMAX: 767,
  LANDSCAPEHEIGHTMAX: 575,
  TABLETMIN: 768,
  TABLETMAX: 1023,
  DESKTOPMIN: 1024
};
var GIFT_CERTIFICATE = 'GIFT_CERTIFICATE';
var CREDIT_CARD = 'CREDIT_CARD';
var PAYPAL = 'PAYPAL';
var MENUHOVERDELAY = 250;
var MENUCLOSEDELAY = 250;
var SUBMENUHOVERDELAY = 500;
var FREESHIPPING = 'FREE';
var STATELABEL = 'state';
var NEWCARD = 'newcard';
var NA_COUNTRIES = ['us', 'ca'];
var EU_PHONE_NUMBER_COUNTRY_CODES = {
  GB: 44,
  DE: 49,
  FR: 33,
  IT: 39,
  ES: 34,
  AT: 43,
  BE: 32,
  CZ: 420,
  HU: 36,
  NL: 31,
  PL: 48,
  PT: 351,
  RO: 40,
  IE: 353,
  SE: 46,
  CH: 41,
  DK: 45,
  FI: 358,
  LV: 371,
  LT: 370,
  LU: 352,
  NO: 47
};
var DSR_FORM_DETAILS_NOT_REQUIRED_TYPE = ['AccessRequest', 'CorrectionRequest'];
module.exports = {
  SCREENSIZE: SCREENSIZES,
  GIFT_CERTIFICATE: GIFT_CERTIFICATE,
  CREDIT_CARD: CREDIT_CARD,
  PAYPAL: PAYPAL,
  MENUCLOSEDELAY: MENUCLOSEDELAY,
  EU_PHONE_NUMBER_COUNTRY_CODES: EU_PHONE_NUMBER_COUNTRY_CODES,
  FREESHIPPING: FREESHIPPING,
  DSR_FORM_DETAILS_NOT_REQUIRED_TYPE: DSR_FORM_DETAILS_NOT_REQUIRED_TYPE,
  STATELABEL: STATELABEL,
  NEWCARD: NEWCARD,
  MENUHOVERDELAY: MENUHOVERDELAY,
  NA_COUNTRIES: NA_COUNTRIES,
  SUBMENUHOVERDELAY: SUBMENUHOVERDELAY
};

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/lazysizesConfig.js":
/*!***********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/lazysizesConfig.js ***!
  \***********************************************************************************************/
/***/ (function() {

"use strict";


window.lazySizesConfig = window.lazySizesConfig || {};
window.lazySizesConfig.loadMode = 1;

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/phoneFormatter.js":
/*!**********************************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/phoneFormatter.js ***!
  \**********************************************************************************************/
/***/ (function(module) {

/** jQuery Mask Plugin for phone numbers
* @param {Object} input - jQuery Input selector to be formatted
*/
// function maskPhoneNumber(input) {
//     var maskPattern = $(input).attr('placeholder');
//     var masklength = maskPattern.length;
//     $(input).mask(
//         maskPattern,
//         { translation: { Z: { pattern: /[0-9]/, optional: true } } }
//     );
//     $(input).attr('minlength', masklength).attr('maxlength', masklength);
// }

/**
 * Updates the phone's country and flag based on the phone number's country code
 * @param {Object} input - phone field jQuery object
 * @param {string} phoneNumber - e164 phone number
 */
function setPhoneCountry(input, phoneNumber) {
  if (phoneNumber && phoneNumber.toString().includes('+')) {
    input.intlTelInput('setNumber', phoneNumber);
  }
}
/**
 * Validates phone number and displays error if invalid
 * @param {Object} input - phone field jQuery object
 * @returns {boolean} if the phone number is valid
 */


function validatePhoneNumber(input) {
  var isValid = input.intlTelInput('isValidNumber');
  var phoneFormGroup = input.parents('.form-group');
  var phoneErrorContainer = phoneFormGroup.find('.invalid-feedback');
  phoneErrorContainer.text('');
  phoneFormGroup.removeClass('is-invalid');
  phoneFormGroup.find('input').removeClass('is-invalid');

  if (!isValid) {
    var errorMessage = input.val() === '' ? input.data('missingError') : input.data('patternMismatch');
    phoneErrorContainer.text(errorMessage).show();
    phoneFormGroup.find('.js-phone, .js-mobile').addClass('is-invalid');
    phoneFormGroup.find('input').addClass('is-invalid');
  }

  return isValid;
}
/**
 * Initialized country phone input and as-you-type masking
 * @param {Object} input - jQuery Input selector to be formatted
 * @param {string} country - Country to default the form to on load.
 * @param {string} phoneNumber - Pre-populated phone number
 */


function initialIntlTel(input, country) {
  var utilsUrl = window.intlTelInputGlobalsUtilsURL;
  input.removeAttr('pattern');
  input.intlTelInput({
    initialCountry: country,
    autoPlaceholder: 'aggressive',
    utilsScript: utilsUrl
  });
  input.on('updatePlaceholder', function () {// maskPhoneNumber(input);
  });
  input.on('blur', function () {
    validatePhoneNumber(input);
  });
}
/**
 * Initialized the International phone number input field
 * @param {string} phoneField - phone field class
 * @returns {string} e164 formatter phone number
 */


function getPhoneNumberE164(phoneField) {
  var e164Format = $(phoneField).intlTelInput('getNumber');
  return e164Format;
}
/**
 * Updates phone number with e.164 format and serializes the form data
 * @param {Object} form - form to be serialized
 * @returns {string} serialized form data
 */


function serializeFormData(form) {
  var formArray = form.serializeArray();
  var phoneField = form.find('.js-phone');
  var mobileField = form.find('.js-mobile');
  var zipCode = form.find('.js-zip-code');

  if (phoneField && phoneField.length) {
    var phoneFieldName = phoneField.attr('name');
    var e164PhoneNumber = getPhoneNumberE164(phoneField[0]);
    formArray.find(function (x) {
      return x.name === phoneFieldName;
    }).value = e164PhoneNumber;
  }

  if (mobileField && mobileField.length) {
    var mobileFieldName = mobileField.attr('name');
    var e164MobileNumber = getPhoneNumberE164(mobileField[0]);
    formArray.find(function (x) {
      return x.name === mobileFieldName;
    }).value = e164MobileNumber;
  }

  if (zipCode && zipCode.length) {
    var zipCodeName = zipCode.attr('name');
    formArray.find(function (x) {
      return x.name === zipCodeName;
    }).value = formArray.find(function (x) {
      return x.name === zipCodeName;
    }).value.toUpperCase();
  }

  return $.param(formArray);
}
/**
 *
 * @param {string} input - country flag to be updated
 * @param {string} countryCode - country code for flag
 */


function setCountryFlag(input, countryCode) {
  input.intlTelInput('setCountry', countryCode);
}

module.exports = {
  methods: {
    initialIntlTel: initialIntlTel,
    getPhoneNumberE164: getPhoneNumberE164,
    serializeFormData: serializeFormData,
    setPhoneCountry: setPhoneCountry,
    validatePhoneNumber: validatePhoneNumber,
    setCountryFlag: setCountryFlag
  }
};

/***/ }),

/***/ "./node_modules/bootstrap/js/src/alert.js":
/*!************************************************!*\
  !*** ./node_modules/bootstrap/js/src/alert.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

var NAME = 'alert';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.alert';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME];
var CLASS_NAME_ALERT = 'alert';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var EVENT_CLOSE = "close".concat(EVENT_KEY);
var EVENT_CLOSED = "closed".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var SELECTOR_DISMISS = '[data-dismiss="alert"]';
/**
 * Class definition
 */

var Alert = /*#__PURE__*/function () {
  function Alert(element) {
    _classCallCheck(this, Alert);

    this._element = element;
  } // Getters


  _createClass(Alert, [{
    key: "close",
    value: // Public
    function close(element) {
      var rootElement = this._element;

      if (element) {
        rootElement = this._getRootElement(element);
      }

      var customEvent = this._triggerCloseEvent(rootElement);

      if (customEvent.isDefaultPrevented()) {
        return;
      }

      this._removeElement(rootElement);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default().removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private

  }, {
    key: "_getRootElement",
    value: function _getRootElement(element) {
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(element);
      var parent = false;

      if (selector) {
        parent = document.querySelector(selector);
      }

      if (!parent) {
        parent = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).closest(".".concat(CLASS_NAME_ALERT))[0];
      }

      return parent;
    }
  }, {
    key: "_triggerCloseEvent",
    value: function _triggerCloseEvent(element) {
      var closeEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_CLOSE);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).trigger(closeEvent);
      return closeEvent;
    }
  }, {
    key: "_removeElement",
    value: function _removeElement(element) {
      var _this = this;

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).removeClass(CLASS_NAME_SHOW);

      if (!jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).hasClass(CLASS_NAME_FADE)) {
        this._destroyElement(element);

        return;
      }

      var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function (event) {
        return _this._destroyElement(element, event);
      }).emulateTransitionEnd(transitionDuration);
    }
  }, {
    key: "_destroyElement",
    value: function _destroyElement(element) {
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).detach().trigger(EVENT_CLOSED).remove();
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var data = $element.data(DATA_KEY);

        if (!data) {
          data = new Alert(this);
          $element.data(DATA_KEY, data);
        }

        if (config === 'close') {
          data[config](this);
        }
      });
    }
  }, {
    key: "_handleDismiss",
    value: function _handleDismiss(alertInstance) {
      return function (event) {
        if (event) {
          event.preventDefault();
        }

        alertInstance.close(this);
      };
    }
  }]);

  return Alert;
}();
/**
 * Data API implementation
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));
/**
 * jQuery
 */

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = Alert._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].Constructor = Alert;

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return Alert._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Alert);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/collapse.js":
/*!***************************************************!*\
  !*** ./node_modules/bootstrap/js/src/collapse.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

var NAME = 'collapse';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.collapse';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME];
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_COLLAPSE = 'collapse';
var CLASS_NAME_COLLAPSING = 'collapsing';
var CLASS_NAME_COLLAPSED = 'collapsed';
var DIMENSION_WIDTH = 'width';
var DIMENSION_HEIGHT = 'height';
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var SELECTOR_ACTIVES = '.show, .collapsing';
var SELECTOR_DATA_TOGGLE = '[data-toggle="collapse"]';
var Default = {
  toggle: true,
  parent: ''
};
var DefaultType = {
  toggle: 'boolean',
  parent: '(string|element)'
};
/**
 * Class definition
 */

var Collapse = /*#__PURE__*/function () {
  function Collapse(element, config) {
    _classCallCheck(this, Collapse);

    this._isTransitioning = false;
    this._element = element;
    this._config = this._getConfig(config);
    this._triggerArray = [].slice.call(document.querySelectorAll("[data-toggle=\"collapse\"][href=\"#".concat(element.id, "\"],") + "[data-toggle=\"collapse\"][data-target=\"#".concat(element.id, "\"]")));
    var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));

    for (var i = 0, len = toggleList.length; i < len; i++) {
      var elem = toggleList[i];
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(elem);
      var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {
        return foundElem === element;
      });

      if (selector !== null && filterElement.length > 0) {
        this._selector = selector;

        this._triggerArray.push(elem);
      }
    }

    this._parent = this._config.parent ? this._getParent() : null;

    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._element, this._triggerArray);
    }

    if (this._config.toggle) {
      this.toggle();
    }
  } // Getters


  _createClass(Collapse, [{
    key: "toggle",
    value: // Public
    function toggle() {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        this.hide();
      } else {
        this.show();
      }
    }
  }, {
    key: "show",
    value: function show() {
      var _this = this;

      if (this._isTransitioning || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var actives;
      var activesData;

      if (this._parent) {
        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {
          if (typeof _this._config.parent === 'string') {
            return elem.getAttribute('data-parent') === _this._config.parent;
          }

          return elem.classList.contains(CLASS_NAME_COLLAPSE);
        });

        if (actives.length === 0) {
          actives = null;
        }
      }

      if (actives) {
        activesData = jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).not(this._selector).data(DATA_KEY);

        if (activesData && activesData._isTransitioning) {
          return;
        }
      }

      var startEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      if (actives) {
        Collapse._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).not(this._selector), 'hide');

        if (!activesData) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(actives).data(DATA_KEY, null);
        }
      }

      var dimension = this._getDimension();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;

      if (this._triggerArray.length) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);
      }

      this.setTransitioning(true);

      var complete = function complete() {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass("".concat(CLASS_NAME_COLLAPSE, " ").concat(CLASS_NAME_SHOW));
        _this._element.style[dimension] = '';

        _this.setTransitioning(false);

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).trigger(EVENT_SHOWN);
      };

      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      var scrollSize = "scroll".concat(capitalizedDimension);
      var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      this._element.style[dimension] = "".concat(this._element[scrollSize], "px");
    }
  }, {
    key: "hide",
    value: function hide() {
      var _this2 = this;

      if (this._isTransitioning || !jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_SHOW)) {
        return;
      }

      var startEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_HIDE);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(startEvent);

      if (startEvent.isDefaultPrevented()) {
        return;
      }

      var dimension = this._getDimension();

      this._element.style[dimension] = "".concat(this._element.getBoundingClientRect()[dimension], "px");
      _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).addClass(CLASS_NAME_COLLAPSING).removeClass("".concat(CLASS_NAME_COLLAPSE, " ").concat(CLASS_NAME_SHOW));
      var triggerArrayLength = this._triggerArray.length;

      if (triggerArrayLength > 0) {
        for (var i = 0; i < triggerArrayLength; i++) {
          var trigger = this._triggerArray[i];
          var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(trigger);

          if (selector !== null) {
            var $elem = jquery__WEBPACK_IMPORTED_MODULE_0___default()([].slice.call(document.querySelectorAll(selector)));

            if (!$elem.hasClass(CLASS_NAME_SHOW)) {
              jquery__WEBPACK_IMPORTED_MODULE_0___default()(trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);
            }
          }
        }
      }

      this.setTransitioning(true);

      var complete = function complete() {
        _this2.setTransitioning(false);

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);
      };

      this._element.style[dimension] = '';
      var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
    }
  }, {
    key: "setTransitioning",
    value: function setTransitioning(isTransitioning) {
      this._isTransitioning = isTransitioning;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default().removeData(this._element, DATA_KEY);
      this._config = null;
      this._parent = null;
      this._element = null;
      this._triggerArray = null;
      this._isTransitioning = null;
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), config);
      config.toggle = Boolean(config.toggle); // Coerce string values

      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_getDimension",
    value: function _getDimension() {
      var hasWidth = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(DIMENSION_WIDTH);
      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;
    }
  }, {
    key: "_getParent",
    value: function _getParent() {
      var _this3 = this;

      var parent;

      if (_util__WEBPACK_IMPORTED_MODULE_1__["default"].isElement(this._config.parent)) {
        parent = this._config.parent; // It's a jQuery object

        if (typeof this._config.parent.jquery !== 'undefined') {
          parent = this._config.parent[0];
        }
      } else {
        parent = document.querySelector(this._config.parent);
      }

      var selector = "[data-toggle=\"collapse\"][data-parent=\"".concat(this._config.parent, "\"]");
      var children = [].slice.call(parent.querySelectorAll(selector));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(children).each(function (i, element) {
        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);
      });
      return parent;
    }
  }, {
    key: "_addAriaAndCollapsedClass",
    value: function _addAriaAndCollapsedClass(element, triggerArray) {
      var isOpen = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).hasClass(CLASS_NAME_SHOW);

      if (triggerArray.length) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);
      }
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_getTargetFromElement",
    value: function _getTargetFromElement(element) {
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(element);
      return selector ? document.querySelector(selector) : null;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var data = $element.data(DATA_KEY);

        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default), $element.data()), _typeof(config) === 'object' && config ? config : {});

        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {
          _config.toggle = false;
        }

        if (!data) {
          data = new Collapse(this, _config);
          $element.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Collapse;
}();
/**
 * Data API implementation
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.currentTarget.tagName === 'A') {
    event.preventDefault();
  }

  var $trigger = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
  var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this);
  var selectors = [].slice.call(document.querySelectorAll(selector));
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(selectors).each(function () {
    var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
    var data = $target.data(DATA_KEY);
    var config = data ? 'toggle' : $trigger.data();

    Collapse._jQueryInterface.call($target, config);
  });
});
/**
 * jQuery
 */

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = Collapse._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].Constructor = Collapse;

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return Collapse._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Collapse);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/modal.js":
/*!************************************************!*\
  !*** ./node_modules/bootstrap/js/src/modal.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

var NAME = 'modal';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.modal';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME];
var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key

var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';
var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';
var CLASS_NAME_BACKDROP = 'modal-backdrop';
var CLASS_NAME_OPEN = 'modal-open';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var CLASS_NAME_STATIC = 'modal-static';
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDE_PREVENTED = "hidePrevented".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_FOCUSIN = "focusin".concat(EVENT_KEY);
var EVENT_RESIZE = "resize".concat(EVENT_KEY);
var EVENT_CLICK_DISMISS = "click.dismiss".concat(EVENT_KEY);
var EVENT_KEYDOWN_DISMISS = "keydown.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEUP_DISMISS = "mouseup.dismiss".concat(EVENT_KEY);
var EVENT_MOUSEDOWN_DISMISS = "mousedown.dismiss".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var SELECTOR_DIALOG = '.modal-dialog';
var SELECTOR_MODAL_BODY = '.modal-body';
var SELECTOR_DATA_TOGGLE = '[data-toggle="modal"]';
var SELECTOR_DATA_DISMISS = '[data-dismiss="modal"]';
var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
var SELECTOR_STICKY_CONTENT = '.sticky-top';
var Default = {
  backdrop: true,
  keyboard: true,
  focus: true,
  show: true
};
var DefaultType = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  focus: 'boolean',
  show: 'boolean'
};
/**
 * Class definition
 */

var Modal = /*#__PURE__*/function () {
  function Modal(element, config) {
    _classCallCheck(this, Modal);

    this._config = this._getConfig(config);
    this._element = element;
    this._dialog = element.querySelector(SELECTOR_DIALOG);
    this._backdrop = null;
    this._isShown = false;
    this._isBodyOverflowing = false;
    this._ignoreBackdropClick = false;
    this._isTransitioning = false;
    this._scrollbarWidth = 0;
  } // Getters


  _createClass(Modal, [{
    key: "toggle",
    value: // Public
    function toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
  }, {
    key: "show",
    value: function show(relatedTarget) {
      var _this = this;

      if (this._isShown || this._isTransitioning) {
        return;
      }

      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_SHOW, {
        relatedTarget: relatedTarget
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = true;

      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE)) {
        this._isTransitioning = true;
      }

      this._checkScrollbar();

      this._setScrollbar();

      this._adjustDialog();

      this._setEscapeEvent();

      this._setResizeEvent();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {
        return _this.hide(event);
      });
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {
          if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).is(_this._element)) {
            _this._ignoreBackdropClick = true;
          }
        });
      });

      this._showBackdrop(function () {
        return _this._showElement(relatedTarget);
      });
    }
  }, {
    key: "hide",
    value: function hide(event) {
      var _this2 = this;

      if (event) {
        event.preventDefault();
      }

      if (!this._isShown || this._isTransitioning) {
        return;
      }

      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_HIDE);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(hideEvent);

      if (!this._isShown || hideEvent.isDefaultPrevented()) {
        return;
      }

      this._isShown = false;
      var transition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE);

      if (transition) {
        this._isTransitioning = true;
      }

      this._setEscapeEvent();

      this._setResizeEvent();

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).removeClass(CLASS_NAME_SHOW);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_CLICK_DISMISS);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).off(EVENT_MOUSEDOWN_DISMISS);

      if (transition) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._element);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function (event) {
          return _this2._hideModal(event);
        }).emulateTransitionEnd(transitionDuration);
      } else {
        this._hideModal();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      [window, this._element, this._dialog].forEach(function (htmlElement) {
        return jquery__WEBPACK_IMPORTED_MODULE_0___default()(htmlElement).off(EVENT_KEY);
      });
      /**
       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`
       * Do not move `document` in `htmlElements` array
       * It will remove `EVENT_CLICK_DATA_API` event that should remain
       */

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN);
      jquery__WEBPACK_IMPORTED_MODULE_0___default().removeData(this._element, DATA_KEY);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
    }
  }, {
    key: "handleUpdate",
    value: function handleUpdate() {
      this._adjustDialog();
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), config);
      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_triggerBackdropTransition",
    value: function _triggerBackdropTransition() {
      var _this3 = this;

      var hideEventPrevented = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_HIDE_PREVENTED);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(hideEventPrevented);

      if (hideEventPrevented.isDefaultPrevented()) {
        return;
      }

      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!isModalOverflowing) {
        this._element.style.overflowY = 'hidden';
      }

      this._element.classList.add(CLASS_NAME_STATIC);

      var modalTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._dialog);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function () {
        _this3._element.classList.remove(CLASS_NAME_STATIC);

        if (!isModalOverflowing) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this3._element).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, function () {
            _this3._element.style.overflowY = '';
          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);
        }
      }).emulateTransitionEnd(modalTransitionDuration);

      this._element.focus();
    }
  }, {
    key: "_showElement",
    value: function _showElement(relatedTarget) {
      var _this4 = this;

      var transition = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE);
      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;

      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
        // Don't move modal's DOM position
        document.body.appendChild(this._element);
      }

      this._element.style.display = 'block';

      this._element.removeAttribute('aria-hidden');

      this._element.setAttribute('aria-modal', true);

      this._element.setAttribute('role', 'dialog');

      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
        modalBody.scrollTop = 0;
      } else {
        this._element.scrollTop = 0;
      }

      if (transition) {
        _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._element);
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).addClass(CLASS_NAME_SHOW);

      if (this._config.focus) {
        this._enforceFocus();
      }

      var shownEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_SHOWN, {
        relatedTarget: relatedTarget
      });

      var transitionComplete = function transitionComplete() {
        if (_this4._config.focus) {
          _this4._element.focus();
        }

        _this4._isTransitioning = false;
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this4._element).trigger(shownEvent);
      };

      if (transition) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._dialog);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._dialog).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
      } else {
        transitionComplete();
      }
    }
  }, {
    key: "_enforceFocus",
    value: function _enforceFocus() {
      var _this5 = this;

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).off(EVENT_FOCUSIN) // Guard against infinite focus loop
      .on(EVENT_FOCUSIN, function (event) {
        if (document !== event.target && _this5._element !== event.target && jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this5._element).has(event.target).length === 0) {
          _this5._element.focus();
        }
      });
    }
  }, {
    key: "_setEscapeEvent",
    value: function _setEscapeEvent() {
      var _this6 = this;

      if (this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {
          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
            event.preventDefault();

            _this6.hide();
          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {
            _this6._triggerBackdropTransition();
          }
        });
      } else if (!this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).off(EVENT_KEYDOWN_DISMISS);
      }
    }
  }, {
    key: "_setResizeEvent",
    value: function _setResizeEvent() {
      var _this7 = this;

      if (this._isShown) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(EVENT_RESIZE, function (event) {
          return _this7.handleUpdate(event);
        });
      } else {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).off(EVENT_RESIZE);
      }
    }
  }, {
    key: "_hideModal",
    value: function _hideModal() {
      var _this8 = this;

      this._element.style.display = 'none';

      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      this._isTransitioning = false;

      this._showBackdrop(function () {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).removeClass(CLASS_NAME_OPEN);

        _this8._resetAdjustments();

        _this8._resetScrollbar();

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this8._element).trigger(EVENT_HIDDEN);
      });
    }
  }, {
    key: "_removeBackdrop",
    value: function _removeBackdrop() {
      if (this._backdrop) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).remove();
        this._backdrop = null;
      }
    }
  }, {
    key: "_showBackdrop",
    value: function _showBackdrop(callback) {
      var _this9 = this;

      var animate = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE) ? CLASS_NAME_FADE : '';

      if (this._isShown && this._config.backdrop) {
        this._backdrop = document.createElement('div');
        this._backdrop.className = CLASS_NAME_BACKDROP;

        if (animate) {
          this._backdrop.classList.add(animate);
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).appendTo(document.body);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).on(EVENT_CLICK_DISMISS, function (event) {
          if (_this9._ignoreBackdropClick) {
            _this9._ignoreBackdropClick = false;
            return;
          }

          if (event.target !== event.currentTarget) {
            return;
          }

          if (_this9._config.backdrop === 'static') {
            _this9._triggerBackdropTransition();
          } else {
            _this9.hide();
          }
        });

        if (animate) {
          _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(this._backdrop);
        }

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).addClass(CLASS_NAME_SHOW);

        if (!callback) {
          return;
        }

        if (!animate) {
          callback();
          return;
        }

        var backdropTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._backdrop);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
      } else if (!this._isShown && this._backdrop) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).removeClass(CLASS_NAME_SHOW);

        var callbackRemove = function callbackRemove() {
          _this9._removeBackdrop();

          if (callback) {
            callback();
          }
        };

        if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_FADE)) {
          var _backdropTransitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(this._backdrop);

          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._backdrop).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);
        } else {
          callbackRemove();
        }
      } else if (callback) {
        callback();
      }
    } // ----------------------------------------------------------------------
    // the following methods are used to handle overflowing modals
    // todo (fat): these should probably be refactored out of modal.js
    // ----------------------------------------------------------------------

  }, {
    key: "_adjustDialog",
    value: function _adjustDialog() {
      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

      if (!this._isBodyOverflowing && isModalOverflowing) {
        this._element.style.paddingLeft = "".concat(this._scrollbarWidth, "px");
      }

      if (this._isBodyOverflowing && !isModalOverflowing) {
        this._element.style.paddingRight = "".concat(this._scrollbarWidth, "px");
      }
    }
  }, {
    key: "_resetAdjustments",
    value: function _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    }
  }, {
    key: "_checkScrollbar",
    value: function _checkScrollbar() {
      var rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
    }
  }, {
    key: "_setScrollbar",
    value: function _setScrollbar() {
      var _this10 = this;

      if (this._isBodyOverflowing) {
        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set
        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set
        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(fixedContent).each(function (index, element) {
          var actualPadding = element.style.paddingRight;
          var calculatedPadding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('padding-right');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('padding-right', actualPadding).css('padding-right', "".concat(parseFloat(calculatedPadding) + _this10._scrollbarWidth, "px"));
        }); // Adjust sticky content margin

        jquery__WEBPACK_IMPORTED_MODULE_0___default()(stickyContent).each(function (index, element) {
          var actualMargin = element.style.marginRight;
          var calculatedMargin = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('margin-right');
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('margin-right', actualMargin).css('margin-right', "".concat(parseFloat(calculatedMargin) - _this10._scrollbarWidth, "px"));
        }); // Adjust body padding

        var actualPadding = document.body.style.paddingRight;
        var calculatedPadding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).css('padding-right');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).data('padding-right', actualPadding).css('padding-right', "".concat(parseFloat(calculatedPadding) + this._scrollbarWidth, "px"));
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).addClass(CLASS_NAME_OPEN);
    }
  }, {
    key: "_resetScrollbar",
    value: function _resetScrollbar() {
      // Restore fixed content padding
      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(fixedContent).each(function (index, element) {
        var padding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('padding-right');
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).removeData('padding-right');
        element.style.paddingRight = padding ? padding : '';
      }); // Restore sticky content

      var elements = [].slice.call(document.querySelectorAll("".concat(SELECTOR_STICKY_CONTENT)));
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(elements).each(function (index, element) {
        var margin = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).data('margin-right');

        if (typeof margin !== 'undefined') {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('margin-right', margin).removeData('margin-right');
        }
      }); // Restore body padding

      var padding = jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).data('padding-right');
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(document.body).removeData('padding-right');
      document.body.style.paddingRight = padding ? padding : '';
    }
  }, {
    key: "_getScrollbarWidth",
    value: function _getScrollbarWidth() {
      // thx d.walsh
      var scrollDiv = document.createElement('div');
      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
      document.body.appendChild(scrollDiv);
      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _objectSpread(_objectSpread(_objectSpread({}, Default), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data()), _typeof(config) === 'object' && config ? config : {});

        if (!data) {
          data = new Modal(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config](relatedTarget);
        } else if (_config.show) {
          data.show(relatedTarget);
        }
      });
    }
  }]);

  return Modal;
}();
/**
 * Data API implementation
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  var _this11 = this;

  var target;
  var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this);

  if (selector) {
    target = document.querySelector(selector);
  }

  var config = jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data(DATA_KEY) ? 'toggle' : _objectSpread(_objectSpread({}, jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).data()), jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data());

  if (this.tagName === 'A' || this.tagName === 'AREA') {
    event.preventDefault();
  }

  var $target = jquery__WEBPACK_IMPORTED_MODULE_0___default()(target).one(EVENT_SHOW, function (showEvent) {
    if (showEvent.isDefaultPrevented()) {
      // Only register focus restorer if modal will actually get shown
      return;
    }

    $target.one(EVENT_HIDDEN, function () {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this11).is(':visible')) {
        _this11.focus();
      }
    });
  });

  Modal._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(target), config, this);
});
/**
 * jQuery
 */

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = Modal._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].Constructor = Modal;

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return Modal._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Modal);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/scrollspy.js":
/*!****************************************************!*\
  !*** ./node_modules/bootstrap/js/src/scrollspy.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

var NAME = 'scrollspy';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.scrollspy';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME];
var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
var CLASS_NAME_ACTIVE = 'active';
var EVENT_ACTIVATE = "activate".concat(EVENT_KEY);
var EVENT_SCROLL = "scroll".concat(EVENT_KEY);
var EVENT_LOAD_DATA_API = "load".concat(EVENT_KEY).concat(DATA_API_KEY);
var METHOD_OFFSET = 'offset';
var METHOD_POSITION = 'position';
var SELECTOR_DATA_SPY = '[data-spy="scroll"]';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_NAV_LINKS = '.nav-link';
var SELECTOR_NAV_ITEMS = '.nav-item';
var SELECTOR_LIST_ITEMS = '.list-group-item';
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_DROPDOWN_ITEMS = '.dropdown-item';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var Default = {
  offset: 10,
  method: 'auto',
  target: ''
};
var DefaultType = {
  offset: 'number',
  method: 'string',
  target: '(string|element)'
};
/**
 * Class definition
 */

var ScrollSpy = /*#__PURE__*/function () {
  function ScrollSpy(element, config) {
    var _this = this;

    _classCallCheck(this, ScrollSpy);

    this._element = element;
    this._scrollElement = element.tagName === 'BODY' ? window : element;
    this._config = this._getConfig(config);
    this._selector = "".concat(this._config.target, " ").concat(SELECTOR_NAV_LINKS, ",") + "".concat(this._config.target, " ").concat(SELECTOR_LIST_ITEMS, ",") + "".concat(this._config.target, " ").concat(SELECTOR_DROPDOWN_ITEMS);
    this._offsets = [];
    this._targets = [];
    this._activeTarget = null;
    this._scrollHeight = 0;
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._scrollElement).on(EVENT_SCROLL, function (event) {
      return _this._process(event);
    });
    this.refresh();

    this._process();
  } // Getters


  _createClass(ScrollSpy, [{
    key: "refresh",
    value: // Public
    function refresh() {
      var _this2 = this;

      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
      this._offsets = [];
      this._targets = [];
      this._scrollHeight = this._getScrollHeight();
      var targets = [].slice.call(document.querySelectorAll(this._selector));
      targets.map(function (element) {
        var target;
        var targetSelector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(element);

        if (targetSelector) {
          target = document.querySelector(targetSelector);
        }

        if (target) {
          var targetBCR = target.getBoundingClientRect();

          if (targetBCR.width || targetBCR.height) {
            // TODO (fat): remove sketch reliance on jQuery position/offset
            return [jquery__WEBPACK_IMPORTED_MODULE_0___default()(target)[offsetMethod]().top + offsetBase, targetSelector];
          }
        }

        return null;
      }).filter(function (item) {
        return item;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).forEach(function (item) {
        _this2._offsets.push(item[0]);

        _this2._targets.push(item[1]);
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default().removeData(this._element, DATA_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._scrollElement).off(EVENT_KEY);
      this._element = null;
      this._scrollElement = null;
      this._config = null;
      this._selector = null;
      this._offsets = null;
      this._targets = null;
      this._activeTarget = null;
      this._scrollHeight = null;
    } // Private

  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      config = _objectSpread(_objectSpread({}, Default), _typeof(config) === 'object' && config ? config : {});

      if (typeof config.target !== 'string' && _util__WEBPACK_IMPORTED_MODULE_1__["default"].isElement(config.target)) {
        var id = jquery__WEBPACK_IMPORTED_MODULE_0___default()(config.target).attr('id');

        if (!id) {
          id = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getUID(NAME);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(config.target).attr('id', id);
        }

        config.target = "#".concat(id);
      }

      _util__WEBPACK_IMPORTED_MODULE_1__["default"].typeCheckConfig(NAME, config, DefaultType);
      return config;
    }
  }, {
    key: "_getScrollTop",
    value: function _getScrollTop() {
      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
    }
  }, {
    key: "_getScrollHeight",
    value: function _getScrollHeight() {
      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
    }
  }, {
    key: "_getOffsetHeight",
    value: function _getOffsetHeight() {
      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
    }
  }, {
    key: "_process",
    value: function _process() {
      var scrollTop = this._getScrollTop() + this._config.offset;

      var scrollHeight = this._getScrollHeight();

      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

      if (this._scrollHeight !== scrollHeight) {
        this.refresh();
      }

      if (scrollTop >= maxScroll) {
        var target = this._targets[this._targets.length - 1];

        if (this._activeTarget !== target) {
          this._activate(target);
        }

        return;
      }

      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
        this._activeTarget = null;

        this._clear();

        return;
      }

      for (var i = this._offsets.length; i--;) {
        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

        if (isActiveTarget) {
          this._activate(this._targets[i]);
        }
      }
    }
  }, {
    key: "_activate",
    value: function _activate(target) {
      this._activeTarget = target;

      this._clear();

      var queries = this._selector.split(',').map(function (selector) {
        return "".concat(selector, "[data-target=\"").concat(target, "\"],").concat(selector, "[href=\"").concat(target, "\"]");
      });

      var $link = jquery__WEBPACK_IMPORTED_MODULE_0___default()([].slice.call(document.querySelectorAll(queries.join(','))));

      if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {
        $link.closest(SELECTOR_DROPDOWN).find(SELECTOR_DROPDOWN_TOGGLE).addClass(CLASS_NAME_ACTIVE);
        $link.addClass(CLASS_NAME_ACTIVE);
      } else {
        // Set triggered link as active
        $link.addClass(CLASS_NAME_ACTIVE); // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor

        $link.parents(SELECTOR_NAV_LIST_GROUP).prev("".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS)).addClass(CLASS_NAME_ACTIVE); // Handle special case when .nav-link is inside .nav-item

        $link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE);
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._scrollElement).trigger(EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
  }, {
    key: "_clear",
    value: function _clear() {
      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {
        return node.classList.contains(CLASS_NAME_ACTIVE);
      }).forEach(function (node) {
        return node.classList.remove(CLASS_NAME_ACTIVE);
      });
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var data = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY);

        var _config = _typeof(config) === 'object' && config;

        if (!data) {
          data = new ScrollSpy(this, _config);
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return ScrollSpy;
}();
/**
 * Data API implementation
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(window).on(EVENT_LOAD_DATA_API, function () {
  var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));
  var scrollSpysLength = scrollSpys.length;

  for (var i = scrollSpysLength; i--;) {
    var $spy = jquery__WEBPACK_IMPORTED_MODULE_0___default()(scrollSpys[i]);

    ScrollSpy._jQueryInterface.call($spy, $spy.data());
  }
});
/**
 * jQuery
 */

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = ScrollSpy._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].Constructor = ScrollSpy;

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return ScrollSpy._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (ScrollSpy);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tab.js":
/*!**********************************************!*\
  !*** ./node_modules/bootstrap/js/src/tab.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */


/**
 * Constants
 */

var NAME = 'tab';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.tab';
var EVENT_KEY = ".".concat(DATA_KEY);
var DATA_API_KEY = '.data-api';
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME];
var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
var CLASS_NAME_ACTIVE = 'active';
var CLASS_NAME_DISABLED = 'disabled';
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var EVENT_HIDE = "hide".concat(EVENT_KEY);
var EVENT_HIDDEN = "hidden".concat(EVENT_KEY);
var EVENT_SHOW = "show".concat(EVENT_KEY);
var EVENT_SHOWN = "shown".concat(EVENT_KEY);
var EVENT_CLICK_DATA_API = "click".concat(EVENT_KEY).concat(DATA_API_KEY);
var SELECTOR_DROPDOWN = '.dropdown';
var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
var SELECTOR_ACTIVE = '.active';
var SELECTOR_ACTIVE_UL = '> li > .active';
var SELECTOR_DATA_TOGGLE = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]';
var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';
/**
 * Class definition
 */

var Tab = /*#__PURE__*/function () {
  function Tab(element) {
    _classCallCheck(this, Tab);

    this._element = element;
  } // Getters


  _createClass(Tab, [{
    key: "show",
    value: // Public
    function show() {
      var _this = this;

      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_ACTIVE) || jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).hasClass(CLASS_NAME_DISABLED)) {
        return;
      }

      var target;
      var previous;
      var listElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];
      var selector = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getSelectorFromElement(this._element);

      if (listElement) {
        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
        previous = jquery__WEBPACK_IMPORTED_MODULE_0___default().makeArray(jquery__WEBPACK_IMPORTED_MODULE_0___default()(listElement).find(itemSelector));
        previous = previous[previous.length - 1];
      }

      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_HIDE, {
        relatedTarget: this._element
      });
      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_SHOW, {
        relatedTarget: previous
      });

      if (previous) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(previous).trigger(hideEvent);
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(this._element).trigger(showEvent);

      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {
        return;
      }

      if (selector) {
        target = document.querySelector(selector);
      }

      this._activate(this._element, listElement);

      var complete = function complete() {
        var hiddenEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_HIDDEN, {
          relatedTarget: _this._element
        });
        var shownEvent = jquery__WEBPACK_IMPORTED_MODULE_0___default().Event(EVENT_SHOWN, {
          relatedTarget: previous
        });
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(previous).trigger(hiddenEvent);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(_this._element).trigger(shownEvent);
      };

      if (target) {
        this._activate(target, target.parentNode, complete);
      } else {
        complete();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      jquery__WEBPACK_IMPORTED_MODULE_0___default().removeData(this._element, DATA_KEY);
      this._element = null;
    } // Private

  }, {
    key: "_activate",
    value: function _activate(element, container, callback) {
      var _this2 = this;

      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? jquery__WEBPACK_IMPORTED_MODULE_0___default()(container).find(SELECTOR_ACTIVE_UL) : jquery__WEBPACK_IMPORTED_MODULE_0___default()(container).children(SELECTOR_ACTIVE);
      var active = activeElements[0];
      var isTransitioning = callback && active && jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).hasClass(CLASS_NAME_FADE);

      var complete = function complete() {
        return _this2._transitionComplete(element, active, callback);
      };

      if (active && isTransitioning) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_1__["default"].getTransitionDurationFromElement(active);
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).removeClass(CLASS_NAME_SHOW).one(_util__WEBPACK_IMPORTED_MODULE_1__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }
    }
  }, {
    key: "_transitionComplete",
    value: function _transitionComplete(element, active, callback) {
      if (active) {
        jquery__WEBPACK_IMPORTED_MODULE_0___default()(active).removeClass(CLASS_NAME_ACTIVE);
        var dropdownChild = jquery__WEBPACK_IMPORTED_MODULE_0___default()(active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];

        if (dropdownChild) {
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(dropdownChild).removeClass(CLASS_NAME_ACTIVE);
        }

        if (active.getAttribute('role') === 'tab') {
          active.setAttribute('aria-selected', false);
        }
      }

      jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).addClass(CLASS_NAME_ACTIVE);

      if (element.getAttribute('role') === 'tab') {
        element.setAttribute('aria-selected', true);
      }

      _util__WEBPACK_IMPORTED_MODULE_1__["default"].reflow(element);

      if (element.classList.contains(CLASS_NAME_FADE)) {
        element.classList.add(CLASS_NAME_SHOW);
      }

      var parent = element.parentNode;

      if (parent && parent.nodeName === 'LI') {
        parent = parent.parentNode;
      }

      if (parent && jquery__WEBPACK_IMPORTED_MODULE_0___default()(parent).hasClass(CLASS_NAME_DROPDOWN_MENU)) {
        var dropdownElement = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).closest(SELECTOR_DROPDOWN)[0];

        if (dropdownElement) {
          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));
          jquery__WEBPACK_IMPORTED_MODULE_0___default()(dropdownToggleList).addClass(CLASS_NAME_ACTIVE);
        }

        element.setAttribute('aria-expanded', true);
      }

      if (callback) {
        callback();
      }
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $this = jquery__WEBPACK_IMPORTED_MODULE_0___default()(this);
        var data = $this.data(DATA_KEY);

        if (!data) {
          data = new Tab(this);
          $this.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tab;
}();
/**
 * Data API implementation
 */


jquery__WEBPACK_IMPORTED_MODULE_0___default()(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  event.preventDefault();

  Tab._jQueryInterface.call(jquery__WEBPACK_IMPORTED_MODULE_0___default()(this), 'show');
});
/**
 * jQuery
 */

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = Tab._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].Constructor = Tab;

(jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return Tab._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Tab);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tools/sanitizer.js":
/*!**********************************************************!*\
  !*** ./node_modules/bootstrap/js/src/tools/sanitizer.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefaultWhitelist": function() { return /* binding */ DefaultWhitelist; },
/* harmony export */   "sanitizeHtml": function() { return /* binding */ sanitizeHtml; }
/* harmony export */ });
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): tools/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
var DefaultWhitelist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

function allowedAttribute(attr, allowedAttributeList) {
  var attrName = attr.nodeName.toLowerCase();

  if (allowedAttributeList.indexOf(attrName) !== -1) {
    if (uriAttrs.indexOf(attrName) !== -1) {
      return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));
    }

    return true;
  }

  var regExp = allowedAttributeList.filter(function (attrRegex) {
    return attrRegex instanceof RegExp;
  }); // Check if a regular expression validates the attribute.

  for (var i = 0, len = regExp.length; i < len; i++) {
    if (regExp[i].test(attrName)) {
      return true;
    }
  }

  return false;
}

function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
  if (unsafeHtml.length === 0) {
    return unsafeHtml;
  }

  if (sanitizeFn && typeof sanitizeFn === 'function') {
    return sanitizeFn(unsafeHtml);
  }

  var domParser = new window.DOMParser();
  var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  var whitelistKeys = Object.keys(whiteList);
  var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));

  var _loop = function _loop(i, len) {
    var el = elements[i];
    var elName = el.nodeName.toLowerCase();

    if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {
      el.parentNode.removeChild(el);
      return "continue";
    }

    var attributeList = [].slice.call(el.attributes); // eslint-disable-next-line unicorn/prefer-spread

    var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);
    attributeList.forEach(function (attr) {
      if (!allowedAttribute(attr, whitelistedAttributes)) {
        el.removeAttribute(attr.nodeName);
      }
    });
  };

  for (var i = 0, len = elements.length; i < len; i++) {
    var _ret = _loop(i, len);

    if (_ret === "continue") continue;
  }

  return createdDocument.body.innerHTML;
}

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tooltip.js":
/*!**************************************************!*\
  !*** ./node_modules/bootstrap/js/src/tooltip.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tools/sanitizer */ "./node_modules/bootstrap/js/src/tools/sanitizer.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var popper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! popper.js */ "./node_modules/popper.js/dist/esm/popper.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/bootstrap/js/src/util.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */




/**
 * Constants
 */

var NAME = 'tooltip';
var VERSION = '4.6.1';
var DATA_KEY = 'bs.tooltip';
var EVENT_KEY = ".".concat(DATA_KEY);
var JQUERY_NO_CONFLICT = (jquery__WEBPACK_IMPORTED_MODULE_1___default().fn)[NAME];
var CLASS_PREFIX = 'bs-tooltip';
var BSCLS_PREFIX_REGEX = new RegExp("(^|\\s)".concat(CLASS_PREFIX, "\\S+"), 'g');
var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
var CLASS_NAME_FADE = 'fade';
var CLASS_NAME_SHOW = 'show';
var HOVER_STATE_SHOW = 'show';
var HOVER_STATE_OUT = 'out';
var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
var SELECTOR_ARROW = '.arrow';
var TRIGGER_HOVER = 'hover';
var TRIGGER_FOCUS = 'focus';
var TRIGGER_CLICK = 'click';
var TRIGGER_MANUAL = 'manual';
var AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: 'right',
  BOTTOM: 'bottom',
  LEFT: 'left'
};
var Default = {
  animation: true,
  template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  selector: false,
  placement: 'top',
  offset: 0,
  container: false,
  fallbackPlacement: 'flip',
  boundary: 'scrollParent',
  customClass: '',
  sanitize: true,
  sanitizeFn: null,
  whiteList: _tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__.DefaultWhitelist,
  popperConfig: null
};
var DefaultType = {
  animation: 'boolean',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string',
  delay: '(number|object)',
  html: 'boolean',
  selector: '(string|boolean)',
  placement: '(string|function)',
  offset: '(number|string|function)',
  container: '(string|element|boolean)',
  fallbackPlacement: '(string|array)',
  boundary: '(string|element)',
  customClass: '(string|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  whiteList: 'object',
  popperConfig: '(null|object)'
};
var Event = {
  HIDE: "hide".concat(EVENT_KEY),
  HIDDEN: "hidden".concat(EVENT_KEY),
  SHOW: "show".concat(EVENT_KEY),
  SHOWN: "shown".concat(EVENT_KEY),
  INSERTED: "inserted".concat(EVENT_KEY),
  CLICK: "click".concat(EVENT_KEY),
  FOCUSIN: "focusin".concat(EVENT_KEY),
  FOCUSOUT: "focusout".concat(EVENT_KEY),
  MOUSEENTER: "mouseenter".concat(EVENT_KEY),
  MOUSELEAVE: "mouseleave".concat(EVENT_KEY)
};
/**
 * Class definition
 */

var Tooltip = /*#__PURE__*/function () {
  function Tooltip(element, config) {
    _classCallCheck(this, Tooltip);

    if (typeof popper_js__WEBPACK_IMPORTED_MODULE_3__["default"] === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    } // Private


    this._isEnabled = true;
    this._timeout = 0;
    this._hoverState = '';
    this._activeTrigger = {};
    this._popper = null; // Protected

    this.element = element;
    this.config = this._getConfig(config);
    this.tip = null;

    this._setListeners();
  } // Getters


  _createClass(Tooltip, [{
    key: "enable",
    value: // Public
    function enable() {
      this._isEnabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this._isEnabled = false;
    }
  }, {
    key: "toggleEnabled",
    value: function toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this._isEnabled) {
        return;
      }

      if (event) {
        var dataKey = this.constructor.DATA_KEY;
        var context = jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
        }

        context._activeTrigger.click = !context._activeTrigger.click;

        if (context._isWithActiveTrigger()) {
          context._enter(null, context);
        } else {
          context._leave(null, context);
        }
      } else {
        if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement()).hasClass(CLASS_NAME_SHOW)) {
          this._leave(null, this);

          return;
        }

        this._enter(null, this);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      clearTimeout(this._timeout);
      jquery__WEBPACK_IMPORTED_MODULE_1___default().removeData(this.element, this.constructor.DATA_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).off(this.constructor.EVENT_KEY);
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);

      if (this.tip) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).remove();
      }

      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;

      if (this._popper) {
        this._popper.destroy();
      }

      this._popper = null;
      this.element = null;
      this.config = null;
      this.tip = null;
    }
  }, {
    key: "show",
    value: function show() {
      var _this = this;

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).css('display') === 'none') {
        throw new Error('Please use show on visible elements');
      }

      var showEvent = jquery__WEBPACK_IMPORTED_MODULE_1___default().Event(this.constructor.Event.SHOW);

      if (this.isWithContent() && this._isEnabled) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(showEvent);
        var shadowRoot = _util__WEBPACK_IMPORTED_MODULE_2__["default"].findShadowRoot(this.element);
        var isInTheDom = jquery__WEBPACK_IMPORTED_MODULE_1___default().contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);

        if (showEvent.isDefaultPrevented() || !isInTheDom) {
          return;
        }

        var tip = this.getTipElement();
        var tipId = _util__WEBPACK_IMPORTED_MODULE_2__["default"].getUID(this.constructor.NAME);
        tip.setAttribute('id', tipId);
        this.element.setAttribute('aria-describedby', tipId);
        this.setContent();

        if (this.config.animation) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(CLASS_NAME_FADE);
        }

        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

        var attachment = this._getAttachment(placement);

        this.addAttachmentClass(attachment);

        var container = this._getContainer();

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).data(this.constructor.DATA_KEY, this);

        if (!jquery__WEBPACK_IMPORTED_MODULE_1___default().contains(this.element.ownerDocument.documentElement, this.tip)) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).appendTo(container);
        }

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(this.constructor.Event.INSERTED);
        this._popper = new popper_js__WEBPACK_IMPORTED_MODULE_3__["default"](this.element, tip, this._getPopperConfig(attachment));
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(CLASS_NAME_SHOW);
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra
        // empty mouseover listeners to the body's immediate children;
        // only needed because of broken event delegation on iOS
        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html

        if ('ontouchstart' in document.documentElement) {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(document.body).children().on('mouseover', null, (jquery__WEBPACK_IMPORTED_MODULE_1___default().noop));
        }

        var complete = function complete() {
          if (_this.config.animation) {
            _this._fixTransition();
          }

          var prevHoverState = _this._hoverState;
          _this._hoverState = null;
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this.element).trigger(_this.constructor.Event.SHOWN);

          if (prevHoverState === HOVER_STATE_OUT) {
            _this._leave(null, _this);
          }
        };

        if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).hasClass(CLASS_NAME_FADE)) {
          var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_2__["default"].getTransitionDurationFromElement(this.tip);
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).one(_util__WEBPACK_IMPORTED_MODULE_2__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
        } else {
          complete();
        }
      }
    }
  }, {
    key: "hide",
    value: function hide(callback) {
      var _this2 = this;

      var tip = this.getTipElement();
      var hideEvent = jquery__WEBPACK_IMPORTED_MODULE_1___default().Event(this.constructor.Event.HIDE);

      var complete = function complete() {
        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {
          tip.parentNode.removeChild(tip);
        }

        _this2._cleanTipClass();

        _this2.element.removeAttribute('aria-describedby');

        jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this2.element).trigger(_this2.constructor.Event.HIDDEN);

        if (_this2._popper !== null) {
          _this2._popper.destroy();
        }

        if (callback) {
          callback();
        }
      };

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).trigger(hideEvent);

      if (hideEvent.isDefaultPrevented()) {
        return;
      }

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass(CLASS_NAME_SHOW); // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support

      if ('ontouchstart' in document.documentElement) {
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(document.body).children().off('mouseover', null, (jquery__WEBPACK_IMPORTED_MODULE_1___default().noop));
      }

      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.tip).hasClass(CLASS_NAME_FADE)) {
        var transitionDuration = _util__WEBPACK_IMPORTED_MODULE_2__["default"].getTransitionDurationFromElement(tip);
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).one(_util__WEBPACK_IMPORTED_MODULE_2__["default"].TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
      } else {
        complete();
      }

      this._hoverState = '';
    }
  }, {
    key: "update",
    value: function update() {
      if (this._popper !== null) {
        this._popper.scheduleUpdate();
      }
    } // Protected

  }, {
    key: "isWithContent",
    value: function isWithContent() {
      return Boolean(this.getTitle());
    }
  }, {
    key: "addAttachmentClass",
    value: function addAttachmentClass(attachment) {
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement()).addClass("".concat(CLASS_PREFIX, "-").concat(attachment));
    }
  }, {
    key: "getTipElement",
    value: function getTipElement() {
      this.tip = this.tip || jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.config.template)[0];
      return this.tip;
    }
  }, {
    key: "setContent",
    value: function setContent() {
      var tip = this.getTipElement();
      this.setElementContent(jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());
      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass("".concat(CLASS_NAME_FADE, " ").concat(CLASS_NAME_SHOW));
    }
  }, {
    key: "setElementContent",
    value: function setElementContent($element, content) {
      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {
        // Content is a DOM node or a jQuery
        if (this.config.html) {
          if (!jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).parent().is($element)) {
            $element.empty().append(content);
          }
        } else {
          $element.text(jquery__WEBPACK_IMPORTED_MODULE_1___default()(content).text());
        }

        return;
      }

      if (this.config.html) {
        if (this.config.sanitize) {
          content = (0,_tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__.sanitizeHtml)(content, this.config.whiteList, this.config.sanitizeFn);
        }

        $element.html(content);
      } else {
        $element.text(content);
      }
    }
  }, {
    key: "getTitle",
    value: function getTitle() {
      var title = this.element.getAttribute('data-original-title');

      if (!title) {
        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
      }

      return title;
    } // Private

  }, {
    key: "_getPopperConfig",
    value: function _getPopperConfig(attachment) {
      var _this3 = this;

      var defaultBsConfig = {
        placement: attachment,
        modifiers: {
          offset: this._getOffset(),
          flip: {
            behavior: this.config.fallbackPlacement
          },
          arrow: {
            element: SELECTOR_ARROW
          },
          preventOverflow: {
            boundariesElement: this.config.boundary
          }
        },
        onCreate: function onCreate(data) {
          if (data.originalPlacement !== data.placement) {
            _this3._handlePopperPlacementChange(data);
          }
        },
        onUpdate: function onUpdate(data) {
          return _this3._handlePopperPlacementChange(data);
        }
      };
      return _objectSpread(_objectSpread({}, defaultBsConfig), this.config.popperConfig);
    }
  }, {
    key: "_getOffset",
    value: function _getOffset() {
      var _this4 = this;

      var offset = {};

      if (typeof this.config.offset === 'function') {
        offset.fn = function (data) {
          data.offsets = _objectSpread(_objectSpread({}, data.offsets), _this4.config.offset(data.offsets, _this4.element));
          return data;
        };
      } else {
        offset.offset = this.config.offset;
      }

      return offset;
    }
  }, {
    key: "_getContainer",
    value: function _getContainer() {
      if (this.config.container === false) {
        return document.body;
      }

      if (_util__WEBPACK_IMPORTED_MODULE_2__["default"].isElement(this.config.container)) {
        return jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.config.container);
      }

      return jquery__WEBPACK_IMPORTED_MODULE_1___default()(document).find(this.config.container);
    }
  }, {
    key: "_getAttachment",
    value: function _getAttachment(placement) {
      return AttachmentMap[placement.toUpperCase()];
    }
  }, {
    key: "_setListeners",
    value: function _setListeners() {
      var _this5 = this;

      var triggers = this.config.trigger.split(' ');
      triggers.forEach(function (trigger) {
        if (trigger === 'click') {
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {
            return _this5.toggle(event);
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;
          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;
          jquery__WEBPACK_IMPORTED_MODULE_1___default()(_this5.element).on(eventIn, _this5.config.selector, function (event) {
            return _this5._enter(event);
          }).on(eventOut, _this5.config.selector, function (event) {
            return _this5._leave(event);
          });
        }
      });

      this._hideModalHandler = function () {
        if (_this5.element) {
          _this5.hide();
        }
      };

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);

      if (this.config.selector) {
        this.config = _objectSpread(_objectSpread({}, this.config), {}, {
          trigger: 'manual',
          selector: ''
        });
      } else {
        this._fixTitle();
      }
    }
  }, {
    key: "_fixTitle",
    value: function _fixTitle() {
      var titleType = _typeof(this.element.getAttribute('data-original-title'));

      if (this.element.getAttribute('title') || titleType !== 'string') {
        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
        this.element.setAttribute('title', '');
      }
    }
  }, {
    key: "_enter",
    value: function _enter(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
      }

      if (jquery__WEBPACK_IMPORTED_MODULE_1___default()(context.getTipElement()).hasClass(CLASS_NAME_SHOW) || context._hoverState === HOVER_STATE_SHOW) {
        context._hoverState = HOVER_STATE_SHOW;
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_SHOW;

      if (!context.config.delay || !context.config.delay.show) {
        context.show();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_SHOW) {
          context.show();
        }
      }, context.config.delay.show);
    }
  }, {
    key: "_leave",
    value: function _leave(event, context) {
      var dataKey = this.constructor.DATA_KEY;
      context = context || jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey);

      if (!context) {
        context = new this.constructor(event.currentTarget, this._getDelegateConfig());
        jquery__WEBPACK_IMPORTED_MODULE_1___default()(event.currentTarget).data(dataKey, context);
      }

      if (event) {
        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;
      }

      if (context._isWithActiveTrigger()) {
        return;
      }

      clearTimeout(context._timeout);
      context._hoverState = HOVER_STATE_OUT;

      if (!context.config.delay || !context.config.delay.hide) {
        context.hide();
        return;
      }

      context._timeout = setTimeout(function () {
        if (context._hoverState === HOVER_STATE_OUT) {
          context.hide();
        }
      }, context.config.delay.hide);
    }
  }, {
    key: "_isWithActiveTrigger",
    value: function _isWithActiveTrigger() {
      for (var trigger in this._activeTrigger) {
        if (this._activeTrigger[trigger]) {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "_getConfig",
    value: function _getConfig(config) {
      var dataAttributes = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.element).data();
      Object.keys(dataAttributes).forEach(function (dataAttr) {
        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {
          delete dataAttributes[dataAttr];
        }
      });
      config = _objectSpread(_objectSpread(_objectSpread({}, this.constructor.Default), dataAttributes), _typeof(config) === 'object' && config ? config : {});

      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }

      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }

      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }

      _util__WEBPACK_IMPORTED_MODULE_2__["default"].typeCheckConfig(NAME, config, this.constructor.DefaultType);

      if (config.sanitize) {
        config.template = (0,_tools_sanitizer__WEBPACK_IMPORTED_MODULE_0__.sanitizeHtml)(config.template, config.whiteList, config.sanitizeFn);
      }

      return config;
    }
  }, {
    key: "_getDelegateConfig",
    value: function _getDelegateConfig() {
      var config = {};

      if (this.config) {
        for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
            config[key] = this.config[key];
          }
        }
      }

      return config;
    }
  }, {
    key: "_cleanTipClass",
    value: function _cleanTipClass() {
      var $tip = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this.getTipElement());
      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);

      if (tabClass !== null && tabClass.length) {
        $tip.removeClass(tabClass.join(''));
      }
    }
  }, {
    key: "_handlePopperPlacementChange",
    value: function _handlePopperPlacementChange(popperData) {
      this.tip = popperData.instance.popper;

      this._cleanTipClass();

      this.addAttachmentClass(this._getAttachment(popperData.placement));
    }
  }, {
    key: "_fixTransition",
    value: function _fixTransition() {
      var tip = this.getTipElement();
      var initConfigAnimation = this.config.animation;

      if (tip.getAttribute('x-placement') !== null) {
        return;
      }

      jquery__WEBPACK_IMPORTED_MODULE_1___default()(tip).removeClass(CLASS_NAME_FADE);
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = initConfigAnimation;
    } // Static

  }], [{
    key: "VERSION",
    get: function get() {
      return VERSION;
    }
  }, {
    key: "Default",
    get: function get() {
      return Default;
    }
  }, {
    key: "NAME",
    get: function get() {
      return NAME;
    }
  }, {
    key: "DATA_KEY",
    get: function get() {
      return DATA_KEY;
    }
  }, {
    key: "Event",
    get: function get() {
      return Event;
    }
  }, {
    key: "EVENT_KEY",
    get: function get() {
      return EVENT_KEY;
    }
  }, {
    key: "DefaultType",
    get: function get() {
      return DefaultType;
    }
  }, {
    key: "_jQueryInterface",
    value: function _jQueryInterface(config) {
      return this.each(function () {
        var $element = jquery__WEBPACK_IMPORTED_MODULE_1___default()(this);
        var data = $element.data(DATA_KEY);

        var _config = _typeof(config) === 'object' && config;

        if (!data && /dispose|hide/.test(config)) {
          return;
        }

        if (!data) {
          data = new Tooltip(this, _config);
          $element.data(DATA_KEY, data);
        }

        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError("No method named \"".concat(config, "\""));
          }

          data[config]();
        }
      });
    }
  }]);

  return Tooltip;
}();
/**
 * jQuery
 */


(jquery__WEBPACK_IMPORTED_MODULE_1___default().fn)[NAME] = Tooltip._jQueryInterface;
(jquery__WEBPACK_IMPORTED_MODULE_1___default().fn)[NAME].Constructor = Tooltip;

(jquery__WEBPACK_IMPORTED_MODULE_1___default().fn)[NAME].noConflict = function () {
  (jquery__WEBPACK_IMPORTED_MODULE_1___default().fn)[NAME] = JQUERY_NO_CONFLICT;
  return Tooltip._jQueryInterface;
};

/* harmony default export */ __webpack_exports__["default"] = (Tooltip);

/***/ }),

/***/ "./node_modules/bootstrap/js/src/util.js":
/*!***********************************************!*\
  !*** ./node_modules/bootstrap/js/src/util.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.6.1): util.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * Private TransitionEnd Helpers
 */

var TRANSITION_END = 'transitionend';
var MAX_UID = 1000000;
var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

function toType(obj) {
  if (obj === null || typeof obj === 'undefined') {
    return "".concat(obj);
  }

  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
}

function getSpecialTransitionEndEvent() {
  return {
    bindType: TRANSITION_END,
    delegateType: TRANSITION_END,
    handle: function handle(event) {
      if (jquery__WEBPACK_IMPORTED_MODULE_0___default()(event.target).is(this)) {
        return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
      }

      return undefined;
    }
  };
}

function transitionEndEmulator(duration) {
  var _this = this;

  var called = false;
  jquery__WEBPACK_IMPORTED_MODULE_0___default()(this).one(Util.TRANSITION_END, function () {
    called = true;
  });
  setTimeout(function () {
    if (!called) {
      Util.triggerTransitionEnd(_this);
    }
  }, duration);
  return this;
}

function setTransitionEndSupport() {
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().fn.emulateTransitionEnd) = transitionEndEmulator;
  (jquery__WEBPACK_IMPORTED_MODULE_0___default().event.special)[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
}
/**
 * Public Util API
 */


var Util = {
  TRANSITION_END: 'bsTransitionEnd',
  getUID: function getUID(prefix) {
    do {
      // eslint-disable-next-line no-bitwise
      prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
    } while (document.getElementById(prefix));

    return prefix;
  },
  getSelectorFromElement: function getSelectorFromElement(element) {
    var selector = element.getAttribute('data-target');

    if (!selector || selector === '#') {
      var hrefAttr = element.getAttribute('href');
      selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';
    }

    try {
      return document.querySelector(selector) ? selector : null;
    } catch (_) {
      return null;
    }
  },
  getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    } // Get transition-duration of the element


    var transitionDuration = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('transition-duration');
    var transitionDelay = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).css('transition-delay');
    var floatTransitionDuration = parseFloat(transitionDuration);
    var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    } // If multiple durations are defined, take the first


    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  },
  reflow: function reflow(element) {
    return element.offsetHeight;
  },
  triggerTransitionEnd: function triggerTransitionEnd(element) {
    jquery__WEBPACK_IMPORTED_MODULE_0___default()(element).trigger(TRANSITION_END);
  },
  supportsTransitionEnd: function supportsTransitionEnd() {
    return Boolean(TRANSITION_END);
  },
  isElement: function isElement(obj) {
    return (obj[0] || obj).nodeType;
  },
  typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
    for (var property in configTypes) {
      if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
        var expectedTypes = configTypes[property];
        var value = config[property];
        var valueType = value && Util.isElement(value) ? 'element' : toType(value);

        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new Error("".concat(componentName.toUpperCase(), ": ") + "Option \"".concat(property, "\" provided type \"").concat(valueType, "\" ") + "but expected type \"".concat(expectedTypes, "\"."));
        }
      }
    }
  },
  findShadowRoot: function findShadowRoot(element) {
    if (!document.documentElement.attachShadow) {
      return null;
    } // Can find the shadow root otherwise it'll return the document


    if (typeof element.getRootNode === 'function') {
      var root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }

    if (element instanceof ShadowRoot) {
      return element;
    } // when we don't find a shadow root


    if (!element.parentNode) {
      return null;
    }

    return Util.findShadowRoot(element.parentNode);
  },
  jQueryDetection: function jQueryDetection() {
    if (typeof (jquery__WEBPACK_IMPORTED_MODULE_0___default()) === 'undefined') {
      throw new TypeError('Bootstrap\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\'s JavaScript.');
    }

    var version = jquery__WEBPACK_IMPORTED_MODULE_0___default().fn.jquery.split(' ')[0].split('.');
    var minMajor = 1;
    var ltMajor = 2;
    var minMinor = 9;
    var minPatch = 1;
    var maxMajor = 4;

    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error('Bootstrap\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');
    }
  }
};
Util.jQueryDetection();
setTransitionEndSupport();
/* harmony default export */ __webpack_exports__["default"] = (Util);

/***/ }),

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
(function (global, factory) {
  ( false ? 0 : _typeof2(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);
})(this, function () {
  'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }
  /* Add properties to a lookup table */


  function addToSet(set, array, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;

    while (l--) {
      var element = array[l];

      if (typeof element === 'string') {
        var lcElement = transformCaseFunc(element);

        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }
  /* Shallow clone an object */


  function clone(object) {
    var newObject = create(null);
    var property;

    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }
  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */


  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);

      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.

  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.

  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  var text = freeze(['#text']);
  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */


  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    } // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.


    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';

    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html) {
          return html;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };
    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */


    DOMPurify.version = '2.4.0';
    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */

    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }

    var originalDocument = window.document;
    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');

      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var documentMode = {};

    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */

    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
        ERB_EXPR$1 = ERB_EXPR,
        DATA_ATTR$1 = DATA_ATTR,
        ARIA_ATTR$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    /* Allowed attribute names */

    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */

    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    var FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    var FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */

    var ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */

    var ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */

    var ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */

    var SAFE_FOR_TEMPLATES = false;
    /* Decide if document with <html>... should be returned */

    var WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */

    var SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */

    var FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */

    var RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */

    var RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */

    var RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */

    var SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (§7.3.3)
     *   - DOM Tree Accessors (§3.1.5)
     *   - Form Element Parent-Child Relations (§4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
     *   - HTMLCollection (§4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */

    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */

    var KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */

    var IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */

    var USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */

    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */

    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */

    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */

    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    /* Parsing of strict XHTML documents */

    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc;
    /* Keep a reference to config to pass to hooks */

    var CONFIG = null;
    /* Ideally, do not touch anything below this line */

    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity


    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */


      if (!cfg || _typeof(cfg) !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */


      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
        return x;
      } : stringToLowerCase;
      /* Set configuration parameters */

      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

      IN_PLACE = cfg.IN_PLACE || false; // Default false

      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */


      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];

        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */


      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */


      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      } // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.


      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.

    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */

    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */

    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.

      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        } // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.


        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        } // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.


        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        } // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points


        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        } // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.


        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        } // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace


        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      } // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.


      return false;
    };
    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */


    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });

      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };
    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */


    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */


    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc;
      var leadingWhitespace;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */

      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */


      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);

        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {// Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */


      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */


    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */


    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function');
    };
    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */


    var _isNode = function _isNode(object) {
      return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };
    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */


    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */


    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeElements', currentNode, null);
      /* Check if element is clobbered or can clobber */


      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Check if tagname contains Unicode */


      if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Now let's check the element's type and name */


      var tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */

      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */


      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Mitigate a problem with templates inside select */


      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Remove element if anything forbids its presence */


      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }
        /* Keep content except for bad-listed elements */


        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);

        return true;
      }
      /* Check whether element has a valid namespace */


      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Sanitize element content to be template-safe */


      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
        content = stringReplace(content, ERB_EXPR$1, ' ');

        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity


    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */


      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ;else if (!value) ;else {
        return false;
      }
      return true;
    };
    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */


    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */


    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;
      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */

      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;
        value = name === 'value' ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        /* Execute a hook if present */

        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */

        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */


        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */


        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */


        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);

          continue;
        }
        /* Sanitize attribute content to be template-safe */


        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
          value = stringReplace(value, ERB_EXPR$1, ' ');
        }
        /* Is `value` valid for this attribute? */


        var lcTag = transformCaseFunc(currentNode.nodeName);

        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */


        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Handle attributes that require Trusted Types */


        if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ;else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                value = trustedTypesPolicy.createHTML(value);
                break;

              case 'TrustedScriptURL':
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */


        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeAttributes', currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */


    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode;

      var shadowIterator = _createIterator(fragment);
      /* Execute a hook if present */


      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);
        /* Sanitize tags and elements */


        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        /* Deep shadow DOM detected */


        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(shadowNode);
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };
    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity


    DOMPurify.sanitize = function (dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var oldNode;
      var returnNode;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */

      IS_EMPTY_INPUT = !dirty;

      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */


      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();

          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }
      /* Check we can run. Otherwise fall back or ignore */


      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }
      /* Assign config vars */


      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */


      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */

      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);

          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);

        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */


        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */

        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */


      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */


      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */


      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }
        /* Sanitize tags and elements */


        if (_sanitizeElements(currentNode)) {
          continue;
        }
        /* Shadow DOM detected, sanitize it */


        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;
      /* If we sanitized `dirty` in-place, return it. */

      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */


      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */

      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */


      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */


    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);

      SET_CONFIG = true;
    };
    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */


    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */


    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */


    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     * @return {Function} removed(popped) hook
     */


    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */


    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */


    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();
  return purify;
});

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function (global, factory) {
  "use strict";

  if (( false ? 0 : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.0",
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    even: function even() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function odd() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function eq(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function globalEval(code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function each(obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function funescape(escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
          // Exclude object elements
          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function CHILD(type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function dir(elem, _dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var _siblings = function siblings(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to prevent firing
    _locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function fire() {
      // Enforce single-firing
      _locked = _locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      _fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (_locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function has(fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function disable() {
        _locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function disabled() {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function lock() {
        _locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function locked() {
        return !!_locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        if (!_locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function _catch(fn) {
          return _promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function
          /* fnDone, fnFail, fnProgress */
        pipe() {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function then(onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                _typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = _slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function updateFunc(i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function fn(elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function acceptData(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function set(owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function isAttached(elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function isAttached(elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (#13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function _on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = _handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function setup(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function trigger(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function _default(event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function handler(event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = _slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function setup() {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function trigger() {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur as it's already being fired
      // in leverageNative.
      _default: function _default() {
        return true;
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function _remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html;
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function getStyles(elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function swap(elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function reliableTrDimensions() {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var final = jQuery.cssProps[name] || vendorProps[name];

    if (final) {
      return final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function stopPropagationCallback(e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};

      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      _statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function statusCode(map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                _statusCode[code] = [_statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds


      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function textScript() {}
      },
      dataFilter: function dataFilter(response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          _callback = _callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, _callback2;

      return {
        send: function send(_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP

  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = _slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});

/***/ }),

/***/ "./node_modules/lazysizes/lazysizes.min.js":
/*!*************************************************!*\
  !*** ./node_modules/lazysizes/lazysizes.min.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! lazysizes - v0.6.1 - 2014-12-23
 Licensed MIT */
!function (a) {
  window.lazySizes = a(),  true && !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return window.lazySizes;
  }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}(function () {
  "use strict";

  function a(a, b) {
    var c;
    window.picturefill ? picturefill({
      reevaluate: !0,
      reparse: !0,
      elements: [a]
    }) : window.respimage && (b && (c = a[respimage._.ns], c && (c[b.srcset ? "srcset" : "src"] = void 0)), respimage({
      reparse: !0,
      elements: [a]
    }));
  }

  function b(a) {
    t++, a = d(a), y(a, K, !0), clearTimeout(B), B = setTimeout(K, 999);
  }

  function c() {
    m = 0, clearTimeout(l);
  }

  function d(b, c) {
    var d,
        e,
        g,
        h,
        j,
        k,
        l,
        m,
        p,
        q,
        r = z(b, "lazybeforeunveil", {
      force: !!c
    }),
        s = b.currentSrc || b.src;

    if (!r.defaultPrevented && (j = b.getAttribute(i.sizesAttr) || b.getAttribute("sizes"), j && ("auto" == j ? f(b, !0) : b.setAttribute("sizes", j), i.clearAttr && b.removeAttribute(i.sizesAttr)), l = b.getAttribute(i.srcsetAttr), k = b.getAttribute(i.srcAttr), (p = v.test(b.nodeName || "")) && (m = b.parentNode, q = u.test(m.nodeName || "")), i.addClasses && (n(b, i.loadingClass), y(b, N, !0)), l || k)) {
      if (q) for (d = m.getElementsByTagName("source"), e = 0, g = d.length; g > e; e++) {
        h = d[e].getAttribute(i.srcsetAttr), h && d[e].setAttribute("srcset", h);
      }
      l ? (b.setAttribute("srcset", l), i.clearAttr && b.removeAttribute(i.srcsetAttr)) : k && (b.setAttribute("src", k), i.clearAttr && b.removeAttribute(i.srcAttr));
    }

    return x(function () {
      o(b, i.lazyClass), "auto" == j && n(b, i.autosizesClass), (l || j) && a(b, {
        srcset: l,
        src: k
      }), b.lazyload && (b.lazyload = 0), !r.details.stopSwitchClass && i.addClasses && (!p || !l && !k || b.complete && s == (b.currentSrc || b.src)) && N({
        target: b
      });
    }), b;
  }

  function e() {
    k = 0, clearTimeout(j);
  }

  function f(b, c) {
    var d, e, f, g, h, j, k, l;

    if (g = b.parentNode) {
      if (d = g.offsetWidth, e = b.offsetWidth, f = e > d ? e : d, !f && !b._lazysizesWidth) for (; g && g != r.body && !f;) {
        f = g.offsetWidth, g = g.parentNode;
      }

      if (l = z(b, "lazybeforesizes", {
        width: f,
        dataAttr: !!c
      }), !l.defaultPrevented && (f = l.details.width, f && f !== b._lazysizesWidth && (!i.onlyLargerSizes || !b._lazysizesWidth || b._lazysizesWidth < f))) {
        if (b._lazysizesWidth = f, f += "px", b.setAttribute("sizes", f), u.test(g.nodeName || "")) for (h = g.getElementsByTagName("source"), j = 0, k = h.length; k > j; j++) {
          h[j].setAttribute("sizes", f);
        }
        l.details.dataAttr || a(b);
      }
    }
  }

  if (Date.now && window.document.getElementsByClassName) {
    var g,
        h,
        i,
        j,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r = window.document,
        s = r.documentElement,
        t = 0,
        u = /^picture$/i,
        v = /^img$/i,
        w = 10,
        x = window.setImmediate || window.setTimeout,
        y = function y(a, b, c) {
      var d = c ? "addEventListener" : "removeEventListener";
      c && y(a, b), a[d]("load", b, !1), a[d]("error", b, !1), a[d]("lazyincluded", b, !1);
    },
        z = function z(a, b, c) {
      var d = r.createEvent("Event");
      return d.initEvent(b, !0, !0), d.details = c || {}, a.dispatchEvent(d), d;
    };

    n = function n(a, b) {
      p(a, b) || (a.className += " " + b);
    }, o = function o(a, b) {
      var c;
      p(a, b) && (c = new RegExp("(\\s|^)" + b + "(\\s|$)"), a.className = a.className.replace(c, " "));
    }, p = function p(a, b) {
      return a.className.match(new RegExp("(\\s|^)" + b + "(\\s|$)"));
    };

    var A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
        I,
        J = Date.now(),
        K = function K(a) {
      t--, clearTimeout(B), a && a.target && y(a.target, K), (!a || 0 > t || !a.target) && (t = 0);
    },
        L = function () {
      var a,
          b,
          d = function d() {
        b = !1;
      },
          e = function e() {
        clearTimeout(a), c(), M(), setTimeout(d);
      };

      return {
        debounce: function debounce() {
          clearTimeout(a), b = !0, a = setTimeout(e, 66);
        },
        throttled: function throttled() {
          b || (b = !0, clearTimeout(a), a = setTimeout(e, 66));
        }
      };
    }(),
        M = function M() {
      var a, c, e;

      if (A = g.length, J = Date.now(), A) {
        for (C = window.innerWidth + w, D = window.innerHeight + w, I = -1 * w; A > m; m++) {
          if (a = g[m].getBoundingClientRect(), (H = a.bottom) >= I && (E = a.top) <= D && (G = a.right) >= I && (F = a.left) <= C && (H || G || F || E) && (!q || "hidden" != getComputedStyle(g[m], null).visibility)) d(g[m]), e = !0;else {
            if (A - 1 > m && Date.now() - J > 9) {
              c = !1, l = setTimeout(M, 4);
              break;
            }

            !e && q && !c && i.preloadAfterLoad && 2 > t && (H || G || F || E || "auto" != g[m].getAttribute(i.sizesAttr)) && (c = g[m]);
          }
        }

        c && !e && b(c);
      }
    },
        N = function N(a) {
      n(a.target, a.target.getAttribute("data-loadedclass") || i.loadedClass), o(a.target, i.loadingClass), y(a.target, N);
    },
        O = function () {
      var a,
          b = function b() {
        clearTimeout(a), e(), P();
      };

      return function () {
        clearTimeout(a), clearTimeout(j), a = setTimeout(b, 99);
      };
    }(),
        P = function P() {
      var a,
          b,
          c,
          d = h.length;
      if (d) for (b = Date.now(), c = k || 0, a = c + 3, e(); d > c; c++) {
        if (f(h[c]), c > a && d - 1 > c && Date.now() - b > 9) {
          k = c + 1, j = setTimeout(P, 4);
          break;
        }
      }
    },
        Q = function Q() {
      w = i.preloadAfterLoad ? 60 : 280, r.addEventListener("load", L.throttled, !0), q = !0;
    },
        R = function R() {
      i.mutation && (window.MutationObserver ? new MutationObserver(L.throttled).observe(s, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }) : (s.addEventListener("DOMNodeInserted", L.throttled, !0), s.addEventListener("DOMAttrModified", L.throttled, !0))), i.hover && r.addEventListener("mouseover", L.throttled, !0), r.addEventListener("focus", L.throttled, !0), window.addEventListener("hashchange", L.throttled, !0), "onmozfullscreenchange" in s ? window.addEventListener("mozfullscreenchange", L.throttled, !0) : "onwebkitfullscreenchange" in s ? window.addEventListener("webkitfullscreenchange", L.throttled, !0) : window.addEventListener("fullscreenchange", L.throttled, !0), i.cssanimation && (r.addEventListener("animationstart", L.throttled, !0), r.addEventListener("transitionstart", L.throttled, !0));
    };

    return i = window.lazySizesConfig || {}, function () {
      var a,
          b = {
        mutation: !0,
        hover: !0,
        cssanimation: !0,
        lazyClass: "lazyload",
        loadedClass: "lazyloaded",
        loadingClass: "lazyloading",
        scroll: !0,
        autosizesClass: "lazyautosizes",
        srcAttr: "data-src",
        srcsetAttr: "data-srcset",
        sizesAttr: "data-sizes",
        preloadAfterLoad: !0,
        onlyLargerSizes: !0
      };

      for (a in b) {
        a in i || (i[a] = b[a]);
      }
    }(), setTimeout(function () {
      g = r.getElementsByClassName(i.lazyClass), h = r.getElementsByClassName(i.autosizesClass), i.scroll && addEventListener("scroll", L.throttled, !0), addEventListener("resize", L.debounce, !1), addEventListener("resize", O, !1), /^i|^loade|c/.test(r.readyState) ? R() : r.addEventListener("DOMContentLoaded", R, !1), "complete" == r.readyState ? Q() : (addEventListener("load", Q, !1), r.addEventListener("readystatechange", L.throttled, !1)), L.throttled(), o(s, "no-js");
    }), {
      cfg: i,
      updateAllSizes: O,
      updateAllLazy: function updateAllLazy(a) {
        a ? (c(), M()) : L.throttled();
      },
      unveilLazy: function unveilLazy(a) {
        p(a, i.lazyClass) && d(a);
      },
      updateSizes: f,
      updatePolyfill: a,
      aC: n,
      rC: o,
      hC: p,
      fire: z
    };
  }
});

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/** Built-in value references. */


var _Symbol = root.Symbol;
module.exports = _Symbol;

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");
/** `Object#toString` result references. */


var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */

function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }

  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}

module.exports = baseGetTag;

/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");
/** Used to match leading whitespace. */


var reTrimStart = /^\s+/;
/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */

function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
}

module.exports = baseTrim;

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Detect free variable `global` from Node.js. */
var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
module.exports = freeGlobal;

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var _Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");
/** Used for built-in method references. */


var objectProto = Object.prototype;
/** Used to check objects for own properties. */

var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/** Built-in value references. */

var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */

function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);

  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }

  return result;
}

module.exports = getRawTag;

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ (function(module) {

/** Used for built-in method references. */
var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var nativeObjectToString = objectProto.toString;
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */

function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");
/** Detect free variable `self`. */


var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
module.exports = root;

/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ (function(module) {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;
/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */

function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}

  return index;
}

module.exports = trimmedEndIndex;

/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");
/** Error message constants. */


var FUNC_ERROR_TEXT = 'Expected a function';
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */

function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = _typeof(value);

  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ (function(module) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && _typeof(value) == 'object';
}

module.exports = isObjectLike;

/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");
/** `Object#toString` result references. */


var symbolTag = '[object Symbol]';
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */

function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
}

module.exports = isSymbol;

/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */


var now = function now() {
  return root.Date.now();
};

module.exports = now;

/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");
/** Used as references for various `Number` constants. */


var NAN = 0 / 0;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */

function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = toNumber;

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
/* harmony default export */ __webpack_exports__["default"] = (Popper);

/***/ }),

/***/ "./node_modules/slick-carousel/slick/slick.min.js":
/*!********************************************************!*\
  !*** ./node_modules/slick-carousel/slick/slick.min.js ***!
  \********************************************************/
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (i) {
  "use strict";

   true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (i),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
}(function (i) {
  "use strict";

  var e = window.Slick || {};
  (e = function () {
    var e = 0;
    return function (t, o) {
      var s,
          n = this;
      n.defaults = {
        accessibility: !0,
        adaptiveHeight: !1,
        appendArrows: i(t),
        appendDots: i(t),
        arrows: !0,
        asNavFor: null,
        prevArrow: '<button class="slick-prev" aria-label="Previous" type="button">Previous</button>',
        nextArrow: '<button class="slick-next" aria-label="Next" type="button">Next</button>',
        autoplay: !1,
        autoplaySpeed: 3e3,
        centerMode: !1,
        centerPadding: "50px",
        cssEase: "ease",
        customPaging: function customPaging(e, t) {
          return i('<button type="button" />').text(t + 1);
        },
        dots: !1,
        dotsClass: "slick-dots",
        draggable: !0,
        easing: "linear",
        edgeFriction: .35,
        fade: !1,
        focusOnSelect: !1,
        focusOnChange: !1,
        infinite: !0,
        initialSlide: 0,
        lazyLoad: "ondemand",
        mobileFirst: !1,
        pauseOnHover: !0,
        pauseOnFocus: !0,
        pauseOnDotsHover: !1,
        respondTo: "window",
        responsive: null,
        rows: 1,
        rtl: !1,
        slide: "",
        slidesPerRow: 1,
        slidesToShow: 1,
        slidesToScroll: 1,
        speed: 500,
        swipe: !0,
        swipeToSlide: !1,
        touchMove: !0,
        touchThreshold: 5,
        useCSS: !0,
        useTransform: !0,
        variableWidth: !1,
        vertical: !1,
        verticalSwiping: !1,
        waitForAnimate: !0,
        zIndex: 1e3
      }, n.initials = {
        animating: !1,
        dragging: !1,
        autoPlayTimer: null,
        currentDirection: 0,
        currentLeft: null,
        currentSlide: 0,
        direction: 1,
        $dots: null,
        listWidth: null,
        listHeight: null,
        loadIndex: 0,
        $nextArrow: null,
        $prevArrow: null,
        scrolling: !1,
        slideCount: null,
        slideWidth: null,
        $slideTrack: null,
        $slides: null,
        sliding: !1,
        slideOffset: 0,
        swipeLeft: null,
        swiping: !1,
        $list: null,
        touchObject: {},
        transformsEnabled: !1,
        unslicked: !1
      }, i.extend(n, n.initials), n.activeBreakpoint = null, n.animType = null, n.animProp = null, n.breakpoints = [], n.breakpointSettings = [], n.cssTransitions = !1, n.focussed = !1, n.interrupted = !1, n.hidden = "hidden", n.paused = !0, n.positionProp = null, n.respondTo = null, n.rowCount = 1, n.shouldClick = !0, n.$slider = i(t), n.$slidesCache = null, n.transformType = null, n.transitionType = null, n.visibilityChange = "visibilitychange", n.windowWidth = 0, n.windowTimer = null, s = i(t).data("slick") || {}, n.options = i.extend({}, n.defaults, o, s), n.currentSlide = n.options.initialSlide, n.originalSettings = n.options, void 0 !== document.mozHidden ? (n.hidden = "mozHidden", n.visibilityChange = "mozvisibilitychange") : void 0 !== document.webkitHidden && (n.hidden = "webkitHidden", n.visibilityChange = "webkitvisibilitychange"), n.autoPlay = i.proxy(n.autoPlay, n), n.autoPlayClear = i.proxy(n.autoPlayClear, n), n.autoPlayIterator = i.proxy(n.autoPlayIterator, n), n.changeSlide = i.proxy(n.changeSlide, n), n.clickHandler = i.proxy(n.clickHandler, n), n.selectHandler = i.proxy(n.selectHandler, n), n.setPosition = i.proxy(n.setPosition, n), n.swipeHandler = i.proxy(n.swipeHandler, n), n.dragHandler = i.proxy(n.dragHandler, n), n.keyHandler = i.proxy(n.keyHandler, n), n.instanceUid = e++, n.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/, n.registerBreakpoints(), n.init(!0);
    };
  }()).prototype.activateADA = function () {
    this.$slideTrack.find(".slick-active").attr({
      "aria-hidden": "false"
    }).find("a, input, button, select").attr({
      tabindex: "0"
    });
  }, e.prototype.addSlide = e.prototype.slickAdd = function (e, t, o) {
    var s = this;
    if ("boolean" == typeof t) o = t, t = null;else if (t < 0 || t >= s.slideCount) return !1;
    s.unload(), "number" == typeof t ? 0 === t && 0 === s.$slides.length ? i(e).appendTo(s.$slideTrack) : o ? i(e).insertBefore(s.$slides.eq(t)) : i(e).insertAfter(s.$slides.eq(t)) : !0 === o ? i(e).prependTo(s.$slideTrack) : i(e).appendTo(s.$slideTrack), s.$slides = s.$slideTrack.children(this.options.slide), s.$slideTrack.children(this.options.slide).detach(), s.$slideTrack.append(s.$slides), s.$slides.each(function (e, t) {
      i(t).attr("data-slick-index", e);
    }), s.$slidesCache = s.$slides, s.reinit();
  }, e.prototype.animateHeight = function () {
    var i = this;

    if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
      i.$list.animate({
        height: e
      }, i.options.speed);
    }
  }, e.prototype.animateSlide = function (e, t) {
    var o = {},
        s = this;
    s.animateHeight(), !0 === s.options.rtl && !1 === s.options.vertical && (e = -e), !1 === s.transformsEnabled ? !1 === s.options.vertical ? s.$slideTrack.animate({
      left: e
    }, s.options.speed, s.options.easing, t) : s.$slideTrack.animate({
      top: e
    }, s.options.speed, s.options.easing, t) : !1 === s.cssTransitions ? (!0 === s.options.rtl && (s.currentLeft = -s.currentLeft), i({
      animStart: s.currentLeft
    }).animate({
      animStart: e
    }, {
      duration: s.options.speed,
      easing: s.options.easing,
      step: function step(i) {
        i = Math.ceil(i), !1 === s.options.vertical ? (o[s.animType] = "translate(" + i + "px, 0px)", s.$slideTrack.css(o)) : (o[s.animType] = "translate(0px," + i + "px)", s.$slideTrack.css(o));
      },
      complete: function complete() {
        t && t.call();
      }
    })) : (s.applyTransition(), e = Math.ceil(e), !1 === s.options.vertical ? o[s.animType] = "translate3d(" + e + "px, 0px, 0px)" : o[s.animType] = "translate3d(0px," + e + "px, 0px)", s.$slideTrack.css(o), t && setTimeout(function () {
      s.disableTransition(), t.call();
    }, s.options.speed));
  }, e.prototype.getNavTarget = function () {
    var e = this,
        t = e.options.asNavFor;
    return t && null !== t && (t = i(t).not(e.$slider)), t;
  }, e.prototype.asNavFor = function (e) {
    var t = this.getNavTarget();
    null !== t && "object" == _typeof(t) && t.each(function () {
      var t = i(this).slick("getSlick");
      t.unslicked || t.slideHandler(e, !0);
    });
  }, e.prototype.applyTransition = function (i) {
    var e = this,
        t = {};
    !1 === e.options.fade ? t[e.transitionType] = e.transformType + " " + e.options.speed + "ms " + e.options.cssEase : t[e.transitionType] = "opacity " + e.options.speed + "ms " + e.options.cssEase, !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);
  }, e.prototype.autoPlay = function () {
    var i = this;
    i.autoPlayClear(), i.slideCount > i.options.slidesToShow && (i.autoPlayTimer = setInterval(i.autoPlayIterator, i.options.autoplaySpeed));
  }, e.prototype.autoPlayClear = function () {
    var i = this;
    i.autoPlayTimer && clearInterval(i.autoPlayTimer);
  }, e.prototype.autoPlayIterator = function () {
    var i = this,
        e = i.currentSlide + i.options.slidesToScroll;
    i.paused || i.interrupted || i.focussed || (!1 === i.options.infinite && (1 === i.direction && i.currentSlide + 1 === i.slideCount - 1 ? i.direction = 0 : 0 === i.direction && (e = i.currentSlide - i.options.slidesToScroll, i.currentSlide - 1 == 0 && (i.direction = 1))), i.slideHandler(e));
  }, e.prototype.buildArrows = function () {
    var e = this;
    !0 === e.options.arrows && (e.$prevArrow = i(e.options.prevArrow).addClass("slick-arrow"), e.$nextArrow = i(e.options.nextArrow).addClass("slick-arrow"), e.slideCount > e.options.slidesToShow ? (e.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex"), e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.prependTo(e.options.appendArrows), e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.appendTo(e.options.appendArrows), !0 !== e.options.infinite && e.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true")) : e.$prevArrow.add(e.$nextArrow).addClass("slick-hidden").attr({
      "aria-disabled": "true",
      tabindex: "-1"
    }));
  }, e.prototype.buildDots = function () {
    var e,
        t,
        o = this;

    if (!0 === o.options.dots) {
      for (o.$slider.addClass("slick-dotted"), t = i("<ul />").addClass(o.options.dotsClass), e = 0; e <= o.getDotCount(); e += 1) {
        t.append(i("<li />").append(o.options.customPaging.call(this, o, e)));
      }

      o.$dots = t.appendTo(o.options.appendDots), o.$dots.find("li").first().addClass("slick-active");
    }
  }, e.prototype.buildOut = function () {
    var e = this;
    e.$slides = e.$slider.children(e.options.slide + ":not(.slick-cloned)").addClass("slick-slide"), e.slideCount = e.$slides.length, e.$slides.each(function (e, t) {
      i(t).attr("data-slick-index", e).data("originalStyling", i(t).attr("style") || "");
    }), e.$slider.addClass("slick-slider"), e.$slideTrack = 0 === e.slideCount ? i('<div class="slick-track"/>').appendTo(e.$slider) : e.$slides.wrapAll('<div class="slick-track"/>').parent(), e.$list = e.$slideTrack.wrap('<div class="slick-list"/>').parent(), e.$slideTrack.css("opacity", 0), !0 !== e.options.centerMode && !0 !== e.options.swipeToSlide || (e.options.slidesToScroll = 1), i("img[data-lazy]", e.$slider).not("[src]").addClass("slick-loading"), e.setupInfinite(), e.buildArrows(), e.buildDots(), e.updateDots(), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), !0 === e.options.draggable && e.$list.addClass("draggable");
  }, e.prototype.buildRows = function () {
    var i,
        e,
        t,
        o,
        s,
        n,
        r,
        l = this;

    if (o = document.createDocumentFragment(), n = l.$slider.children(), l.options.rows > 1) {
      for (r = l.options.slidesPerRow * l.options.rows, s = Math.ceil(n.length / r), i = 0; i < s; i++) {
        var d = document.createElement("div");

        for (e = 0; e < l.options.rows; e++) {
          var a = document.createElement("div");

          for (t = 0; t < l.options.slidesPerRow; t++) {
            var c = i * r + (e * l.options.slidesPerRow + t);
            n.get(c) && a.appendChild(n.get(c));
          }

          d.appendChild(a);
        }

        o.appendChild(d);
      }

      l.$slider.empty().append(o), l.$slider.children().children().children().css({
        width: 100 / l.options.slidesPerRow + "%",
        display: "inline-block"
      });
    }
  }, e.prototype.checkResponsive = function (e, t) {
    var o,
        s,
        n,
        r = this,
        l = !1,
        d = r.$slider.width(),
        a = window.innerWidth || i(window).width();

    if ("window" === r.respondTo ? n = a : "slider" === r.respondTo ? n = d : "min" === r.respondTo && (n = Math.min(a, d)), r.options.responsive && r.options.responsive.length && null !== r.options.responsive) {
      s = null;

      for (o in r.breakpoints) {
        r.breakpoints.hasOwnProperty(o) && (!1 === r.originalSettings.mobileFirst ? n < r.breakpoints[o] && (s = r.breakpoints[o]) : n > r.breakpoints[o] && (s = r.breakpoints[o]));
      }

      null !== s ? null !== r.activeBreakpoint ? (s !== r.activeBreakpoint || t) && (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : (r.activeBreakpoint = s, "unslick" === r.breakpointSettings[s] ? r.unslick(s) : (r.options = i.extend({}, r.originalSettings, r.breakpointSettings[s]), !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e)), l = s) : null !== r.activeBreakpoint && (r.activeBreakpoint = null, r.options = r.originalSettings, !0 === e && (r.currentSlide = r.options.initialSlide), r.refresh(e), l = s), e || !1 === l || r.$slider.trigger("breakpoint", [r, l]);
    }
  }, e.prototype.changeSlide = function (e, t) {
    var o,
        s,
        n,
        r = this,
        l = i(e.currentTarget);

    switch (l.is("a") && e.preventDefault(), l.is("li") || (l = l.closest("li")), n = r.slideCount % r.options.slidesToScroll != 0, o = n ? 0 : (r.slideCount - r.currentSlide) % r.options.slidesToScroll, e.data.message) {
      case "previous":
        s = 0 === o ? r.options.slidesToScroll : r.options.slidesToShow - o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide - s, !1, t);
        break;

      case "next":
        s = 0 === o ? r.options.slidesToScroll : o, r.slideCount > r.options.slidesToShow && r.slideHandler(r.currentSlide + s, !1, t);
        break;

      case "index":
        var d = 0 === e.data.index ? 0 : e.data.index || l.index() * r.options.slidesToScroll;
        r.slideHandler(r.checkNavigable(d), !1, t), l.children().trigger("focus");
        break;

      default:
        return;
    }
  }, e.prototype.checkNavigable = function (i) {
    var e, t;
    if (e = this.getNavigableIndexes(), t = 0, i > e[e.length - 1]) i = e[e.length - 1];else for (var o in e) {
      if (i < e[o]) {
        i = t;
        break;
      }

      t = e[o];
    }
    return i;
  }, e.prototype.cleanUpEvents = function () {
    var e = this;
    e.options.dots && null !== e.$dots && (i("li", e.$dots).off("click.slick", e.changeSlide).off("mouseenter.slick", i.proxy(e.interrupt, e, !0)).off("mouseleave.slick", i.proxy(e.interrupt, e, !1)), !0 === e.options.accessibility && e.$dots.off("keydown.slick", e.keyHandler)), e.$slider.off("focus.slick blur.slick"), !0 === e.options.arrows && e.slideCount > e.options.slidesToShow && (e.$prevArrow && e.$prevArrow.off("click.slick", e.changeSlide), e.$nextArrow && e.$nextArrow.off("click.slick", e.changeSlide), !0 === e.options.accessibility && (e.$prevArrow && e.$prevArrow.off("keydown.slick", e.keyHandler), e.$nextArrow && e.$nextArrow.off("keydown.slick", e.keyHandler))), e.$list.off("touchstart.slick mousedown.slick", e.swipeHandler), e.$list.off("touchmove.slick mousemove.slick", e.swipeHandler), e.$list.off("touchend.slick mouseup.slick", e.swipeHandler), e.$list.off("touchcancel.slick mouseleave.slick", e.swipeHandler), e.$list.off("click.slick", e.clickHandler), i(document).off(e.visibilityChange, e.visibility), e.cleanUpSlideEvents(), !0 === e.options.accessibility && e.$list.off("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().off("click.slick", e.selectHandler), i(window).off("orientationchange.slick.slick-" + e.instanceUid, e.orientationChange), i(window).off("resize.slick.slick-" + e.instanceUid, e.resize), i("[draggable!=true]", e.$slideTrack).off("dragstart", e.preventDefault), i(window).off("load.slick.slick-" + e.instanceUid, e.setPosition);
  }, e.prototype.cleanUpSlideEvents = function () {
    var e = this;
    e.$list.off("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.off("mouseleave.slick", i.proxy(e.interrupt, e, !1));
  }, e.prototype.cleanUpRows = function () {
    var i,
        e = this;
    e.options.rows > 1 && ((i = e.$slides.children().children()).removeAttr("style"), e.$slider.empty().append(i));
  }, e.prototype.clickHandler = function (i) {
    !1 === this.shouldClick && (i.stopImmediatePropagation(), i.stopPropagation(), i.preventDefault());
  }, e.prototype.destroy = function (e) {
    var t = this;
    t.autoPlayClear(), t.touchObject = {}, t.cleanUpEvents(), i(".slick-cloned", t.$slider).detach(), t.$dots && t.$dots.remove(), t.$prevArrow && t.$prevArrow.length && (t.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.prevArrow) && t.$prevArrow.remove()), t.$nextArrow && t.$nextArrow.length && (t.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", ""), t.htmlExpr.test(t.options.nextArrow) && t.$nextArrow.remove()), t.$slides && (t.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function () {
      i(this).attr("style", i(this).data("originalStyling"));
    }), t.$slideTrack.children(this.options.slide).detach(), t.$slideTrack.detach(), t.$list.detach(), t.$slider.append(t.$slides)), t.cleanUpRows(), t.$slider.removeClass("slick-slider"), t.$slider.removeClass("slick-initialized"), t.$slider.removeClass("slick-dotted"), t.unslicked = !0, e || t.$slider.trigger("destroy", [t]);
  }, e.prototype.disableTransition = function (i) {
    var e = this,
        t = {};
    t[e.transitionType] = "", !1 === e.options.fade ? e.$slideTrack.css(t) : e.$slides.eq(i).css(t);
  }, e.prototype.fadeSlide = function (i, e) {
    var t = this;
    !1 === t.cssTransitions ? (t.$slides.eq(i).css({
      zIndex: t.options.zIndex
    }), t.$slides.eq(i).animate({
      opacity: 1
    }, t.options.speed, t.options.easing, e)) : (t.applyTransition(i), t.$slides.eq(i).css({
      opacity: 1,
      zIndex: t.options.zIndex
    }), e && setTimeout(function () {
      t.disableTransition(i), e.call();
    }, t.options.speed));
  }, e.prototype.fadeSlideOut = function (i) {
    var e = this;
    !1 === e.cssTransitions ? e.$slides.eq(i).animate({
      opacity: 0,
      zIndex: e.options.zIndex - 2
    }, e.options.speed, e.options.easing) : (e.applyTransition(i), e.$slides.eq(i).css({
      opacity: 0,
      zIndex: e.options.zIndex - 2
    }));
  }, e.prototype.filterSlides = e.prototype.slickFilter = function (i) {
    var e = this;
    null !== i && (e.$slidesCache = e.$slides, e.unload(), e.$slideTrack.children(this.options.slide).detach(), e.$slidesCache.filter(i).appendTo(e.$slideTrack), e.reinit());
  }, e.prototype.focusHandler = function () {
    var e = this;
    e.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*", function (t) {
      t.stopImmediatePropagation();
      var o = i(this);
      setTimeout(function () {
        e.options.pauseOnFocus && (e.focussed = o.is(":focus"), e.autoPlay());
      }, 0);
    });
  }, e.prototype.getCurrent = e.prototype.slickCurrentSlide = function () {
    return this.currentSlide;
  }, e.prototype.getDotCount = function () {
    var i = this,
        e = 0,
        t = 0,
        o = 0;
    if (!0 === i.options.infinite) {
      if (i.slideCount <= i.options.slidesToShow) ++o;else for (; e < i.slideCount;) {
        ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
      }
    } else if (!0 === i.options.centerMode) o = i.slideCount;else if (i.options.asNavFor) for (; e < i.slideCount;) {
      ++o, e = t + i.options.slidesToScroll, t += i.options.slidesToScroll <= i.options.slidesToShow ? i.options.slidesToScroll : i.options.slidesToShow;
    } else o = 1 + Math.ceil((i.slideCount - i.options.slidesToShow) / i.options.slidesToScroll);
    return o - 1;
  }, e.prototype.getLeft = function (i) {
    var e,
        t,
        o,
        s,
        n = this,
        r = 0;
    return n.slideOffset = 0, t = n.$slides.first().outerHeight(!0), !0 === n.options.infinite ? (n.slideCount > n.options.slidesToShow && (n.slideOffset = n.slideWidth * n.options.slidesToShow * -1, s = -1, !0 === n.options.vertical && !0 === n.options.centerMode && (2 === n.options.slidesToShow ? s = -1.5 : 1 === n.options.slidesToShow && (s = -2)), r = t * n.options.slidesToShow * s), n.slideCount % n.options.slidesToScroll != 0 && i + n.options.slidesToScroll > n.slideCount && n.slideCount > n.options.slidesToShow && (i > n.slideCount ? (n.slideOffset = (n.options.slidesToShow - (i - n.slideCount)) * n.slideWidth * -1, r = (n.options.slidesToShow - (i - n.slideCount)) * t * -1) : (n.slideOffset = n.slideCount % n.options.slidesToScroll * n.slideWidth * -1, r = n.slideCount % n.options.slidesToScroll * t * -1))) : i + n.options.slidesToShow > n.slideCount && (n.slideOffset = (i + n.options.slidesToShow - n.slideCount) * n.slideWidth, r = (i + n.options.slidesToShow - n.slideCount) * t), n.slideCount <= n.options.slidesToShow && (n.slideOffset = 0, r = 0), !0 === n.options.centerMode && n.slideCount <= n.options.slidesToShow ? n.slideOffset = n.slideWidth * Math.floor(n.options.slidesToShow) / 2 - n.slideWidth * n.slideCount / 2 : !0 === n.options.centerMode && !0 === n.options.infinite ? n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2) - n.slideWidth : !0 === n.options.centerMode && (n.slideOffset = 0, n.slideOffset += n.slideWidth * Math.floor(n.options.slidesToShow / 2)), e = !1 === n.options.vertical ? i * n.slideWidth * -1 + n.slideOffset : i * t * -1 + r, !0 === n.options.variableWidth && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, !0 === n.options.centerMode && (o = n.slideCount <= n.options.slidesToShow || !1 === n.options.infinite ? n.$slideTrack.children(".slick-slide").eq(i) : n.$slideTrack.children(".slick-slide").eq(i + n.options.slidesToShow + 1), e = !0 === n.options.rtl ? o[0] ? -1 * (n.$slideTrack.width() - o[0].offsetLeft - o.width()) : 0 : o[0] ? -1 * o[0].offsetLeft : 0, e += (n.$list.width() - o.outerWidth()) / 2)), e;
  }, e.prototype.getOption = e.prototype.slickGetOption = function (i) {
    return this.options[i];
  }, e.prototype.getNavigableIndexes = function () {
    var i,
        e = this,
        t = 0,
        o = 0,
        s = [];

    for (!1 === e.options.infinite ? i = e.slideCount : (t = -1 * e.options.slidesToScroll, o = -1 * e.options.slidesToScroll, i = 2 * e.slideCount); t < i;) {
      s.push(t), t = o + e.options.slidesToScroll, o += e.options.slidesToScroll <= e.options.slidesToShow ? e.options.slidesToScroll : e.options.slidesToShow;
    }

    return s;
  }, e.prototype.getSlick = function () {
    return this;
  }, e.prototype.getSlideCount = function () {
    var e,
        t,
        o = this;
    return t = !0 === o.options.centerMode ? o.slideWidth * Math.floor(o.options.slidesToShow / 2) : 0, !0 === o.options.swipeToSlide ? (o.$slideTrack.find(".slick-slide").each(function (s, n) {
      if (n.offsetLeft - t + i(n).outerWidth() / 2 > -1 * o.swipeLeft) return e = n, !1;
    }), Math.abs(i(e).attr("data-slick-index") - o.currentSlide) || 1) : o.options.slidesToScroll;
  }, e.prototype.goTo = e.prototype.slickGoTo = function (i, e) {
    this.changeSlide({
      data: {
        message: "index",
        index: parseInt(i)
      }
    }, e);
  }, e.prototype.init = function (e) {
    var t = this;
    i(t.$slider).hasClass("slick-initialized") || (i(t.$slider).addClass("slick-initialized"), t.buildRows(), t.buildOut(), t.setProps(), t.startLoad(), t.loadSlider(), t.initializeEvents(), t.updateArrows(), t.updateDots(), t.checkResponsive(!0), t.focusHandler()), e && t.$slider.trigger("init", [t]), !0 === t.options.accessibility && t.initADA(), t.options.autoplay && (t.paused = !1, t.autoPlay());
  }, e.prototype.initADA = function () {
    var e = this,
        t = Math.ceil(e.slideCount / e.options.slidesToShow),
        o = e.getNavigableIndexes().filter(function (i) {
      return i >= 0 && i < e.slideCount;
    });
    e.$slides.add(e.$slideTrack.find(".slick-cloned")).attr({
      "aria-hidden": "true",
      tabindex: "-1"
    }).find("a, input, button, select").attr({
      tabindex: "-1"
    }), null !== e.$dots && (e.$slides.not(e.$slideTrack.find(".slick-cloned")).each(function (t) {
      var s = o.indexOf(t);
      i(this).attr({
        role: "tabpanel",
        id: "slick-slide" + e.instanceUid + t,
        tabindex: -1
      }), -1 !== s && i(this).attr({
        "aria-describedby": "slick-slide-control" + e.instanceUid + s
      });
    }), e.$dots.attr("role", "tablist").find("li").each(function (s) {
      var n = o[s];
      i(this).attr({
        role: "presentation"
      }), i(this).find("button").first().attr({
        role: "tab",
        id: "slick-slide-control" + e.instanceUid + s,
        "aria-controls": "slick-slide" + e.instanceUid + n,
        "aria-label": s + 1 + " of " + t,
        "aria-selected": null,
        tabindex: "-1"
      });
    }).eq(e.currentSlide).find("button").attr({
      "aria-selected": "true",
      tabindex: "0"
    }).end());

    for (var s = e.currentSlide, n = s + e.options.slidesToShow; s < n; s++) {
      e.$slides.eq(s).attr("tabindex", 0);
    }

    e.activateADA();
  }, e.prototype.initArrowEvents = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.off("click.slick").on("click.slick", {
      message: "previous"
    }, i.changeSlide), i.$nextArrow.off("click.slick").on("click.slick", {
      message: "next"
    }, i.changeSlide), !0 === i.options.accessibility && (i.$prevArrow.on("keydown.slick", i.keyHandler), i.$nextArrow.on("keydown.slick", i.keyHandler)));
  }, e.prototype.initDotEvents = function () {
    var e = this;
    !0 === e.options.dots && (i("li", e.$dots).on("click.slick", {
      message: "index"
    }, e.changeSlide), !0 === e.options.accessibility && e.$dots.on("keydown.slick", e.keyHandler)), !0 === e.options.dots && !0 === e.options.pauseOnDotsHover && i("li", e.$dots).on("mouseenter.slick", i.proxy(e.interrupt, e, !0)).on("mouseleave.slick", i.proxy(e.interrupt, e, !1));
  }, e.prototype.initSlideEvents = function () {
    var e = this;
    e.options.pauseOnHover && (e.$list.on("mouseenter.slick", i.proxy(e.interrupt, e, !0)), e.$list.on("mouseleave.slick", i.proxy(e.interrupt, e, !1)));
  }, e.prototype.initializeEvents = function () {
    var e = this;
    e.initArrowEvents(), e.initDotEvents(), e.initSlideEvents(), e.$list.on("touchstart.slick mousedown.slick", {
      action: "start"
    }, e.swipeHandler), e.$list.on("touchmove.slick mousemove.slick", {
      action: "move"
    }, e.swipeHandler), e.$list.on("touchend.slick mouseup.slick", {
      action: "end"
    }, e.swipeHandler), e.$list.on("touchcancel.slick mouseleave.slick", {
      action: "end"
    }, e.swipeHandler), e.$list.on("click.slick", e.clickHandler), i(document).on(e.visibilityChange, i.proxy(e.visibility, e)), !0 === e.options.accessibility && e.$list.on("keydown.slick", e.keyHandler), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), i(window).on("orientationchange.slick.slick-" + e.instanceUid, i.proxy(e.orientationChange, e)), i(window).on("resize.slick.slick-" + e.instanceUid, i.proxy(e.resize, e)), i("[draggable!=true]", e.$slideTrack).on("dragstart", e.preventDefault), i(window).on("load.slick.slick-" + e.instanceUid, e.setPosition), i(e.setPosition);
  }, e.prototype.initUI = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.show(), i.$nextArrow.show()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.show();
  }, e.prototype.keyHandler = function (i) {
    var e = this;
    i.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === i.keyCode && !0 === e.options.accessibility ? e.changeSlide({
      data: {
        message: !0 === e.options.rtl ? "next" : "previous"
      }
    }) : 39 === i.keyCode && !0 === e.options.accessibility && e.changeSlide({
      data: {
        message: !0 === e.options.rtl ? "previous" : "next"
      }
    }));
  }, e.prototype.lazyLoad = function () {
    function e(e) {
      i("img[data-lazy]", e).each(function () {
        var e = i(this),
            t = i(this).attr("data-lazy"),
            o = i(this).attr("data-srcset"),
            s = i(this).attr("data-sizes") || n.$slider.attr("data-sizes"),
            r = document.createElement("img");
        r.onload = function () {
          e.animate({
            opacity: 0
          }, 100, function () {
            o && (e.attr("srcset", o), s && e.attr("sizes", s)), e.attr("src", t).animate({
              opacity: 1
            }, 200, function () {
              e.removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading");
            }), n.$slider.trigger("lazyLoaded", [n, e, t]);
          });
        }, r.onerror = function () {
          e.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), n.$slider.trigger("lazyLoadError", [n, e, t]);
        }, r.src = t;
      });
    }

    var t,
        o,
        s,
        n = this;
    if (!0 === n.options.centerMode ? !0 === n.options.infinite ? s = (o = n.currentSlide + (n.options.slidesToShow / 2 + 1)) + n.options.slidesToShow + 2 : (o = Math.max(0, n.currentSlide - (n.options.slidesToShow / 2 + 1)), s = n.options.slidesToShow / 2 + 1 + 2 + n.currentSlide) : (o = n.options.infinite ? n.options.slidesToShow + n.currentSlide : n.currentSlide, s = Math.ceil(o + n.options.slidesToShow), !0 === n.options.fade && (o > 0 && o--, s <= n.slideCount && s++)), t = n.$slider.find(".slick-slide").slice(o, s), "anticipated" === n.options.lazyLoad) for (var r = o - 1, l = s, d = n.$slider.find(".slick-slide"), a = 0; a < n.options.slidesToScroll; a++) {
      r < 0 && (r = n.slideCount - 1), t = (t = t.add(d.eq(r))).add(d.eq(l)), r--, l++;
    }
    e(t), n.slideCount <= n.options.slidesToShow ? e(n.$slider.find(".slick-slide")) : n.currentSlide >= n.slideCount - n.options.slidesToShow ? e(n.$slider.find(".slick-cloned").slice(0, n.options.slidesToShow)) : 0 === n.currentSlide && e(n.$slider.find(".slick-cloned").slice(-1 * n.options.slidesToShow));
  }, e.prototype.loadSlider = function () {
    var i = this;
    i.setPosition(), i.$slideTrack.css({
      opacity: 1
    }), i.$slider.removeClass("slick-loading"), i.initUI(), "progressive" === i.options.lazyLoad && i.progressiveLazyLoad();
  }, e.prototype.next = e.prototype.slickNext = function () {
    this.changeSlide({
      data: {
        message: "next"
      }
    });
  }, e.prototype.orientationChange = function () {
    var i = this;
    i.checkResponsive(), i.setPosition();
  }, e.prototype.pause = e.prototype.slickPause = function () {
    var i = this;
    i.autoPlayClear(), i.paused = !0;
  }, e.prototype.play = e.prototype.slickPlay = function () {
    var i = this;
    i.autoPlay(), i.options.autoplay = !0, i.paused = !1, i.focussed = !1, i.interrupted = !1;
  }, e.prototype.postSlide = function (e) {
    var t = this;
    t.unslicked || (t.$slider.trigger("afterChange", [t, e]), t.animating = !1, t.slideCount > t.options.slidesToShow && t.setPosition(), t.swipeLeft = null, t.options.autoplay && t.autoPlay(), !0 === t.options.accessibility && (t.initADA(), t.options.focusOnChange && i(t.$slides.get(t.currentSlide)).attr("tabindex", 0).focus()));
  }, e.prototype.prev = e.prototype.slickPrev = function () {
    this.changeSlide({
      data: {
        message: "previous"
      }
    });
  }, e.prototype.preventDefault = function (i) {
    i.preventDefault();
  }, e.prototype.progressiveLazyLoad = function (e) {
    e = e || 1;
    var t,
        o,
        s,
        n,
        r,
        l = this,
        d = i("img[data-lazy]", l.$slider);
    d.length ? (t = d.first(), o = t.attr("data-lazy"), s = t.attr("data-srcset"), n = t.attr("data-sizes") || l.$slider.attr("data-sizes"), (r = document.createElement("img")).onload = function () {
      s && (t.attr("srcset", s), n && t.attr("sizes", n)), t.attr("src", o).removeAttr("data-lazy data-srcset data-sizes").removeClass("slick-loading"), !0 === l.options.adaptiveHeight && l.setPosition(), l.$slider.trigger("lazyLoaded", [l, t, o]), l.progressiveLazyLoad();
    }, r.onerror = function () {
      e < 3 ? setTimeout(function () {
        l.progressiveLazyLoad(e + 1);
      }, 500) : (t.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error"), l.$slider.trigger("lazyLoadError", [l, t, o]), l.progressiveLazyLoad());
    }, r.src = o) : l.$slider.trigger("allImagesLoaded", [l]);
  }, e.prototype.refresh = function (e) {
    var t,
        o,
        s = this;
    o = s.slideCount - s.options.slidesToShow, !s.options.infinite && s.currentSlide > o && (s.currentSlide = o), s.slideCount <= s.options.slidesToShow && (s.currentSlide = 0), t = s.currentSlide, s.destroy(!0), i.extend(s, s.initials, {
      currentSlide: t
    }), s.init(), e || s.changeSlide({
      data: {
        message: "index",
        index: t
      }
    }, !1);
  }, e.prototype.registerBreakpoints = function () {
    var e,
        t,
        o,
        s = this,
        n = s.options.responsive || null;

    if ("array" === i.type(n) && n.length) {
      s.respondTo = s.options.respondTo || "window";

      for (e in n) {
        if (o = s.breakpoints.length - 1, n.hasOwnProperty(e)) {
          for (t = n[e].breakpoint; o >= 0;) {
            s.breakpoints[o] && s.breakpoints[o] === t && s.breakpoints.splice(o, 1), o--;
          }

          s.breakpoints.push(t), s.breakpointSettings[t] = n[e].settings;
        }
      }

      s.breakpoints.sort(function (i, e) {
        return s.options.mobileFirst ? i - e : e - i;
      });
    }
  }, e.prototype.reinit = function () {
    var e = this;
    e.$slides = e.$slideTrack.children(e.options.slide).addClass("slick-slide"), e.slideCount = e.$slides.length, e.currentSlide >= e.slideCount && 0 !== e.currentSlide && (e.currentSlide = e.currentSlide - e.options.slidesToScroll), e.slideCount <= e.options.slidesToShow && (e.currentSlide = 0), e.registerBreakpoints(), e.setProps(), e.setupInfinite(), e.buildArrows(), e.updateArrows(), e.initArrowEvents(), e.buildDots(), e.updateDots(), e.initDotEvents(), e.cleanUpSlideEvents(), e.initSlideEvents(), e.checkResponsive(!1, !0), !0 === e.options.focusOnSelect && i(e.$slideTrack).children().on("click.slick", e.selectHandler), e.setSlideClasses("number" == typeof e.currentSlide ? e.currentSlide : 0), e.setPosition(), e.focusHandler(), e.paused = !e.options.autoplay, e.autoPlay(), e.$slider.trigger("reInit", [e]);
  }, e.prototype.resize = function () {
    var e = this;
    i(window).width() !== e.windowWidth && (clearTimeout(e.windowDelay), e.windowDelay = window.setTimeout(function () {
      e.windowWidth = i(window).width(), e.checkResponsive(), e.unslicked || e.setPosition();
    }, 50));
  }, e.prototype.removeSlide = e.prototype.slickRemove = function (i, e, t) {
    var o = this;
    if (i = "boolean" == typeof i ? !0 === (e = i) ? 0 : o.slideCount - 1 : !0 === e ? --i : i, o.slideCount < 1 || i < 0 || i > o.slideCount - 1) return !1;
    o.unload(), !0 === t ? o.$slideTrack.children().remove() : o.$slideTrack.children(this.options.slide).eq(i).remove(), o.$slides = o.$slideTrack.children(this.options.slide), o.$slideTrack.children(this.options.slide).detach(), o.$slideTrack.append(o.$slides), o.$slidesCache = o.$slides, o.reinit();
  }, e.prototype.setCSS = function (i) {
    var e,
        t,
        o = this,
        s = {};
    !0 === o.options.rtl && (i = -i), e = "left" == o.positionProp ? Math.ceil(i) + "px" : "0px", t = "top" == o.positionProp ? Math.ceil(i) + "px" : "0px", s[o.positionProp] = i, !1 === o.transformsEnabled ? o.$slideTrack.css(s) : (s = {}, !1 === o.cssTransitions ? (s[o.animType] = "translate(" + e + ", " + t + ")", o.$slideTrack.css(s)) : (s[o.animType] = "translate3d(" + e + ", " + t + ", 0px)", o.$slideTrack.css(s)));
  }, e.prototype.setDimensions = function () {
    var i = this;
    !1 === i.options.vertical ? !0 === i.options.centerMode && i.$list.css({
      padding: "0px " + i.options.centerPadding
    }) : (i.$list.height(i.$slides.first().outerHeight(!0) * i.options.slidesToShow), !0 === i.options.centerMode && i.$list.css({
      padding: i.options.centerPadding + " 0px"
    })), i.listWidth = i.$list.width(), i.listHeight = i.$list.height(), !1 === i.options.vertical && !1 === i.options.variableWidth ? (i.slideWidth = Math.ceil(i.listWidth / i.options.slidesToShow), i.$slideTrack.width(Math.ceil(i.slideWidth * i.$slideTrack.children(".slick-slide").length))) : !0 === i.options.variableWidth ? i.$slideTrack.width(5e3 * i.slideCount) : (i.slideWidth = Math.ceil(i.listWidth), i.$slideTrack.height(Math.ceil(i.$slides.first().outerHeight(!0) * i.$slideTrack.children(".slick-slide").length)));
    var e = i.$slides.first().outerWidth(!0) - i.$slides.first().width();
    !1 === i.options.variableWidth && i.$slideTrack.children(".slick-slide").width(i.slideWidth - e);
  }, e.prototype.setFade = function () {
    var e,
        t = this;
    t.$slides.each(function (o, s) {
      e = t.slideWidth * o * -1, !0 === t.options.rtl ? i(s).css({
        position: "relative",
        right: e,
        top: 0,
        zIndex: t.options.zIndex - 2,
        opacity: 0
      }) : i(s).css({
        position: "relative",
        left: e,
        top: 0,
        zIndex: t.options.zIndex - 2,
        opacity: 0
      });
    }), t.$slides.eq(t.currentSlide).css({
      zIndex: t.options.zIndex - 1,
      opacity: 1
    });
  }, e.prototype.setHeight = function () {
    var i = this;

    if (1 === i.options.slidesToShow && !0 === i.options.adaptiveHeight && !1 === i.options.vertical) {
      var e = i.$slides.eq(i.currentSlide).outerHeight(!0);
      i.$list.css("height", e);
    }
  }, e.prototype.setOption = e.prototype.slickSetOption = function () {
    var e,
        t,
        o,
        s,
        n,
        r = this,
        l = !1;
    if ("object" === i.type(arguments[0]) ? (o = arguments[0], l = arguments[1], n = "multiple") : "string" === i.type(arguments[0]) && (o = arguments[0], s = arguments[1], l = arguments[2], "responsive" === arguments[0] && "array" === i.type(arguments[1]) ? n = "responsive" : void 0 !== arguments[1] && (n = "single")), "single" === n) r.options[o] = s;else if ("multiple" === n) i.each(o, function (i, e) {
      r.options[i] = e;
    });else if ("responsive" === n) for (t in s) {
      if ("array" !== i.type(r.options.responsive)) r.options.responsive = [s[t]];else {
        for (e = r.options.responsive.length - 1; e >= 0;) {
          r.options.responsive[e].breakpoint === s[t].breakpoint && r.options.responsive.splice(e, 1), e--;
        }

        r.options.responsive.push(s[t]);
      }
    }
    l && (r.unload(), r.reinit());
  }, e.prototype.setPosition = function () {
    var i = this;
    i.setDimensions(), i.setHeight(), !1 === i.options.fade ? i.setCSS(i.getLeft(i.currentSlide)) : i.setFade(), i.$slider.trigger("setPosition", [i]);
  }, e.prototype.setProps = function () {
    var i = this,
        e = document.body.style;
    i.positionProp = !0 === i.options.vertical ? "top" : "left", "top" === i.positionProp ? i.$slider.addClass("slick-vertical") : i.$slider.removeClass("slick-vertical"), void 0 === e.WebkitTransition && void 0 === e.MozTransition && void 0 === e.msTransition || !0 === i.options.useCSS && (i.cssTransitions = !0), i.options.fade && ("number" == typeof i.options.zIndex ? i.options.zIndex < 3 && (i.options.zIndex = 3) : i.options.zIndex = i.defaults.zIndex), void 0 !== e.OTransform && (i.animType = "OTransform", i.transformType = "-o-transform", i.transitionType = "OTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.MozTransform && (i.animType = "MozTransform", i.transformType = "-moz-transform", i.transitionType = "MozTransition", void 0 === e.perspectiveProperty && void 0 === e.MozPerspective && (i.animType = !1)), void 0 !== e.webkitTransform && (i.animType = "webkitTransform", i.transformType = "-webkit-transform", i.transitionType = "webkitTransition", void 0 === e.perspectiveProperty && void 0 === e.webkitPerspective && (i.animType = !1)), void 0 !== e.msTransform && (i.animType = "msTransform", i.transformType = "-ms-transform", i.transitionType = "msTransition", void 0 === e.msTransform && (i.animType = !1)), void 0 !== e.transform && !1 !== i.animType && (i.animType = "transform", i.transformType = "transform", i.transitionType = "transition"), i.transformsEnabled = i.options.useTransform && null !== i.animType && !1 !== i.animType;
  }, e.prototype.setSlideClasses = function (i) {
    var e,
        t,
        o,
        s,
        n = this;

    if (t = n.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true"), n.$slides.eq(i).addClass("slick-current"), !0 === n.options.centerMode) {
      var r = n.options.slidesToShow % 2 == 0 ? 1 : 0;
      e = Math.floor(n.options.slidesToShow / 2), !0 === n.options.infinite && (i >= e && i <= n.slideCount - 1 - e ? n.$slides.slice(i - e + r, i + e + 1).addClass("slick-active").attr("aria-hidden", "false") : (o = n.options.slidesToShow + i, t.slice(o - e + 1 + r, o + e + 2).addClass("slick-active").attr("aria-hidden", "false")), 0 === i ? t.eq(t.length - 1 - n.options.slidesToShow).addClass("slick-center") : i === n.slideCount - 1 && t.eq(n.options.slidesToShow).addClass("slick-center")), n.$slides.eq(i).addClass("slick-center");
    } else i >= 0 && i <= n.slideCount - n.options.slidesToShow ? n.$slides.slice(i, i + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false") : t.length <= n.options.slidesToShow ? t.addClass("slick-active").attr("aria-hidden", "false") : (s = n.slideCount % n.options.slidesToShow, o = !0 === n.options.infinite ? n.options.slidesToShow + i : i, n.options.slidesToShow == n.options.slidesToScroll && n.slideCount - i < n.options.slidesToShow ? t.slice(o - (n.options.slidesToShow - s), o + s).addClass("slick-active").attr("aria-hidden", "false") : t.slice(o, o + n.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"));

    "ondemand" !== n.options.lazyLoad && "anticipated" !== n.options.lazyLoad || n.lazyLoad();
  }, e.prototype.setupInfinite = function () {
    var e,
        t,
        o,
        s = this;

    if (!0 === s.options.fade && (s.options.centerMode = !1), !0 === s.options.infinite && !1 === s.options.fade && (t = null, s.slideCount > s.options.slidesToShow)) {
      for (o = !0 === s.options.centerMode ? s.options.slidesToShow + 1 : s.options.slidesToShow, e = s.slideCount; e > s.slideCount - o; e -= 1) {
        t = e - 1, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t - s.slideCount).prependTo(s.$slideTrack).addClass("slick-cloned");
      }

      for (e = 0; e < o + s.slideCount; e += 1) {
        t = e, i(s.$slides[t]).clone(!0).attr("id", "").attr("data-slick-index", t + s.slideCount).appendTo(s.$slideTrack).addClass("slick-cloned");
      }

      s.$slideTrack.find(".slick-cloned").find("[id]").each(function () {
        i(this).attr("id", "");
      });
    }
  }, e.prototype.interrupt = function (i) {
    var e = this;
    i || e.autoPlay(), e.interrupted = i;
  }, e.prototype.selectHandler = function (e) {
    var t = this,
        o = i(e.target).is(".slick-slide") ? i(e.target) : i(e.target).parents(".slick-slide"),
        s = parseInt(o.attr("data-slick-index"));
    s || (s = 0), t.slideCount <= t.options.slidesToShow ? t.slideHandler(s, !1, !0) : t.slideHandler(s);
  }, e.prototype.slideHandler = function (i, e, t) {
    var o,
        s,
        n,
        r,
        l,
        d = null,
        a = this;
    if (e = e || !1, !(!0 === a.animating && !0 === a.options.waitForAnimate || !0 === a.options.fade && a.currentSlide === i)) if (!1 === e && a.asNavFor(i), o = i, d = a.getLeft(o), r = a.getLeft(a.currentSlide), a.currentLeft = null === a.swipeLeft ? r : a.swipeLeft, !1 === a.options.infinite && !1 === a.options.centerMode && (i < 0 || i > a.getDotCount() * a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function () {
      a.postSlide(o);
    }) : a.postSlide(o));else if (!1 === a.options.infinite && !0 === a.options.centerMode && (i < 0 || i > a.slideCount - a.options.slidesToScroll)) !1 === a.options.fade && (o = a.currentSlide, !0 !== t ? a.animateSlide(r, function () {
      a.postSlide(o);
    }) : a.postSlide(o));else {
      if (a.options.autoplay && clearInterval(a.autoPlayTimer), s = o < 0 ? a.slideCount % a.options.slidesToScroll != 0 ? a.slideCount - a.slideCount % a.options.slidesToScroll : a.slideCount + o : o >= a.slideCount ? a.slideCount % a.options.slidesToScroll != 0 ? 0 : o - a.slideCount : o, a.animating = !0, a.$slider.trigger("beforeChange", [a, a.currentSlide, s]), n = a.currentSlide, a.currentSlide = s, a.setSlideClasses(a.currentSlide), a.options.asNavFor && (l = (l = a.getNavTarget()).slick("getSlick")).slideCount <= l.options.slidesToShow && l.setSlideClasses(a.currentSlide), a.updateDots(), a.updateArrows(), !0 === a.options.fade) return !0 !== t ? (a.fadeSlideOut(n), a.fadeSlide(s, function () {
        a.postSlide(s);
      })) : a.postSlide(s), void a.animateHeight();
      !0 !== t ? a.animateSlide(d, function () {
        a.postSlide(s);
      }) : a.postSlide(s);
    }
  }, e.prototype.startLoad = function () {
    var i = this;
    !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && (i.$prevArrow.hide(), i.$nextArrow.hide()), !0 === i.options.dots && i.slideCount > i.options.slidesToShow && i.$dots.hide(), i.$slider.addClass("slick-loading");
  }, e.prototype.swipeDirection = function () {
    var i,
        e,
        t,
        o,
        s = this;
    return i = s.touchObject.startX - s.touchObject.curX, e = s.touchObject.startY - s.touchObject.curY, t = Math.atan2(e, i), (o = Math.round(180 * t / Math.PI)) < 0 && (o = 360 - Math.abs(o)), o <= 45 && o >= 0 ? !1 === s.options.rtl ? "left" : "right" : o <= 360 && o >= 315 ? !1 === s.options.rtl ? "left" : "right" : o >= 135 && o <= 225 ? !1 === s.options.rtl ? "right" : "left" : !0 === s.options.verticalSwiping ? o >= 35 && o <= 135 ? "down" : "up" : "vertical";
  }, e.prototype.swipeEnd = function (i) {
    var e,
        t,
        o = this;
    if (o.dragging = !1, o.swiping = !1, o.scrolling) return o.scrolling = !1, !1;
    if (o.interrupted = !1, o.shouldClick = !(o.touchObject.swipeLength > 10), void 0 === o.touchObject.curX) return !1;

    if (!0 === o.touchObject.edgeHit && o.$slider.trigger("edge", [o, o.swipeDirection()]), o.touchObject.swipeLength >= o.touchObject.minSwipe) {
      switch (t = o.swipeDirection()) {
        case "left":
        case "down":
          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide + o.getSlideCount()) : o.currentSlide + o.getSlideCount(), o.currentDirection = 0;
          break;

        case "right":
        case "up":
          e = o.options.swipeToSlide ? o.checkNavigable(o.currentSlide - o.getSlideCount()) : o.currentSlide - o.getSlideCount(), o.currentDirection = 1;
      }

      "vertical" != t && (o.slideHandler(e), o.touchObject = {}, o.$slider.trigger("swipe", [o, t]));
    } else o.touchObject.startX !== o.touchObject.curX && (o.slideHandler(o.currentSlide), o.touchObject = {});
  }, e.prototype.swipeHandler = function (i) {
    var e = this;
    if (!(!1 === e.options.swipe || "ontouchend" in document && !1 === e.options.swipe || !1 === e.options.draggable && -1 !== i.type.indexOf("mouse"))) switch (e.touchObject.fingerCount = i.originalEvent && void 0 !== i.originalEvent.touches ? i.originalEvent.touches.length : 1, e.touchObject.minSwipe = e.listWidth / e.options.touchThreshold, !0 === e.options.verticalSwiping && (e.touchObject.minSwipe = e.listHeight / e.options.touchThreshold), i.data.action) {
      case "start":
        e.swipeStart(i);
        break;

      case "move":
        e.swipeMove(i);
        break;

      case "end":
        e.swipeEnd(i);
    }
  }, e.prototype.swipeMove = function (i) {
    var e,
        t,
        o,
        s,
        n,
        r,
        l = this;
    return n = void 0 !== i.originalEvent ? i.originalEvent.touches : null, !(!l.dragging || l.scrolling || n && 1 !== n.length) && (e = l.getLeft(l.currentSlide), l.touchObject.curX = void 0 !== n ? n[0].pageX : i.clientX, l.touchObject.curY = void 0 !== n ? n[0].pageY : i.clientY, l.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(l.touchObject.curX - l.touchObject.startX, 2))), r = Math.round(Math.sqrt(Math.pow(l.touchObject.curY - l.touchObject.startY, 2))), !l.options.verticalSwiping && !l.swiping && r > 4 ? (l.scrolling = !0, !1) : (!0 === l.options.verticalSwiping && (l.touchObject.swipeLength = r), t = l.swipeDirection(), void 0 !== i.originalEvent && l.touchObject.swipeLength > 4 && (l.swiping = !0, i.preventDefault()), s = (!1 === l.options.rtl ? 1 : -1) * (l.touchObject.curX > l.touchObject.startX ? 1 : -1), !0 === l.options.verticalSwiping && (s = l.touchObject.curY > l.touchObject.startY ? 1 : -1), o = l.touchObject.swipeLength, l.touchObject.edgeHit = !1, !1 === l.options.infinite && (0 === l.currentSlide && "right" === t || l.currentSlide >= l.getDotCount() && "left" === t) && (o = l.touchObject.swipeLength * l.options.edgeFriction, l.touchObject.edgeHit = !0), !1 === l.options.vertical ? l.swipeLeft = e + o * s : l.swipeLeft = e + o * (l.$list.height() / l.listWidth) * s, !0 === l.options.verticalSwiping && (l.swipeLeft = e + o * s), !0 !== l.options.fade && !1 !== l.options.touchMove && (!0 === l.animating ? (l.swipeLeft = null, !1) : void l.setCSS(l.swipeLeft))));
  }, e.prototype.swipeStart = function (i) {
    var e,
        t = this;
    if (t.interrupted = !0, 1 !== t.touchObject.fingerCount || t.slideCount <= t.options.slidesToShow) return t.touchObject = {}, !1;
    void 0 !== i.originalEvent && void 0 !== i.originalEvent.touches && (e = i.originalEvent.touches[0]), t.touchObject.startX = t.touchObject.curX = void 0 !== e ? e.pageX : i.clientX, t.touchObject.startY = t.touchObject.curY = void 0 !== e ? e.pageY : i.clientY, t.dragging = !0;
  }, e.prototype.unfilterSlides = e.prototype.slickUnfilter = function () {
    var i = this;
    null !== i.$slidesCache && (i.unload(), i.$slideTrack.children(this.options.slide).detach(), i.$slidesCache.appendTo(i.$slideTrack), i.reinit());
  }, e.prototype.unload = function () {
    var e = this;
    i(".slick-cloned", e.$slider).remove(), e.$dots && e.$dots.remove(), e.$prevArrow && e.htmlExpr.test(e.options.prevArrow) && e.$prevArrow.remove(), e.$nextArrow && e.htmlExpr.test(e.options.nextArrow) && e.$nextArrow.remove(), e.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
  }, e.prototype.unslick = function (i) {
    var e = this;
    e.$slider.trigger("unslick", [e, i]), e.destroy();
  }, e.prototype.updateArrows = function () {
    var i = this;
    Math.floor(i.options.slidesToShow / 2), !0 === i.options.arrows && i.slideCount > i.options.slidesToShow && !i.options.infinite && (i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false"), 0 === i.currentSlide ? (i.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - i.options.slidesToShow && !1 === i.options.centerMode ? (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")) : i.currentSlide >= i.slideCount - 1 && !0 === i.options.centerMode && (i.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true"), i.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false")));
  }, e.prototype.updateDots = function () {
    var i = this;
    null !== i.$dots && (i.$dots.find("li").removeClass("slick-active").end(), i.$dots.find("li").eq(Math.floor(i.currentSlide / i.options.slidesToScroll)).addClass("slick-active"));
  }, e.prototype.visibility = function () {
    var i = this;
    i.options.autoplay && (document[i.hidden] ? i.interrupted = !0 : i.interrupted = !1);
  }, i.fn.slick = function () {
    var i,
        t,
        o = this,
        s = arguments[0],
        n = Array.prototype.slice.call(arguments, 1),
        r = o.length;

    for (i = 0; i < r; i++) {
      if ("object" == _typeof(s) || void 0 === s ? o[i].slick = new e(o[i], s) : t = o[i].slick[s].apply(o[i].slick, n), void 0 !== t) return t;
    }

    return o;
  };
});

/***/ }),

/***/ "./cartridges/app_mk_storefront/cartridge/config/customAddressConfig.json":
/*!********************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/config/customAddressConfig.json ***!
  \********************************************************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"US":{"firstName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\']*$)"},"lastName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\']*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»^\\\\[?;:!§$£€%µ,.\'\\\\-\\\\/\\\\)\\\\(\\\\{\\\\]\\\\|+`*=~&#_@]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»^\\\\[?;:!§$£€%µ,.\'\\\\-\\\\/\\\\)\\\\(\\\\{\\\\]\\\\|+`*=~&#_@]*$"},"postalCode":{"type":"tel","mandatory":true,"maxLength":"10","regEx":"^\\\\d{5}(?:-\\\\d{4})?$"},"city":{"maxLength":"30","minLength":"2","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»^\\\\[?;:!§$£€%µ,.\'\\\\-\\\\/\\\\)\\\\(\\\\{\\\\]\\\\|+`*=~&#_@]*$"},"phone":{"maxLength":"15","minLength":"10","mandatory":true,"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"state","zipLabel":"zip"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»^\\\\[?;:!§$£€%µ,.\'\\\\-\\\\/\\\\)\\\\(\\\\{\\\\]\\\\|+`*=~&#_@]*$","maxLength":"2","mandatory":true,"hidden":false,"options":{"AL":"Alabama","AK":"Alaska","AS":"Samoa","PR":"Puerto Rico","AZ":"Arizona","AR":"Arkansas","CA":"California","CO":"Colorado","CT":"Connecticut","DE":"Delaware","DC":"District of Columbia","FL":"Florida","GA":"Georgia","GU":"Guam","HI":"Hawaii","ID":"Idaho","IL":"Illinois","IN":"Indiana","IA":"Iowa","KS":"Kansas","KY":"Kentucky","LA":"Louisiana","ME":"Maine","MD":"Maryland","MA":"Massachusetts","MI":"Michigan","MN":"Minnesota","MS":"Mississippi","MO":"Missouri","MP":"Mariana Islands","MT":"Montana","NE":"Nebraska","NV":"Nevada","NH":"New Hampshire","NJ":"New Jersey","NM":"New Mexico","NY":"New York","NC":"North Carolina","ND":"North Dakota","OH":"Ohio","OK":"Oklahoma","OR":"Oregon","PA":"Pennsylvania","RI":"Rhode Island","SC":"South Carolina","SD":"South Dakota","TN":"Tennessee","TX":"Texas","UT":"Utah","VT":"Vermont","VI":"Virgin Islands","VA":"Virginia","WA":"Washington","WV":"West Virginia","WI":"Wisconsin","WY":"Wyoming","AA":"AA-APO/FPO","AE":"AE-APO/FPO","AP":"AP-APO/FPO"}}},"GB":{"firstName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\']*$)"},"lastName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\']*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-]*$"},"postalCode":{"type":"text","minLength":"5","maxLength":"10","mandatory":true,"regEx":"(^[A-Za-z]{1,2}[0-9Rr][0-9A-Za-z]? ?[0-9][A-Za-z]{2}$)"},"city":{"maxLength":"30","minLength":"2","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-]*$"},"phone":{"maxLength":"15","minLength":"10","mandatory":true,"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"CA":{"firstName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$)"},"lastName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"postalCode":{"type":"text","mandatory":true,"regEx":"^([0-9]{5}|([0-9]{5}[\\\\-][0-9]{4}))$|^[a-zA-Z][0-9][a-zA-Z] ?[0-9][a-zA-Z][0-9]$"},"city":{"maxLength":"30","minLength":"2","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"phone":{"maxLength":"15","minLength":"10","mandatory":true,"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"state","zipLabel":"zip"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"2","mandatory":true,"hidden":false,"options":{"AB":"Alberta","MB":"Manitoba","BC":"British Columbia","NB":"New Brunswick","NL":"Newfoundland and Labrador","NS":"Nova Scotia","NT":"Northwest Territories","NU":"Nunavut","ON":"Ontario","PE":"Prince Edward Island","QC":"Quebec","SK":"Saskatchewan","YT":"Yukon Territory"}}},"FR":{"firstName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$)"},"lastName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{5}$"},"city":{"maxLength":"30","minLength":"2","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$"},"phone":{"maxLength":"15","minLength":"10","mandatory":true,"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ùûüÿàâæçéèêëïîôœÙÛÜŸÀÂÆÇÉÈÊËÏÎÔŒ]*$","maxLength":"35","mandatory":false,"hidden":true,"options":{}}},"IT":{"firstName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'àèéìòóùÀÈÉÌÒÓÙ]*$)"},"lastName":{"maxLength":"29","mandatory":true,"regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'àèéìòóùÀÈÉÌÒÓÙ]*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-àèéìòóùÀÈÉÌÒÓÙ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-àèéìòóùÀÈÉÌÒÓÙ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{1,5}$"},"city":{"maxLength":"30","minLength":"2","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-àèéìòóùÀÈÉÌÒÓÙ]*$"},"phone":{"maxLength":"15","minLength":"10","mandatory":true,"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-àèéìòóùÀÈÉÌÒÓÙ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"DE":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{5}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$","maxLength":"35","mandatory":false,"hidden":true,"options":{}}},"BE":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"AU":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"maxLength":"35","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"maxLength":"35","mandatory":false,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[\\\\d]*$"},"city":{"maxLength":"30","mandatory":true,"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"state","zipLabel":"zip"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{"AAT":"Australian Antarctic Territory","ACT":"Australian Capital Territory","NT":"Northern Territory","NSW":"New South Wales","QLD":"Queensland","SA":"South Australia","TAS":"Tasmania","VIC":"Victoria","WA":"Western Australia"}}},"PT":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_°²,.\'\\\\-ãáàâçéêíõóôúüÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ãáàâçéêíõóôúüÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}[-][0-9]{3}?$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_°²,.\'\\\\-ãáàâçéêíõóôúüÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_°²,.\'\\\\-ãáàâçéêíõóôúüÃÁÀÂÇÉÊÍÕÓÔÚÜ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"DK":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæéøÅÆÉØ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæéøÅÆÉØ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæéøÅÆÉØ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæéøÅÆÉØ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"ES":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíñóúü¿¡ÁÉÍÑÓÚÜ¿¡]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíñóúü¿¡ÁÉÍÑÓÚÜ¿¡]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{1,5}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíñóúü¿¡ÁÉÍÑÓÚÜ¿¡]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\\\\-áéíñóúü¿¡ÁÉÍÑÓÚÜ¿¡]*$","maxLength":"35","mandatory":false,"hidden":true,"options":{}}},"AT":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"postalCode":{"type":"tel","padding":"true","minLength":"4","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"CH":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$","maxLength":"35","mandatory":false,"hidden":true,"options":{}}},"CZ":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-úůýžáčďéěíňóřšťÚŮÝŽÁČĎÉĚÍŇÓŘŠŤ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-úůýžáčďéěíňóřšťÚŮÝŽÁČĎÉĚÍŇÓŘŠŤ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^\\\\d{3}\\\\s?\\\\d{2}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-úůýžáčďéěíňóřšťÚŮÝŽÁČĎÉĚÍŇÓŘŠŤ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-úůýžáčďéěíňóřšťÚŮÝŽÁČĎÉĚÍŇÓŘŠŤ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"FI":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåöÄÅÖ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåöÄÅÖ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{5}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåöÄÅÖ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåöÄÅÖ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"HU":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíöóőüúűÁÉÍÖÓŐÜÚŰ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíöóőüúűÁÉÍÖÓŐÜÚŰ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-áéíöóőüúűÁÉÍÖÓŐÜÚŰ]*$"},"phone":{"maxLength":"15","mnLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-áéíöóőüúűÁÉÍÖÓŐÜÚŰ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"NL":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-éëïóöüÉËÏÓÖÜ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-éëïóöüÉËÏÓÖÜ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}[ ]?[a-zA-Z]{2}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-éëïóöüÉËÏÓÖÜ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-éëïóöüÉËÏÓÖÜ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"RO":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-âăîşţșțÂĂÎŞŢȘȚ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-âăîşţșțÂĂÎŞŢȘȚ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[\\\\d]*$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-âăîşţșțÂĂÎŞŢȘȚ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-âăîşţșțÂĂÎŞŢȘȚ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"LU":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^(L|l)[-][0-9]{4}$|^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"NO":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæâéèêøóòôÅÆÂÉÈÊØÓÒÔ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæâéèêøóòôÅÆÂÉÈÊØÓÒÔ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-åæâéèêøóòôÅÆÂÉÈÊØÓÒÔ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-åæâéèêøóòôÅÆÂÉÈÊØÓÒÔ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"IE":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"postalCode":{"type":"text","padding":"true","mandatory":false,"maxLength":"10","regEx":"^[A-Za-z]{1}[0-9A-Za-z]{2}\\\\s[A-Za-z0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äöüß€ÄÖÜß€]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äöüß€ÄÖÜß€]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"LT":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąčęėįšųūžĄČĘĖĮŠŲŪŽ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąčęėįšųūžĄČĘĖĮŠŲŪŽ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{5}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąčęėįšųūžĄČĘĖĮŠŲŪŽ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąčęėįšųūžĄČĘĖĮŠŲŪŽ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"LV":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-āčēģīķļšūžĀČĒĢĪĶĻŠŪŽ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-āčēģīķļšūžĀČĒĢĪĶĻŠŪŽ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^(LV|lv|Lv|lV)[-][0-9]{4}$|^[0-9]{4}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-āčēģīķļšūžĀČĒĢĪĶĻŠŪŽ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-āčēģīķļšūžĀČĒĢĪĶĻŠŪŽ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"PL":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{2}-[0-9]{3}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-ąćęłńóśźżĄĆĘŁŃÓŚŹŻ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"SE":{"firstName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"lastName":{"maxLength":"29","regEx":"(^[a-zA-Z0-9\\\\s.\\\\-,\'äöüß€ÄÖÜß€]*$)"},"address1":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåéöÄÅÉÖ]*$"},"address2":{"maxLength":"35","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåéöÄÅÉÖ]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"10","mandatory":true,"regEx":"^[0-9]{3}[ ]?[0-9]{2}$"},"city":{"maxLength":"30","regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'\\\\-äåéöÄÅÉÖ]*$"},"phone":{"maxLength":"15","minLength":"10","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-äåéöÄÅÉÖ]*$","maxLength":"35","mandatory":false,"hidden":false,"options":{}}},"HR":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"KZ":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"EE":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"HK":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"NG":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"PK":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"EG":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"GH":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","required":false,"minLength":"0","maxLength":"12","mandatory":true,"regEx":"^[A-Za-z0-9-]*$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"GR":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{3}\\\\s{0,1}\\\\d{2}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"BH":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{3,4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"IN":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"PH":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"ID":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"IL":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"7","mandatory":true,"regEx":"^\\\\b\\\\d{5}(\\\\d{2})?$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"LB":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"9","mandatory":true,"regEx":"^\\\\d{4}(?:[-\\\\s]\\\\d{4})?$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"TW":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"TH":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"VN":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"AZ":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^[Aa][Zz]\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"BG":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"CY":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"MY":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"NZ":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"NE":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"QA":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":false,"hidden":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"RU":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"SG":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"6","mandatory":true,"regEx":"^\\\\d{6}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"SK":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"12","mandatory":true,"regEx":"^\\\\d{5}\\\\s\\\\(\\\\d{3}\\\\s\\\\d{2}\\\\)$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"ZA":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"minLength":"9","regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"TK":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"UA":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"MO":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"4","mandatory":false,"hidden":true,"regEx":"^\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"MT":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"16","mandatory":true,"regEx":"^[A-Za-z]{3}\\\\s{0,1}\\\\d{4}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"SI":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"12","mandatory":true,"regEx":"^([Ss][Ii][- ]{0,1}){0,1}\\\\d{4}$$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}},"TR":{"firstName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"lastName":{"regEx":"(^[a-zA-Z\\\\s.\\\\-,\']*$)"},"address1":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"address2":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"postalCode":{"type":"tel","padding":"true","maxLength":"5","mandatory":true,"regEx":"^\\\\d{5}$"},"city":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$"},"phone":{"regEx":"^\\\\+[1-9]\\\\d{1,14}$"},"resources":{"stateLabel":"province","zipLabel":"postal"},"states":{"regEx":"^[\\\\da-zA-Z\\\\s«»\\\\^\\\\[?;:¨!§$£€%µ\\\\/\\\\)\\\\(\\\\}\\\\{\\\\]|\\\\+`\\\\*=~&#_@°²,.\'-]*$","maxLength":"100","mandatory":true,"hidden":false,"options":{}}}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
/*!**************************************************************************!*\
  !*** ./cartridges/app_mk_storefront/cartridge/client/default/js/main.js ***!
  \**************************************************************************/
var dateString = new Date().toISOString();
console.log('Page Loaded Started at :', dateString); // eslint-disable-line no-console

window.jQuery = window.$ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");

var processInclude = __webpack_require__(/*! ./util */ "./cartridges/app_mk_storefront/cartridge/client/default/js/util.js");

$(document).ready(function () {
  processInclude(__webpack_require__(/*! ./components/ada */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/ada.js"));
  processInclude(__webpack_require__(/*! ./components/header */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/header.js"));
  processInclude(__webpack_require__(/*! ./components/countryRedirectModal */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/countryRedirectModal.js"));
  processInclude(__webpack_require__(/*! ./components/menu */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/menu.js"));
  processInclude(__webpack_require__(/*! ./components/cookie */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/cookie.js"));
  processInclude(__webpack_require__(/*! ./components/consentTracking */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/consentTracking.js"));
  processInclude(__webpack_require__(/*! ./components/footer */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/footer.js"));
  processInclude(__webpack_require__(/*! ./components/miniCart */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/miniCart.js"));
  processInclude(__webpack_require__(/*! ./components/collapsibleItem */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/collapsibleItem.js"));
  processInclude(__webpack_require__(/*! ./components/search */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/search.js"));
  processInclude(__webpack_require__(/*! ./components/clientSideValidation */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/clientSideValidation.js"));
  processInclude(__webpack_require__(/*! ./components/countrySelector */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/countrySelector.js"));
  processInclude(__webpack_require__(/*! ./components/toolTip */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/toolTip.js"));
  processInclude(__webpack_require__(/*! ./components/capriCountrySelector */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/capriCountrySelector.js"));
  processInclude(__webpack_require__(/*! ./login/accountLogin */ "./cartridges/app_mk_storefront/cartridge/client/default/js/login/accountLogin.js"));
  processInclude(__webpack_require__(/*! ./product/wishlist */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlist.js"));
  processInclude(__webpack_require__(/*! ./product/quickView */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/quickView.js"));
  processInclude(__webpack_require__(/*! ./product/favorites */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/favorites.js"));
  processInclude(__webpack_require__(/*! ./csrfHelper */ "./cartridges/app_mk_storefront/cartridge/client/default/js/csrfHelper.js"));
  processInclude(__webpack_require__(/*! ./product/wishlistHeart */ "./cartridges/app_mk_storefront/cartridge/client/default/js/product/wishlistHeart.js"));
  processInclude(__webpack_require__(/*! int_syte/components/syte */ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/syte.js"));
  processInclude(__webpack_require__(/*! int_syte/components/header */ "../../capri-core-sfcc/src/cartridges/int_syte/cartridge/client/default/js/components/header.js"));
  processInclude(__webpack_require__(/*! int_shoppinggives/components/setSGTrackingId */ "../../capri-core-sfcc/src/cartridges/int_shoppinggives/cartridge/client/default/js/components/setSGTrackingId.js"));
});

__webpack_require__(/*! ./bootstrap */ "./cartridges/app_mk_storefront/cartridge/client/default/js/bootstrap.js");

__webpack_require__(/*! ./components/spinner */ "./cartridges/app_mk_storefront/cartridge/client/default/js/components/spinner.js");

__webpack_require__(/*! ./utilities/lazysizesConfig */ "./cartridges/app_mk_storefront/cartridge/client/default/js/utilities/lazysizesConfig.js");

__webpack_require__(/*! lazysizes/lazysizes.min */ "./node_modules/lazysizes/lazysizes.min.js");

__webpack_require__(/*! slick-carousel/slick/slick.min.js */ "./node_modules/slick-carousel/slick/slick.min.js");
}();
/******/ })()
;
//# sourceMappingURL=main.js.map